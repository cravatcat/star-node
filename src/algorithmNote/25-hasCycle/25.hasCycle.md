# 环形链表 (Linked List Cycle)

## 1. 题目描述

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 `true` 。 否则，返回 `false` 。

**示例 1:**

![circularlinkedlist](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

> **输入:** head = [3,2,0,-4], pos = 1  
> **输出:** true  
> **解释:** 链表中有一个环，其尾部连接到第二个节点。

**示例 2:**

![circularlinkedlist_test2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

> **输入:** head = [1,2], pos = 0  
> **输出:** true  
> **解释:** 链表中有一个环，其尾部连接到第一个节点。

**示例 3:**

![circularlinkedlist_test3](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

> **输入:** head = [1], pos = -1  
> **输出:** false  
> **解释:** 链表中没有环。

## 2. 实现思路

判断链表是否有环，最经典的方法是 **快慢指针法 (Floyd's Cycle-Finding Algorithm)**，也就是俗称的“龟兔赛跑”算法。

我们定义两个指针，一快一慢：
*   **慢指针 (slow)**：每次只移动一步。
*   **快指针 (fast)**：每次移动两步。

**原理：**
*   如果链表中没有环，快指针最终会遇到 `null`（到达链表尾部），此时可以直接返回 `false`。
*   如果链表中存在环，快指针和慢指针最终都会进入环中。因为快指针移动得快，它就像是在环形跑道上追赶慢指针。只要有足够的时间，**快指针一定会在环内追上慢指针**（即 `fast === slow`）。

## 3. 详细步骤

1.  处理边界情况：如果链表为空 (`head === null`) 或者链表只有一个节点 (`head.next === null`)，显然不可能有环，直接返回 `false`。
2.  初始化两个指针：
    *   `slow = head`
    *   `fast = head.next` (或者 `fast = head`，然后先移动再判断，这里采用 `head.next` 以便进入循环)
3.  进入循环，条件是 `slow !== fast`：
    *   在循环内部，首先检查 `fast` 和 `fast.next` 是否为 `null`。如果是，说明链表有尽头，没有环，返回 `false`。
    *   `slow` 向前移动一步：`slow = slow.next`
    *   `fast` 向前移动两步：`fast = fast.next.next`
4.  如果循环结束（即 `slow === fast`），说明快慢指针相遇了，链表中存在环，返回 `true`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function hasCycle(head: ListNode | null): boolean {
    if (!head || !head.next) {
        return false;
    }

    let slow: ListNode | null = head;
    let fast: ListNode | null = head.next;

    while (slow !== fast) {
        // 如果快指针到达链表尾部，说明没有环
        if (!fast || !fast.next) {
            return false;
        }
        slow = slow!.next;
        fast = fast.next.next;
    }

    return true;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。
    *   **无环情况**: 快指针移动到链表末尾，时间取决于链表长度 $n$。
    *   **有环情况**: 两个指针都会进入环。设非环部分长度为 $N$，环长度为 $K$。快慢指针在环内相遇所需的移动次数大约与 $K$ 成正比，总体不超过 $O(n)$。
*   **空间复杂度**: $O(1)$。我们只使用了两个指针变量。
