# 滑动窗口最大值 (Sliding Window Maximum)

## 1. 题目描述

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 **滑动窗口中的最大值** 。

**示例 1:**

> **输入:** nums = [1,3,-1,-3,5,3,6,7], k = 3  
> **输出:** [3,3,5,5,6,7]  
> **解释:** 
> 
> | 滑动窗口的位置 | 最大值 |
> | :--- | :---: |
> | [1 3 -1] -3 5 3 6 7 | 3 |
> | 1 [3 -1 -3] 5 3 6 7 | 3 |
> | 1 3 [-1 -3 5] 3 6 7 | 5 |
> | 1 3 -1 [-3 5 3] 6 7 | 5 |
> | 1 3 -1 -3 [5 3 6] 7 | 6 |
> | 1 3 -1 -3 5 [3 6 7] | 7 |

**示例 2:**

> **输入:** nums = [1], k = 1  
> **输出:** [1]

## 2. 实现思路

最直观的解法是对于每个窗口都遍历一遍寻找最大值，时间复杂度是 $O(n \cdot k)$，但这会超时。我们需要一个 $O(n)$ 的解法。

我们可以使用 **单调队列 (Monotonic Queue)**（通常使用双端队列 Deque 实现）。

**核心思想**：
我们需要一个队列，这个队列存放的是窗口内**可能成为最大值**的元素的**下标**。
并且，这个队列中的元素对应的数值必须是 **单调递减** 的。

为什么是单调递减？
假设队列中有两个元素，下标分别为 `i` 和 `j`，且 `i < j`。
如果 `nums[i] < nums[j]`，那么 `nums[i]` 永远不可能成为最大值了。因为 `nums[j]` 比它大，而且比它晚离开窗口（`j` 的下标更大，存活时间更长）。
所以，只要 `nums[j]` 进来了，比它小且在它前面的 `nums[i]` 就可以直接淘汰（出队）。

这样，队列的 **头部** 永远是当前窗口的 **最大值**。

## 3. 详细步骤

1.  初始化一个双端队列 `deque`（存储下标），和一个结果数组 `result`。
2.  遍历数组 `nums`，索引为 `i`：
    *   **移除过期元素**：检查队头元素（`deque[0]`）是否已经滑出窗口（即 `deque[0] < i - k + 1`）。如果是，移出队头。
    *   **维护单调性**：检查队尾元素。如果当前元素 `nums[i]` 大于队尾元素 `nums[deque[last]]`，说明队尾元素不可能是最大值了，将其移除。重复此过程，直到队列为空或队尾元素大于等于 `nums[i]`。
    *   **入队**：将当前元素下标 `i` 加入队尾。
    *   **记录结果**：当窗口形成后（`i >= k - 1`），将队头元素 `nums[deque[0]]` 加入结果数组。
3.  返回 `result`。

## 4. 代码实现 (TypeScript)

```typescript
function maxSlidingWindow(nums: number[], k: number): number[] {
    if (nums.length === 0 || k === 0) return [];
    
    const deque: number[] = []; // 存储的是下标，不是值
    const result: number[] = [];
    
    for (let i = 0; i < nums.length; i++) {
        // 1. 移除队列中已经滑出窗口的元素（下标过小）
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();
        }
        
        // 2. 维护单调递减队列
        // 如果当前元素 nums[i] 大于队列尾部的元素，说明队列尾部的元素不可能是最大值了，直接移除
        // 只要进来的比队尾大，队尾就被淘汰，保证队头永远是最大的
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        
        // 3. 将当前元素下标加入队列
        deque.push(i);
        
        // 4. 记录当前窗口的最大值（队列头部元素）
        // 当窗口形成后（i >= k - 1），开始记录结果
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
};
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。
    *   虽然代码里有 `while` 循环，但是每个元素最多被 `push` 进队列一次，也最多被 `pop` 出队列一次。所以均摊下来是线性的。
*   **空间复杂度**: $O(k)$。
    *   双端队列最多存储 $k$ 个元素。
