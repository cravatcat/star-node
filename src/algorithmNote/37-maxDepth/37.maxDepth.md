# 二叉树的最大深度 (Maximum Depth of Binary Tree)

## 1. 题目描述

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

## 2. 实现思路

### 方法一：递归 (Recursion) / 深度优先搜索 (DFS)
这是一个非常经典的递归问题。
*   如果根节点为空，深度为 0。
*   如果根节点不为空，那么这棵树的深度 = `max(左子树的深度, 右子树的深度) + 1`。
*   我们只需要递归地求出左右子树的深度，然后取较大值加 1 即可。

### 方法二：广度优先搜索 (BFS)
我们也可以使用层序遍历（BFS）来解决。
*   使用一个队列 `queue` 存放当前层的节点。
*   每遍历一层，深度 `ans` 加 1。
*   直到队列为空，说明遍历完所有层，返回 `ans`。

这里主要介绍最简洁的 **递归 DFS** 方法。

## 3. 详细步骤 (递归法)

1.  **终止条件**：如果当前节点 `root` 为 `null`，返回 0。
2.  **递归调用**：
    *   递归计算左子树的最大深度：`leftDepth = maxDepth(root.left)`。
    *   递归计算右子树的最大深度：`rightDepth = maxDepth(root.right)`。
3.  **返回结果**：当前节点的最大深度 = `Math.max(leftDepth, rightDepth) + 1`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function maxDepth(root: TreeNode | null): number {
    // 1. 如果节点为空，深度为 0
    if (root === null) {
        return 0;
    }
    
    // 2. 递归计算左右子树的深度
    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);
    
    // 3. 返回较大值 + 1 (当前节点)
    return Math.max(leftDepth, rightDepth) + 1;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。其中 $n$ 是二叉树的节点数。我们需要遍历每个节点一次。
*   **空间复杂度**: $O(height)$。其中 $height$ 是二叉树的高度。递归函数需要栈空间，栈的深度取决于树的高度。
    *   最坏情况下（树退化为链表），空间复杂度为 $O(n)$。
    *   平均情况下（树比较平衡），空间复杂度为 $O(\log n)$。
