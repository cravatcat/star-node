# 环形链表 II (Linked List Cycle II)

## 1. 题目描述

给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1:**

![circularlinkedlist](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

> **输入:** head = [3,2,0,-4], pos = 1  
> **输出:** 返回索引为 1 的链表节点  
> **解释:** 链表中有一个环，其尾部连接到第二个节点。

**示例 2:**

![circularlinkedlist_test2](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

> **输入:** head = [1,2], pos = 0  
> **输出:** 返回索引为 0 的链表节点  
> **解释:** 链表中有一个环，其尾部连接到第一个节点。

**示例 3:**

![circularlinkedlist_test3](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

> **输入:** head = [1], pos = -1  
> **输出:** 返回 null  
> **解释:** 链表中没有环。

## 2. 实现思路

这道题是 **环形链表 I** 的进阶版。我们不仅要判断是否有环，还要找到环的入口。

依然使用 **快慢指针 (Floyd's Cycle-Finding Algorithm)**。

假设：
*   链表头到环入口的距离为 $a$。
*   环入口到相遇点的距离为 $b$。
*   相遇点到环入口的距离为 $c$。
*   环的周长为 $L = b + c$。

**第一阶段：判断是否有环**
快指针 `fast` 每次走 2 步，慢指针 `slow` 每次走 1 步。
当 `fast` 和 `slow` 相遇时：
*   `slow` 走过的路程：$a + b$
*   `fast` 走过的路程：$a + b + n(b + c)$ （其中 $n$ 是 `fast` 在环内绕的圈数，至少为 1）

因为 `fast` 的速度是 `slow` 的 2 倍，所以：
$2(a + b) = a + b + n(b + c)$
$a + b = n(b + c)$
$a = n(b + c) - b$
$a = (n - 1)(b + c) + c$

**关键推导：**
当 $n=1$ 时（最简单情况），$a = c$。
这意味着：**从链表头到环入口的距离 ($a$) 等于从相遇点继续走到环入口的距离 ($c$)。**

即使 $n > 1$，也是一样的结论：从链表头出发走 $a$ 步，和从相遇点出发走 $a$ 步（可能会在环里绕圈），最终都会在环入口相遇。

**第二阶段：寻找环入口**
1.  当 `fast` 和 `slow` 相遇后，我们将 `fast`（或者 `slow`，任选一个）重置回链表头部 `head`。
2.  然后让 `fast` 和 `slow` **同时移动**，但这次 **每次都只走 1 步**。
3.  根据 $a = c$ 的推导，它们必然会在环的入口节点相遇。

## 3. 详细步骤

1.  初始化 `slow = head`, `fast = head`。
2.  循环移动 `slow` (1步) 和 `fast` (2步)，直到它们相遇或者 `fast` 遇到 `null`。
    *   如果 `fast` 或 `fast.next` 为 `null`，说明无环，返回 `null`。
3.  当 `slow === fast` 时（相遇），将 `fast` 重置为 `head`。
4.  循环移动 `slow` 和 `fast`，每次都只走 1 步，直到它们再次相遇。
5.  再次相遇的节点即为环的入口，返回该节点。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function detectCycle(head: ListNode | null): ListNode | null {
    if (!head || !head.next) {
        return null;
    }

    let slow: ListNode | null = head;
    let fast: ListNode | null = head;

    // 1. 判断是否有环
    while (fast !== null && fast.next !== null) {
        slow = slow!.next;
        fast = fast.next.next;
        if (slow === fast) {
            // 2. 找到环的入口
            // 将 fast 指针重新指向头节点
            fast = head;
            // slow 和 fast 同时移动，每次一步，相遇点即为环入口
            while (slow !== fast) {
                slow = slow!.next;
                fast = fast!.next;
            }
            return slow;
        }
    }

    return null;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。快慢指针相遇前，指针移动次数不会超过链表长度。寻找入口时，也只遍历了一部分链表。
*   **空间复杂度**: $O(1)$。只使用了常数个指针变量。
