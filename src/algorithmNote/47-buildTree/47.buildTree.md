# 105. 从前序与中序遍历序列构造二叉树

## 题目描述

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的先序遍历， `inorder` 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

## 实现思路

二叉树的遍历性质：
- **前序遍历**：`[ 根节点, [左子树的前序遍历], [右子树的前序遍历] ]`
- **中序遍历**：`[ [左子树的中序遍历], 根节点, [右子树的中序遍历] ]`

我们可以利用这些性质递归地构造二叉树：
1. `preorder` 的第一个元素一定是当前的 **根节点**。
2. 在 `inorder` 中找到这个根节点的位置 `index`。
3. 此时，`inorder` 中 `index` 左边的元素构成了 **左子树**，右边的元素构成了 **右子树**。
4. 根据左子树的节点数量，我们也可以在 `preorder` 中确定左子树和右子树的范围。
5. 递归构造左子树和右子树。

为了快速定位根节点在 `inorder` 中的位置，我们可以预先使用哈希表存储 `val -> index` 的映射。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function buildTree(preorder: number[], inorder: number[]): TreeNode | null {
  const map = new Map<number, number>();
  
  // 记录中序遍历每个值对应的索引，便于快速查找
  for (let i = 0; i < inorder.length; i++) {
    map.set(inorder[i], i);
  }
  
  return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, map);
}

function build(
  preorder: number[], 
  preStart: number, 
  preEnd: number, 
  inorder: number[], 
  inStart: number, 
  inEnd: number, 
  map: Map<number, number>
): TreeNode | null {
  if (preStart > preEnd || inStart > inEnd) {
    return null;
  }

  // 前序遍历的第一个节点是根节点
  const rootVal = preorder[preStart];
  const root = new TreeNode(rootVal);
  
  // 在中序遍历中找到根节点的位置
  const inRoot = map.get(rootVal)!;
  
  // 左子树的节点数量
  const numsLeft = inRoot - inStart;

  // 递归构建左子树
  root.left = build(
    preorder, 
    preStart + 1, 
    preStart + numsLeft, 
    inorder, 
    inStart, 
    inRoot - 1, 
    map
  );
  
  // 递归构建右子树
  root.right = build(
    preorder, 
    preStart + numsLeft + 1, 
    preEnd, 
    inorder, 
    inRoot + 1, 
    inEnd, 
    map
  );

  return root;
}
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是二叉树的节点数。我们需要遍历每个节点一次来构造树，哈希表的查找操作是 O(1) 的。
- **空间复杂度**：O(n)，需要 O(n) 的空间存储哈希表，以及 O(n) 的递归栈空间（最坏情况下）。
