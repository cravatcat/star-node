# 接雨水 (Trapping Rain Water)

## 1. 题目描述

给定 `n` 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1:**

![rainwatertrap.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

> **输入:** height = [0,1,0,2,1,0,1,3,2,1,2,1]  
> **输出:** 6  
> **解释:** 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**示例 2:**

> **输入:** height = [4,2,0,3,2,5]  
> **输出:** 9

## 2. 实现思路

本题有多种解法（动态规划、单调栈、双指针）。其中 **双指针** 法空间复杂度最优，为 $O(1)$。

核心思想是：对于每一列，它能接的水量取决于 **它左边最高的柱子** 和 **它右边最高的柱子** 之间的较小值，即 `min(leftMax, rightMax) - height[i]`（如果结果大于 0）。

使用双指针时，我们维护 `left` 和 `right` 两个指针，以及 `leftMax` 和 `rightMax` 分别记录左边和右边目前遇到的最大高度。

*   如果 `height[left] < height[right]`：
    *   说明对于 `left` 指针所指的列，其右边一定有一个比它高的（至少是 `height[right]`），所以它能接多少水完全取决于 `leftMax`。
    *   我们更新 `leftMax`，计算当前列的积水量，然后 `left++`。
*   如果 `height[left] >= height[right]`：
    *   说明对于 `right` 指针所指的列，其左边一定有一个比它高的（至少是 `height[left]`），所以它能接多少水完全取决于 `rightMax`。
    *   我们更新 `rightMax`，计算当前列的积水量，然后 `right--`。

## 3. 详细步骤

1.  初始化 `left = 0`, `right = n - 1`。
2.  初始化 `leftMax = 0`, `rightMax = 0`，`ans = 0`。
3.  当 `left < right` 时循环：
    *   更新 `leftMax = max(leftMax, height[left])`。
    *   更新 `rightMax = max(rightMax, height[right])`。
    *   如果 `height[left] < height[right]`：
        *   当前位置能接的水量为 `leftMax - height[left]`（因为已经更新了 `leftMax`，所以这个值至少为 0）。
        *   `ans += leftMax - height[left]`。
        *   `left++`。
    *   否则：
        *   当前位置能接的水量为 `rightMax - height[right]`。
        *   `ans += rightMax - height[right]`。
        *   `right--`。
4.  返回 `ans`。

## 4. 代码实现 (TypeScript)

```typescript
function trap(height: number[]): number {
  let left = 0;
  let right = height.length - 1;
  let leftMax = 0;
  let rightMax = 0;
  let ans = 0;

  while (left < right) {
    // 更新左右两边的最大高度
    leftMax = Math.max(leftMax, height[left]);
    rightMax = Math.max(rightMax, height[right]);

    // 谁小结算谁
    if (height[left] < height[right]) {
      ans += leftMax - height[left];
      left++;
    } else {
      ans += rightMax - height[right];
      right--;
    }
  }

  return ans;
};
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。
    *   只需要遍历一次数组，两个指针相遇即停止。
*   **空间复杂度**: $O(1)$。
    *   只使用了常数个变量。
