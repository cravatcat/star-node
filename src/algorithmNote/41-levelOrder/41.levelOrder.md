# 二叉树的层序遍历 (Binary Tree Level Order Traversal)

## 1. 题目描述

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![tree1](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

> **输入：** root = [3,9,20,null,null,15,7]  
> **输出：** [[3],[9,20],[15,7]]

**示例 2：**

> **输入：** root = [1]  
> **输出：** [[1]]

**示例 3：**

> **输入：** root = []  
> **输出：** []

## 2. 实现思路

层序遍历通常使用 **广度优先搜索 (BFS)** 来实现。
我们可以借助一个 **队列 (Queue)** 来存储当前层的节点。

1.  如果 `root` 为空，返回空数组。
2.  初始化队列 `queue`，将 `root` 加入队列。
3.  当队列不为空时，进行循环：
    *   获取当前队列的长度 `currentLevelSize`，这个长度就是当前层的节点数量。
    *   初始化一个空数组 `currentLevel` 用于存储当前层的结果。
    *   循环 `currentLevelSize` 次（处理当前层的所有节点）：
        *   从队首取出一个节点 `node`。
        *   将 `node.val` 加入 `currentLevel`。
        *   如果 `node` 有左子节点，将左子节点加入队列。
        *   如果 `node` 有右子节点，将右子节点加入队列。
    *   将 `currentLevel` 加入最终结果 `res`。
4.  返回 `res`。

## 3. 代码实现 (TypeScript)

```typescript
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function levelOrder(root: TreeNode | null): number[][] {
    const res: number[][] = [];
    if (!root) {
        return res;
    }

    const queue: TreeNode[] = [root];

    while (queue.length > 0) {
        // 记录当前层的节点数
        const currentLevelSize = queue.length;
        const currentLevel: number[] = [];

        // 遍历当前层的所有节点
        for (let i = 0; i < currentLevelSize; i++) {
            const node = queue.shift()!; // 出队
            currentLevel.push(node.val);
            
            // 将下一层的子节点入队
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }
        res.push(currentLevel);
    }

    return res;
}
```

## 4. 复杂度分析

*   **时间复杂度**: $O(n)$。其中 $n$ 是二叉树的节点数。每个节点进队和出队各一次。
*   **空间复杂度**: $O(n)$。队列中最多需要存储一层的节点，最坏情况下（满二叉树的最底层）大约有 $n/2$ 个节点。
