# 39. 组合总和

## 题目描述

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

## 实现思路

这也是一个 **回溯** 问题。与“子集”问题类似，但有两点不同：
1. 限制条件变为：元素和等于 `target`。
2. 元素可以重复使用：这意味着在递归调用时，下一层的 `startIndex` 仍然可以是当前索引 `i`，而不是 `i + 1`。

**回溯算法框架**：
1. `path`：记录当前组合。
2. `currentSum`：记录当前组合的和。
3. `startIndex`：控制遍历起点，避免产生重复组合（如 `[2, 2, 3]` 和 `[3, 2, 2]`）。

**具体步骤**：
1. 终止条件：
   - `currentSum === target`：找到一个合法组合，加入 `res`，返回。
   - `currentSum > target`：和已超过目标，剪枝，返回。
2. 遍历 `candidates`（从 `startIndex` 开始）：
   - 做选择：`path.push(candidates[i])`，更新 `currentSum`。
   - 递归：`backtrack(i, currentSum)`（注意传入 `i`，表示可以重复选当前数）。
   - 撤销选择：`path.pop()`。

## 代码实现

```typescript
export function combinationSum(candidates: number[], target: number): number[][] {
  const res: number[][] = [];
  const path: number[] = [];

  function backtrack(startIndex: number, currentSum: number) {
    // 找到目标和
    if (currentSum === target) {
      res.push([...path]);
      return;
    }

    // 超过目标和，剪枝
    if (currentSum > target) {
      return;
    }

    for (let i = startIndex; i < candidates.length; i++) {
      path.push(candidates[i]);
      // 关键点：递归传入 i，表示当前元素 candidates[i] 可以重复使用
      backtrack(i, currentSum + candidates[i]);
      path.pop();
    }
  }

  backtrack(0, 0);
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(S)，其中 S 是所有可行解的长度之和。最坏情况下（例如 candidates=[1], target=N），复杂度是指数级的。
- **空间复杂度**：O(target)，递归栈的深度最深为 `target`（每次都选最小的 1）。
