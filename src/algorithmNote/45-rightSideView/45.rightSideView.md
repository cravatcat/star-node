# 199. 二叉树的右视图

## 题目描述

给定一个二叉树的 根节点 `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

## 实现思路

我们可以对二叉树进行 **层序遍历** (BFS)。
在层序遍历中，我们是一层一层地访问节点的。对于每一层来说，**最后一个被访问的节点** 也就是最右边的节点，正是我们从右侧能看到的节点。

具体步骤：
1. 使用队列 `queue` 进行层序遍历，初始时将 `root` 加入队列。
2. 当队列不为空时，循环执行：
   - 获取当前队列的长度 `size`，这代表当前层的节点数量。
   - 遍历这 `size` 个节点：
     - 取出队首节点。
     - 如果是该层的最后一个节点（下标为 `size - 1`），将其值加入结果数组。
     - 将该节点的左右子节点（如果不为空）加入队列。
3. 返回结果数组。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function rightSideView(root: TreeNode | null): number[] {
  const res: number[] = [];
  if (!root) {
    return res;
  }

  const queue: TreeNode[] = [root];

  while (queue.length > 0) {
    const size = queue.length;
    
    for (let i = 0; i < size; i++) {
      const node = queue.shift()!;
      
      // 如果是当前层的最后一个节点，加入结果集
      if (i === size - 1) {
        res.push(node.val);
      }
      
      if (node.left) {
        queue.push(node.left);
      }
      if (node.right) {
        queue.push(node.right);
      }
    }
  }
  
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是二叉树的节点数。我们需要遍历树中的每一个节点。
- **空间复杂度**：O(n)，最坏情况下（例如完全二叉树），队列中最多会包含 n/2 个节点（最后一层的节点数）。
