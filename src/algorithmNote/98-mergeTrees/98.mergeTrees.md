# 98. 合并二叉树

## 题目描述

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。

合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。

## 实现思路

这道题可以使用递归（DFS）来解决。

算法流程：
1. **递归终止条件**：
   - 如果 `root1` 为空，则返回 `root2`（因为没有节点与 `root2` 合并，直接返回 `root2` 即可）。
   - 如果 `root2` 为空，则返回 `root1`。
2. **递归过程**：
   - 如果两个节点都不为空，创建一个新节点 `merged`，其值为 `root1.val + root2.val`。
   - 递归合并左子树：`merged.left = mergeTrees(root1.left, root2.left)`。
   - 递归合并右子树：`merged.right = mergeTrees(root1.right, root2.right)`。
   - 返回 `merged`。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
  if (!root1) return root2;
  if (!root2) return root1;

  const merged = new TreeNode(root1.val + root2.val);
  merged.left = mergeTrees(root1.left, root2.left);
  merged.right = mergeTrees(root1.right, root2.right);

  return merged;
}
```

## 复杂度分析

- **时间复杂度**：O(min(m, n))，其中 m 和 n 分别是两棵树的节点个数。我们只需要访问两棵树中重叠的节点。
- **空间复杂度**：O(min(m, n))，递归调用的层数取决于较小树的高度。在最坏情况下，树退化为链表，空间复杂度为 O(min(m, n))。
