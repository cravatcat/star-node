# 100. 比特位计数

## 题目描述

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **1 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

## 实现思路

这道题可以使用 **动态规划** 来解决，时间复杂度为 O(n)。

观察规律：
- 对于偶数 `i`，其二进制表示中 1 的个数与 `i / 2`（即 `i >> 1`）相同。因为偶数最低位是 0，右移一位不丢失 1。
- 对于奇数 `i`，其二进制表示中 1 的个数比 `i - 1`（前一个偶数）多 1，或者也可以看作是 `i / 2` 的 1 的个数加 1（因为奇数最低位是 1，右移丢失了这个 1）。

统一的状态转移方程：
`bits[i] = bits[i >> 1] + (i & 1)`

- `i >> 1`：去掉最低位后的数字。
- `i & 1`：最低位的值（0 或 1）。

## 代码实现

```typescript
export function countBits(n: number): number[] {
  const bits = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    // i >> 1 相当于 i / 2，去掉最低位
    // i & 1 相当于 i % 2，获取最低位
    bits[i] = bits[i >> 1] + (i & 1);
  }
  return bits;
}
```

## 复杂度分析

- **时间复杂度**：O(n)。只需要遍历一次 0 到 n。
- **空间复杂度**：O(1)。除了返回的数组外，只需要常数空间（题目要求返回数组不算在额外空间内）。
