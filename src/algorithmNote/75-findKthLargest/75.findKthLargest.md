# 75. 数组中的第K个最大元素

## 题目描述

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```text
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```text
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

## 实现思路

这道题要求 O(n) 的时间复杂度，最常用的方法是 **快速选择算法 (Quick Select)**。

快速选择算法基于快速排序的思想：
1. 选择一个基准元素（pivot）。
2. 将数组分为两部分：一部分大于 pivot，一部分小于 pivot。
3. 判断 pivot 所在的位置是否正好是第 k 个位置（索引为 `k-1`）。
   - 如果是，直接返回 pivot。
   - 如果 `k-1` 小于 pivot 的索引，说明第 k 大元素在左半部分，递归左半部分。
   - 如果 `k-1` 大于 pivot 的索引，说明第 k 大元素在右半部分，递归右半部分。

为了方便，我们可以实现一个降序排列的 `partition` 函数，这样第 k 大的元素就正好位于索引 `k-1` 处。

## 代码实现

```typescript
export function findKthLargest(nums: number[], k: number): number {
  // 使用快速选择算法 (Quick Select)
  const quickSelect = (left: number, right: number, k: number): number => {
    if (left === right) return nums[left];

    const pivotIndex = partition(left, right);

    if (k === pivotIndex) {
      return nums[k];
    } else if (k < pivotIndex) {
      return quickSelect(left, pivotIndex - 1, k);
    } else {
      return quickSelect(pivotIndex + 1, right, k);
    }
  };

  const partition = (left: number, right: number): number => {
    const pivot = nums[right];
    let i = left;
    
    for (let j = left; j < right; j++) {
      // 如果要是第 K 大，我们通常按降序排，或者找第 N-K 小
      // 这里我们找的是第 N-K+1 小的元素，或者直接按降序排找第 K 个
      // 为了方便，我们这里实现降序排列的 partition
      if (nums[j] > pivot) {
        [nums[i], nums[j]] = [nums[j], nums[i]];
        i++;
      }
    }
    [nums[i], nums[right]] = [nums[right], nums[i]];
    return i;
  };

  // 因为我们是降序排列，所以第 K 大元素的索引就是 k - 1
  return quickSelect(0, nums.length - 1, k - 1);
}
```

## 复杂度分析

- **时间复杂度**：O(n)，平均情况下。最坏情况（每次 partition 都很不平衡）下为 O(n^2)，但可以通过随机选择 pivot 来避免。
- **空间复杂度**：O(1)（迭代版）或 O(log n)（递归栈空间）。
