# 72. 最小栈

## 题目描述

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

```text
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

## 实现思路

要实现 O(1) 时间复杂度的 `getMin`，我们可以使用 **辅助栈** 的方法。

我们维护两个栈：
1. `stack`：普通栈，存储所有元素。
2. `minStack`：最小栈，存储当前的最小值。

操作逻辑：
- **push(val)**：
  - 将 `val` 压入 `stack`。
  - 如果 `minStack` 为空，或者 `val` 小于等于 `minStack` 的栈顶元素，将 `val` 也压入 `minStack`。
  - 这样 `minStack` 的栈顶始终是当前 `stack` 中的最小值。
- **pop()**：
  - 弹出 `stack` 的栈顶元素 `val`。
  - 如果 `val` 等于 `minStack` 的栈顶元素，说明最小值被移除了，`minStack` 也要弹出栈顶元素。
- **top()**：
  - 直接返回 `stack` 的栈顶元素。
- **getMin()**：
  - 直接返回 `minStack` 的栈顶元素。

## 代码实现

```typescript
export class MinStack {
  private stack: number[];
  private minStack: number[];

  constructor() {
    this.stack = [];
    this.minStack = [];
  }

  push(val: number): void {
    this.stack.push(val);
    // 如果 minStack 为空，或者 val 小于等于 minStack 栈顶元素，则入 minStack
    // 注意这里是 <=，如果有重复的最小值，也需要入栈
    if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {
      this.minStack.push(val);
    }
  }

  pop(): void {
    const val = this.stack.pop();
    // 如果弹出的元素等于 minStack 栈顶元素，则 minStack 也弹出
    if (val === this.minStack[this.minStack.length - 1]) {
      this.minStack.pop();
    }
  }

  top(): number {
    return this.stack[this.stack.length - 1];
  }

  getMin(): number {
    return this.minStack[this.minStack.length - 1];
  }
}
```

## 复杂度分析

- **时间复杂度**：所有操作（`push`, `pop`, `top`, `getMin`）的时间复杂度都是 O(1)。
- **空间复杂度**：O(n)，其中 n 是栈中元素的数量。我们需要额外的辅助栈。
