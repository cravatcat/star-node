# 63. 搜索二维矩阵

## 题目描述

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```text
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

```text
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

## 实现思路

由于矩阵具有以下特性：
1. 每行从左到右递增。
2. 每行第一个数大于上一行最后一个数。

这意味着如果我们把矩阵的每一行拼接起来，会得到一个严格递增的一维数组。
因此，我们可以将这个二维矩阵视为一个长度为 `m * n` 的有序数组，并直接在这个虚拟的数组上进行 **二分查找**。

具体步骤：
1. 设矩阵行数为 `m`，列数为 `n`。
2. 二分查找的范围是 `left = 0` 到 `right = m * n - 1`。
3. 在二分查找过程中，计算中间索引 `mid`。
   - 需要将一维索引 `mid` 转换为二维坐标 `(row, col)`：
     - `row = Math.floor(mid / n)`
     - `col = mid % n`
4. 比较 `matrix[row][col]` 与 `target` 的大小，调整 `left` 或 `right`。

## 代码实现

```typescript
export function searchMatrix(matrix: number[][], target: number): boolean {
  if (!matrix.length || !matrix[0].length) return false;
  
  const m = matrix.length;
  const n = matrix[0].length;
  
  // 将二维矩阵视为一个有序的一维数组进行二分查找
  // 范围是 [0, m * n - 1]
  let left = 0;
  let right = m * n - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    // 将一维索引映射回二维坐标
    const row = Math.floor(mid / n);
    const col = mid % n;
    const val = matrix[row][col];

    if (val === target) {
      return true;
    } else if (val < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return false;
}
```

## 复杂度分析

- **时间复杂度**：O(log(mn))，其中 m 和 n 分别是矩阵的行数和列数。我们在长度为 `m * n` 的虚拟数组上进行二分查找。
- **空间复杂度**：O(1)，只使用了常数级额外空间。
