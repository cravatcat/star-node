# 51. N 皇后

## 题目描述

按照国际象棋的规则，皇后可以攻击与之处在同一行、同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

## 实现思路

这是最经典的回溯算法题目之一。

我们需要在每一行放置一个皇后，并保证它不与前面已经放置的皇后冲突。

**冲突检查**：
1. **列冲突**：当前列 `col` 是否已有皇后。
2. **主对角线冲突**：`row - col` 是否相同。
3. **副对角线冲突**：`row + col` 是否相同。

我们可以使用三个集合（Set）来快速判断这三种冲突：`cols`, `diag1`, `diag2`。

**回溯算法框架**：
1. `row`：当前正在放置第几行的皇后。
2. 遍历当前行的每一列 `col`：
   - 检查是否有冲突。
   - 如果无冲突：放置皇后，更新集合，递归进入下一行 `row + 1`。
   - 回溯：移除皇后，恢复集合。

## 代码实现

```typescript
export function solveNQueens(n: number): string[][] {
  const res: string[][] = [];
  // 初始化棋盘
  const board: string[][] = Array.from({ length: n }, () => Array(n).fill('.'));
  
  // 辅助集合用于快速检查冲突
  const cols = new Set<number>();
  const diag1 = new Set<number>(); // 主对角线: row - col 为常数
  const diag2 = new Set<number>(); // 副对角线: row + col 为常数

  function backtrack(row: number) {
    // 成功放置了 n 个皇后
    if (row === n) {
      res.push(board.map(r => r.join('')));
      return;
    }

    for (let col = 0; col < n; col++) {
      // 检查冲突
      if (cols.has(col) || diag1.has(row - col) || diag2.has(row + col)) {
        continue;
      }

      // 做选择
      board[row][col] = 'Q';
      cols.add(col);
      diag1.add(row - col);
      diag2.add(row + col);

      // 递归
      backtrack(row + 1);

      // 撤销选择
      board[row][col] = '.';
      cols.delete(col);
      diag1.delete(row - col);
      diag2.delete(row + col);
    }
  }

  backtrack(0);
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(N!)。第一行有 N 种选法，第二行有 N-1 种... 因此总体接近 N!。
- **空间复杂度**：O(N)，需要 O(N) 的空间存储棋盘状态和辅助集合，递归栈深度为 N。
