# 131. 分割回文串

## 题目描述

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

## 实现思路

这是一个 **回溯** 问题，类似于组合/切割问题。

我们需要在字符串的间隔处切刀，将字符串切分成若干个回文子串。

**回溯算法框架**：
1. `startIndex`：当前切割的起始位置。
2. `path`：当前已经切出的回文子串列表。
3. **结束条件**：当 `startIndex === s.length` 时，说明已经切到了字符串末尾，找到了一个合法的分割方案。

**具体步骤**：
1. 从 `startIndex` 开始，尝试在 `i` (startIndex <= i < s.length) 处进行切割。
2. 判断子串 `s[startIndex...i]` 是否为回文串。
   - 如果是，将其加入 `path`，并递归调用 `backtrack(i + 1)`。
   - 如果不是，跳过（剪枝）。
3. 递归返回后，将子串从 `path` 移除（回溯）。

**优化**：可以使用动态规划预处理字符串的所有子串是否为回文串，将判断回文的时间复杂度降为 O(1)。但在本题数据规模下，直接双指针判断也足够。

## 代码实现

```typescript
export function partition(s: string): string[][] {
  const res: string[][] = [];
  const path: string[] = [];

  // 辅助函数：判断是否为回文串
  function isPalindrome(str: string, left: number, right: number): boolean {
    while (left < right) {
      if (str[left] !== str[right]) {
        return false;
      }
      left++;
      right--;
    }
    return true;
  }

  function backtrack(startIndex: number) {
    // 切割到了末尾，收集结果
    if (startIndex === s.length) {
      res.push([...path]);
      return;
    }

    for (let i = startIndex; i < s.length; i++) {
      // 如果 [startIndex, i] 是回文串，则可以切割
      if (isPalindrome(s, startIndex, i)) {
        const sub = s.substring(startIndex, i + 1);
        path.push(sub);
        // 继续切割剩余部分
        backtrack(i + 1);
        // 回溯
        path.pop();
      }
    }
  }

  backtrack(0);
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(N * 2^N)，其中 N 是字符串长度。最坏情况下（例如全是相同字符），有 2^(N-1) 种切割方案，每种方案需要 O(N) 时间构造结果。
- **空间复杂度**：O(N)，递归栈的深度。
