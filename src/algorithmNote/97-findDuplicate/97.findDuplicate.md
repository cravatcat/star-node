# 97. 寻找重复数

## 题目描述

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个** 重复的整数 ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

## 实现思路

这道题可以转化为 **链表找环** 的问题（Floyd 判圈算法 / 龟兔赛跑算法）。

我们将数组下标 `i` 到 `nums[i]` 的映射看作是链表中的 `i -> next` 指针。
由于数组中存在重复的数字，说明有多个位置指向同一个值，这就形成了环。
且因为数字都在 `[1, n]` 范围内，下标 `0` 不可能被指向（因为值域从 1 开始），所以从下标 `0` 出发一定能进入环。

算法步骤：
1. **快慢指针**：初始化 `slow = 0`, `fast = 0`。
2. **相遇**：`slow` 每次走一步（`nums[slow]`），`fast` 每次走两步（`nums[nums[fast]]`）。当 `slow === fast` 时，说明在环内相遇。
3. **找入口**：将 `slow` 重置为 `0`，`fast` 保持在相遇点。然后两者都每次走一步。当它们再次相遇时，相遇点就是环的入口，也就是重复的数字。

## 代码实现

```typescript
export function findDuplicate(nums: number[]): number {
  let slow = 0;
  let fast = 0;

  // 1. 寻找相遇点 (Floyd's Tortoise and Hare)
  do {
    slow = nums[slow];
    fast = nums[nums[fast]];
  } while (slow !== fast);

  // 2. 寻找环的入口
  slow = 0;
  while (slow !== fast) {
    slow = nums[slow];
    fast = nums[fast];
  }

  return slow;
}
```

## 复杂度分析

- **时间复杂度**：O(n)。
- **空间复杂度**：O(1)，只使用了常数额外空间，且未修改原数组。
