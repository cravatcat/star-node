# 缺失的第一个正数 (First Missing Positive)

## 1. 题目描述

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 $O(n)$ 并且只使用常数级别额外空间的解决方案。

**示例 1:**

> **输入:** nums = [1,2,0]  
> **输出:** 3  
> **解释:** 范围 [1,2] 中的数字都在数组中。

**示例 2:**

> **输入:** nums = [3,4,-1,1]  
> **输出:** 2  
> **解释:** 1 在数组中，但 2 没有。

**示例 3:**

> **输入:** nums = [7,8,9,11,12]  
> **输出:** 1  
> **解释:** 最小的正整数 1 没有出现。

## 2. 实现思路

题目要求 $O(n)$ 时间复杂度和 $O(1)$ 空间复杂度。这意味着我们不能使用常规的哈希表（空间复杂度 $O(n)$）或排序（时间复杂度 $O(n \log n)$）。

我们可以利用数组本身作为哈希表（**原地哈希**）。

对于一个长度为 $n$ 的数组，如果没有缺失的正整数，那么它包含的元素应该是 `1, 2, ..., n`。
我们可以尝试把数组中的每个数 `x` 放到它应该出现的位置 `x-1` 上（即 `nums[x-1] = x`）。

例如，数字 `1` 应该放在索引 `0` 处，数字 `2` 应该放在索引 `1` 处，以此类推。

算法流程：
1.  遍历数组，对于每个元素 `nums[i]`，如果它满足以下条件，我们就通过交换把它放到正确的位置 `nums[i] - 1` 上：
    *   `nums[i]` 是正数 (`nums[i] > 0`)
    *   `nums[i]` 不超过数组长度 (`nums[i] <= n`)
    *   `nums[i]` 当前不在正确的位置上，且目标位置 `nums[i] - 1` 上也没有放正确的数字（避免重复数字导致的死循环）。
2.  交换后，继续检查当前位置的新数字，直到无法交换为止。
3.  再次遍历数组，如果发现 `nums[i] !== i + 1`，说明 `i + 1` 这个正整数缺失了，直接返回 `i + 1`。
4.  如果数组遍历完都符合要求，说明数组包含了 `1` 到 `n` 的所有整数，那么缺失的就是 `n + 1`。

## 3. 详细步骤

1.  获取数组长度 `n`。
2.  遍历数组 `i` 从 `0` 到 `n-1`：
    *   当 `nums[i] > 0` 且 `nums[i] <= n` 且 `nums[nums[i] - 1] !== nums[i]` 时：
        *   将 `nums[i]` 与 `nums[nums[i] - 1]` 进行交换。
        *   注意：使用 `while` 循环，因为交换回来的新 `nums[i]` 可能还需要继续交换。
3.  再次遍历数组 `i` 从 `0` 到 `n-1`：
    *   如果 `nums[i] !== i + 1`，返回 `i + 1`。
4.  如果循环结束未返回，则返回 `n + 1`。

## 4. 代码实现 (TypeScript)

```typescript
function firstMissingPositive(nums: number[]): number {
  const n = nums.length;

  for (let i = 0; i < n; i++) {
    // 1. nums[i] 必须在 [1, n] 范围内
    // 2. nums[i] 应该放在索引 nums[i] - 1 的位置上
    // 3. 如果 nums[i] 已经放在了正确的位置上，则不需要交换
    while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {
      const targetIndex = nums[i] - 1;
      // 交换
      [nums[targetIndex], nums[i]] = [nums[i], nums[targetIndex]];
    }
  }

  // 再次遍历，寻找第一个不符合 nums[i] === i + 1 的位置
  for (let i = 0; i < n; i++) {
    if (nums[i] !== i + 1) {
      return i + 1;
    }
  }

  // 如果所有位置都正确，说明数组是 [1, 2, ..., n]，则缺失的是 n + 1
  return n + 1;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。虽然外层循环里有一个 `while`，但是每个数字最多只会被交换一次到它正确的位置上，所以总的操作次数是线性的。
*   **空间复杂度**: $O(1)$。我们只使用了常数个额外变量，利用输入数组本身进行状态存储。
