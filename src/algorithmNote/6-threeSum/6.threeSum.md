# 三数之和 (3Sum)

## 1. 题目描述

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c` ，使得 `a + b + c = 0` ？请你找出所有和为 `0` 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

**示例 1:**

> **输入:** nums = [-1,0,1,2,-1,-4]  
> **输出:** [[-1,-1,2],[-1,0,1]]  
> **解释:**  
> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。  
> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。  
> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。  
> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。  
> 注意，输出的顺序和三元组的顺序并不重要。

**示例 2:**

> **输入:** nums = [0,1,1]  
> **输出:** []  
> **解释:** 唯一可能的三元组和不为 0 。

**示例 3:**

> **输入:** nums = [0,0,0]  
> **输出:** [[0,0,0]]  
> **解释:** 唯一可能的三元组和为 0 。

## 2. 实现思路

这道题可以看作是 **两数之和 (Two Sum)** 的升级版。

如果暴力求解，三层循环的时间复杂度是 $O(n^3)$，显然会超时。我们可以利用 **排序 + 双指针** 将时间复杂度降低到 $O(n^2)$。

1. **排序**：首先将数组从小到大排序。排序有助于我们去重和使用双指针。
2. **固定一个数，寻找另外两个数**：
    * 遍历数组，固定当前数 `nums[i]`。
    * 问题转化为：在 `i` 后面的数组中，寻找两个数 `nums[left]` 和 `nums[right]`，使得 `nums[left] + nums[right] = -nums[i]`。
    * 这正是双指针的典型应用场景。
3. **双指针查找**：
    * 初始化左指针 `left = i + 1`，右指针 `right = n - 1`。
    * 计算三数之和 `sum = nums[i] + nums[left] + nums[right]`。
        * 如果 `sum == 0`：找到一组解，加入结果集。同时需要移动 `left` 和 `right`，并**跳过重复元素**以避免重复的三元组。
        * 如果 `sum < 0`：说明和太小，需要更大的数，`left` 右移。
        * 如果 `sum > 0`：说明和太大，需要更小的数，`right` 左移。

**去重逻辑**：

* **对于 `i` 的去重**：如果 `nums[i] == nums[i-1]`，说明当前数字已经作为第一个数处理过了，直接跳过。
* **对于 `left` 和 `right` 的去重**：当找到一组解后，如果 `nums[left] == nums[left+1]`，则 `left` 继续右移；同理 `right`。

## 3. 详细步骤

1. 特判：如果数组长度小于 3，返回 `[]`。
2. 对数组进行排序。
3. 遍历数组，索引 `i` 从 `0` 到 `n-3`：
    * 若 `nums[i] > 0`：因为已排序，后面的数一定都大于 0，三数之和不可能为 0，直接 `break`。
    * 若 `i > 0` 且 `nums[i] == nums[i-1]`：跳过，去重。
    * 设 `left = i + 1`，`right = n - 1`。
    * 当 `left < right` 时：
        * 计算 `sum = nums[i] + nums[left] + nums[right]`。
        * 若 `sum == 0`：
            * 记录结果 `[nums[i], nums[left], nums[right]]`。
            * `while` 循环跳过重复的 `nums[left]`。
            * `while` 循环跳过重复的 `nums[right]`。
            * `left++`，`right--`。
        * 若 `sum < 0`：`left++`。
        * 若 `sum > 0`：`right--`。
4. 返回结果数组。

## 4. 代码实现 (TypeScript)

```typescript
function threeSum(nums: number[]): number[][] {
  const len = nums.length;
  if (len < 3) return [];
  
  // 排序是关键，为了后续的双指针操作和去重
  nums.sort((a, b) => a - b);
  
  const ans: number[][] = [];
  
  for (let i = 0; i < len - 2; i++) {
    // 如果当前数字已经大于0，后面的数字也都大于0，不可能组成和为0的三元组
    if (nums[i] > 0) break;
    
    // 去重：如果当前数字和前一个数字相同，跳过
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    
    let left = i + 1;
    let right = len - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      if (sum === 0) {
        ans.push([nums[i], nums[left], nums[right]]);
        
        // 去重：跳过重复的左指针元素
        while (left < right && nums[left] === nums[left + 1]) left++;
        // 去重：跳过重复的右指针元素
        while (left < right && nums[right] === nums[right - 1]) right--;
        
        left++;
        right--;
      } else if (sum < 0) {
        // 和太小，需要更大的数，左指针右移
        left++;
      } else {
        // 和太大，需要更小的数，右指针左移
        right--;
      }
    }
  }
  return ans;
};
```

## 5. 复杂度分析

* **时间复杂度**: $O(n^2)$。
  * 数组排序的时间复杂度为 $O(n \log n)$。
  * 遍历数组需要 $O(n)$，双指针遍历需要 $O(n)$，嵌套后为 $O(n^2)$。
  * 总时间复杂度为 $O(n \log n + n^2) \approx O(n^2)$。
* **空间复杂度**: $O(\log n)$ 到 $O(n)$。
  * 主要取决于排序算法所需的栈空间。我们忽略存储答案的空间。
