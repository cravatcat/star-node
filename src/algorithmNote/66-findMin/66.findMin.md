# 66. 寻找旋转排序数组中的最小值

## 题目描述

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
- 若旋转 4 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 7 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```text
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```text
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

**示例 3：**

```text
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

## 实现思路

这是一个经典的二分查找问题。我们需要找到数组中唯一的“断崖”点，即前一个元素大于后一个元素的地方，那个后一个元素就是最小值。

我们可以通过比较 `nums[mid]` 和 `nums[right]` 的大小来缩小搜索范围：

1. **如果 `nums[mid] > nums[right]`**：
   - 说明 `mid` 在第一段上升区间（较大的那段），而最小值肯定在第二段（较小的那段）。
   - 最小值一定在 `mid` 的右侧，且不包含 `mid`。
   - 调整 `left = mid + 1`。

2. **如果 `nums[mid] <= nums[right]`**：
   - 说明 `[mid, right]` 这一段是单调递增的。
   - 最小值可能是 `mid`，也可能在 `mid` 的左侧。
   - 调整 `right = mid`。

循环条件为 `left < right`，当循环结束时，`left == right`，此时 `nums[left]` 就是最小值。

## 代码实现

```typescript
export function findMin(nums: number[]): number {
  let left = 0;
  let right = nums.length - 1;

  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    
    // 将 mid 与 right 比较
    if (nums[mid] > nums[right]) {
      // 如果 nums[mid] > nums[right]，说明最小值肯定在右半部分
      // 因为如果这一段是有序的，mid 应该小于 right
      // 出现 mid > right 说明旋转点在 [mid+1, right] 之间
      left = mid + 1;
    } else {
      // nums[mid] <= nums[right]
      // 说明右半部分是有序的，或者 mid 就是最小值
      // 旋转点在 [left, mid] 之间
      right = mid;
    }
  }
  return nums[left];
}
```

## 复杂度分析

- **时间复杂度**：O(log n)，其中 n 是数组的长度。标准的二分查找。
- **空间复杂度**：O(1)，只使用了常数级额外空间。
