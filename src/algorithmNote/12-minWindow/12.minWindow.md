# 最小覆盖子串 (Minimum Window Substring)

## 1. 题目描述

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

* 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
* 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

> **输入：** s = "ADOBECODEBANC", t = "ABC"
> **输出：** "BANC"
> **解释：** 最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

**示例 2：**

> **输入：** s = "a", t = "a"
> **输出：** "a"

**示例 3：**

> **输入：** s = "a", t = "aa"
> **输出：** ""
> **解释：** t 中两个字符 'a' 均应包含在 s 的子串中，
> 因此没有符合条件的子字符串，返回空字符串。

## 2. 实现思路

本题可以使用 **滑动窗口 (Sliding Window)** 算法来解决。

核心思想是维护一个窗口 `[left, right)`，让该窗口不断向右滑动（扩大），直到窗口包含了 `t` 中所有的字符。然后，我们尝试收缩窗口（`left` 向右移动），在保证窗口依然包含 `t` 中所有字符的前提下，尽可能缩小窗口的大小。

具体步骤如下：

1. **初始化**：
    * 使用两个哈希表 `need` 和 `window`。`need` 记录 `t` 中每个字符出现的次数，`window` 记录当前窗口中相应字符出现的次数。
    * 使用变量 `left` 和 `right` 表示窗口的左右边界，初始都为 0。
    * 使用变量 `valid` 记录窗口中满足 `need` 条件的字符个数。
    * 使用 `start` 和 `len` 记录最小覆盖子串的起始位置和长度，`len` 初始化为无穷大。

2. **扩大窗口**：
    * 不断增加 `right`，将 `s[right]` 加入窗口。
    * 如果 `s[right]` 是 `need` 中的字符，更新 `window` 计数。如果 `window[s[right]]` 达到 `need[s[right]]` 的数量，说明该字符已满足要求，`valid` 加 1。

3. **收缩窗口**：
    * 当 `valid` 等于 `need` 的大小时（即窗口已包含 `t` 中所有字符），说明找到了一个可行解。
    * 此时尝试收缩窗口：更新最小覆盖子串的信息（如果当前窗口更小）。
    * 将 `s[left]` 移出窗口，`left` 加 1。
    * 如果移出的字符 `s[left]` 是 `need` 中的字符，更新 `window` 计数和 `valid` 状态。

4. **循环执行**：重复步骤 2 和 3，直到 `right` 到达字符串 `s` 的末尾。

5. **返回结果**：如果 `len` 依然是无穷大，说明没有找到符合条件的子串，返回空字符串；否则返回 `s.substring(start, start + len)`。

## 3. 详细步骤

1. 遍历字符串 `t`，构建 `need` 哈希表。
2. 初始化 `left = 0`, `right = 0`, `valid = 0`, `start = 0`, `len = Infinity`。
3. 当 `right < s.length` 时，执行循环：
    * 取出 `c = s[right]`，`right++`。
    * 如果 `c` 在 `need` 中：
        * `window[c]++`。
        * 如果 `window[c] == need[c]`，`valid++`。
    * 当 `valid == need.size` 时（窗口满足条件），执行循环：
        * 如果 `right - left < len`，更新 `start = left`, `len = right - left`。
        * 取出 `d = s[left]`，`left++`。
        * 如果 `d` 在 `need` 中：
            * 如果 `window[d] == need[d]`，`valid--`。
            * `window[d]--`。
4. 返回结果。

## 4. 代码实现 (TypeScript)

```typescript
export function minWindow(s: string, t: string): string {
  const need: Map<string, number> = new Map();
  const window: Map<string, number> = new Map();

  // 统计 t 中字符出现的次数
  for (const char of t) {
    need.set(char, (need.get(char) || 0) + 1);
  }

  let left = 0, right = 0;
  let valid = 0; // 窗口中满足 need 条件的字符个数
  let start = 0, len = Infinity; // 记录最小覆盖子串的起始位置和长度

  while (right < s.length) {
    // c 是将移入窗口的字符
    const c = s[right];
    // 右移窗口
    right++;

    // 进行窗口内数据的一系列更新
    if (need.has(c)) {
      window.set(c, (window.get(c) || 0) + 1);
      if (window.get(c) === need.get(c)) {
        valid++;
      }
    }

    // 判断左侧窗口是否要收缩
    while (valid === need.size) {
      // 在这里更新最小覆盖子串
      if (right - left < len) {
        start = left;
        len = right - left;
      }

      // d 是将移出窗口的字符
      const d = s[left];
      // 左移窗口
      left++;

      // 进行窗口内数据的一系列更新
      if (need.has(d)) {
        if (window.get(d) === need.get(d)) {
          valid--;
        }
        window.set(d, window.get(d)! - 1);
      }
    }
  }

  // 返回最小覆盖子串
  return len === Infinity ? "" : s.substring(start, start + len);
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(N + M)$，其中 $N$ 是字符串 `s` 的长度，$M$ 是字符串 `t` 的长度。我们首先需要遍历 `t` 来构建 `need` 表，时间复杂度为 $O(M)$。然后我们使用滑动窗口遍历 `s`，虽然有嵌套循环，但 `left` and `right` 指针都只会向右移动，每个字符最多被访问两次（移入窗口一次，移出窗口一次），所以时间复杂度为 $O(N)$。总复杂度为 $O(N + M)$。
* **空间复杂度**: $O(C)$，其中 $C$ 是字符集的大小。在本题中，字符集通常为 ASCII 字符或英文字母，所以 $C$ 可以看作是一个常数（如 128 或 26）。我们需要两个哈希表 `need` and `window` 来存储字符频率，它们的大小不会超过字符集的大小。
