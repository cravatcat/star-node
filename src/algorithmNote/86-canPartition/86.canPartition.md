# 86. 分割等和子集

## 题目描述

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```text
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```text
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

## 实现思路

这道题可以转化为 **0-1 背包问题**。
问题等价于：能否从数组 `nums` 中选出一些数字，使得这些数字的和等于整个数组和的一半。

首先计算数组总和 `sum`。如果 `sum` 是奇数，肯定无法平分，直接返回 `false`。
如果 `sum` 是偶数，我们的目标就是找到一个子集，其和为 `target = sum / 2`。

定义 `dp[j]` 为是否可以凑成和为 `j` 的子集。
对于数组中的每个数字 `num`，我们更新 `dp` 数组：
`dp[j] = dp[j] || dp[j - num]`
这表示：如果之前能凑成 `j`，或者能凑成 `j - num`（加上当前的 `num` 就凑成了 `j`），那么现在就能凑成 `j`。

**注意**：为了避免同一个数字被重复使用（0-1 背包的特性），内层循环需要 **从大到小** 遍历。

## 代码实现

```typescript
export function canPartition(nums: number[]): boolean {
  const sum = nums.reduce((a, b) => a + b, 0);
  if (sum % 2 !== 0) return false;

  const target = sum / 2;
  const n = nums.length;
  // dp[i] 表示是否可以凑成金额 i
  const dp = new Array(target + 1).fill(false);
  dp[0] = true;

  for (const num of nums) {
    // 从后往前遍历，避免重复使用同一个数字
    for (let j = target; j >= num; j--) {
      dp[j] = dp[j] || dp[j - num];
    }
  }

  return dp[target];
}
```

## 复杂度分析

- **时间复杂度**：O(n * target)，其中 n 是数组长度，target 是数组和的一半。
- **空间复杂度**：O(target)，使用一维数组进行优化。
