# 90. 编辑距离

## 题目描述

给你两个单词 `word1` 和 `word2`， 请返回将 `word1` 转换成 `word2` 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

**示例 1：**

```text
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```text
输入：word1 = "intention", word2 = "execution"
输出：5
```

## 实现思路

这是一个经典的动态规划问题。

定义 `dp[i][j]` 表示 `word1` 的前 `i` 个字符转换成 `word2` 的前 `j` 个字符所使用的最少操作数。

状态转移方程：
1. 如果 `word1[i-1] == word2[j-1]`，说明这两个字符相同，不需要操作，则 `dp[i][j] = dp[i-1][j-1]`。
2. 如果 `word1[i-1] != word2[j-1]`，我们可以进行三种操作，取最小值：
   - **插入**：`dp[i][j-1] + 1`（在 `word1` 的末尾插入一个字符，使其等于 `word2[j-1]`，然后问题转化为 `word1` 前 `i` 个字符和 `word2` 前 `j-1` 个字符的编辑距离）。
   - **删除**：`dp[i-1][j] + 1`（删除 `word1` 的第 `i` 个字符，然后问题转化为 `word1` 前 `i-1` 个字符和 `word2` 前 `j` 个字符的编辑距离）。
   - **替换**：`dp[i-1][j-1] + 1`（将 `word1` 的第 `i` 个字符替换为 `word2` 的第 `j` 个字符）。

初始条件：
- `dp[i][0] = i`（将 `word1` 前 `i` 个字符变成空字符串，需要删除 `i` 次）。
- `dp[0][j] = j`（将空字符串变成 `word2` 前 `j` 个字符，需要插入 `j` 次）。

## 代码实现

```typescript
export function minDistance(word1: string, word2: string): number {
  const m = word1.length;
  const n = word2.length;

  // dp[i][j] 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符所使用的最少操作数
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));

  // 初始化
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1,    // 删除
          dp[i][j - 1] + 1,    // 插入
          dp[i - 1][j - 1] + 1 // 替换
        );
      }
    }
  }

  return dp[m][n];
}
```

## 复杂度分析

- **时间复杂度**：O(m * n)，m 和 n 分别是两个字符串的长度。
- **空间复杂度**：O(m * n)，需要一个二维数组。
