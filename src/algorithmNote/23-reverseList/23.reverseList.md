# 反转链表 (Reverse Linked List)

## 1. 题目描述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1:**

![rev1ex1](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

> **输入:** head = [1,2,3,4,5]  
> **输出:** [5,4,3,2,1]

**示例 2:**

![rev1ex2](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

> **输入:** head = [1,2]  
> **输出:** [2,1]

**示例 3:**

> **输入:** head = []  
> **输出:** []

## 2. 实现思路

反转链表是一个非常基础且重要的链表操作。最常用的方法是 **迭代法**。

我们需要三个指针：
1.  `prev`：指向当前节点的前一个节点，初始为 `null`。
2.  `curr`：指向当前节点，初始为 `head`。
3.  `next`：指向当前节点的下一个节点（临时保存，防止断链）。

**迭代过程：**
在遍历链表时，我们将当前节点 `curr` 的 `next` 指针改为指向 `prev`。然后，将 `prev` 和 `curr` 都向前移动一步。

## 3. 详细步骤

1.  初始化 `prev` 为 `null`，`curr` 为 `head`。
2.  当 `curr` 不为 `null` 时，执行以下操作：
    *   暂存 `curr` 的下一个节点：`nextTemp = curr.next`。
    *   修改 `curr` 的 `next` 指针，使其指向 `prev`：`curr.next = prev`。
    *   移动 `prev` 指针到当前节点：`prev = curr`。
    *   移动 `curr` 指针到下一个节点：`curr = nextTemp`。
3.  当循环结束时，`curr` 为 `null`，`prev` 指向新的头节点（原链表的尾节点）。
4.  返回 `prev`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function reverseList(head: ListNode | null): ListNode | null {
    let prev: ListNode | null = null;
    let curr: ListNode | null = head;

    while (curr !== null) {
        const nextTemp: ListNode | null = curr.next; // 暂存后继节点
        curr.next = prev;                           // 修改引用指向
        prev = curr;                                // 暂存当前节点
        curr = nextTemp;                            // 访问下一节点
    }

    return prev;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。其中 $n$ 是链表的长度。需要遍历链表一次。
*   **空间复杂度**: $O(1)$。我们只需要常数空间来存储指针变量。
