# 22. 括号生成

## 题目描述

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

## 实现思路

我们可以把这个问题看作是填充 `2n` 个位置，每个位置可以填 `(` 或 `)`。

为了保证括号有效，我们需要遵守两个规则：
1. 只要左括号的数量小于 `n`，我们就可以放置一个左括号 `(`。
2. 只要右括号的数量小于左括号的数量，我们就可以放置一个右括号 `)`。

通过这两个规则进行 **回溯**（DFS），我们就能生成所有合法的括号组合。

**回溯算法框架**：
1. `current`：当前生成的字符串。
2. `open`：已经使用的左括号数量。
3. `close`：已经使用的右括号数量。
4. **结束条件**：当 `current.length === 2 * n` 时，说明生成完成。

## 代码实现

```typescript
export function generateParenthesis(n: number): string[] {
  const res: string[] = [];
  
  function backtrack(current: string, open: number, close: number) {
    // 结束条件
    if (current.length === n * 2) {
      res.push(current);
      return;
    }

    // 尝试添加左括号
    if (open < n) {
      backtrack(current + '(', open + 1, close);
    }

    // 尝试添加右括号
    if (close < open) {
      backtrack(current + ')', open, close + 1);
    }
  }

  backtrack('', 0, 0);
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(4^n / \sqrt{n})。这是一个卡特兰数（Catalan Number）问题，第 n 个卡特兰数的大小约为 4^n / (n^(3/2) * \sqrt{\pi})。
- **空间复杂度**：O(n)，递归栈的深度为 2n。
