# 78. 子集

## 题目描述

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

## 实现思路

这也是一个经典的 **回溯** 问题。与全排列不同的是：
1. 子集问题不需要考虑顺序（`[1, 2]` 和 `[2, 1]` 是同一个子集），所以我们需要通过 `startIndex` 来控制遍历的范围，保证每次只从当前元素之后的元素中选择，避免重复和逆序。
2. 子集问题中，决策树的 **每一个节点** 都是一个合法的结果，而不仅仅是叶子节点。

**回溯算法框架**：
1. `path`：记录当前子集。
2. `startIndex`：控制下一层递归从哪里开始选数字。
3. **收集结果**：每次进入递归函数，都将当前的 `path` 加入结果集 `res`。

**具体步骤**：
1. 定义 `backtrack(startIndex)`。
2. 将当前 `path` 加入 `res`。
3. 从 `startIndex` 开始遍历 `nums`：
   - 做选择：`path.push(nums[i])`。
   - 递归：`backtrack(i + 1)`（注意是 `i + 1`，表示下一个数字只能选后面的）。
   - 撤销选择：`path.pop()`。

## 代码实现

```typescript
export function subsets(nums: number[]): number[][] {
  const res: number[][] = [];
  const path: number[] = [];

  function backtrack(startIndex: number) {
    // 收集结果：决策树的每个节点都是一个子集
    res.push([...path]);

    for (let i = startIndex; i < nums.length; i++) {
      // 做选择
      path.push(nums[i]);
      // 递归
      backtrack(i + 1);
      // 撤销选择
      path.pop();
    }
  }

  backtrack(0);
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(N * 2^N)，其中 N 是数组长度。每个元素都有选或不选两种可能，共有 2^N 个子集。生成每个子集需要 O(N) 的时间。
- **空间复杂度**：O(N)，递归栈的深度为 N。
