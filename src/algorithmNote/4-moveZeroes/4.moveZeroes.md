# 移动零 (Move Zeroes)

## 1. 题目描述

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

> **输入:** nums = [0, 1, 0, 3, 12]  
> **输出:** [1, 3, 12, 0, 0]

**示例 2:**

> **输入:** nums = [0]  
> **输出:** [0]

## 2. 实现思路

题目要求 **原地** 修改数组，且保持非零元素的相对顺序。这提示我们可以使用 **双指针** 技巧。

我们可以维护两个指针：

* `i` (慢指针)：指向当前已处理好的非零序列的下一个位置。
* `j` (快指针)：用于遍历数组，寻找非零元素。

当 `j` 指向的元素非零时，我们将 `nums[j]` 与 `nums[i]` 交换，并将 `i` 向前移动一步。这样，`i` 左侧的所有元素（不包括 `i`）都是非零的，且保持了原来的相对顺序。

## 3. 详细步骤

1. 初始化两个指针 `i = 0` 和 `j = 0`。
2. 遍历数组，当 `j < nums.length` 时：
    * 检查 `nums[j]` 是否不等于 `0`。
    * 如果是非零元素：
        * 检查 `i` 是否等于 `j`。如果不相等，说明中间有零，交换 `nums[i]` 和 `nums[j]`。
        * 将 `i` 指针加 1 (`i++`)。
    * 无论是否交换，`j` 指针都加 1 (`j++`)，继续检查下一个元素。
3. 遍历结束后，所有非零元素都移到了数组的前面，剩下的位置自然就是 `0`（因为是交换操作，零被换到了后面）。

## 4. 代码实现 (TypeScript)

```typescript
/**
 Do not return anything, modify nums in-place instead.
 */
function moveZeroes(nums: number[]): void {
  let i = 0, j = 0;
  while (j < nums.length) {
    if (nums[j] !== 0) {
      // 只有当 i 和 j 不指向同一个位置时才交换，避免无意义的自身交换
      if (i !== j) {
        [nums[i], nums[j]] = [nums[j], nums[i]];
      }
      i++;
    }
    j++;
  }
};
```

## 5. 复杂度分析

* **时间复杂度**: $O(n)$。
  * 我们需要遍历整个数组一次，其中 $n$ 是数组的长度。
* **空间复杂度**: $O(1)$。
  * 我们只使用了两个指针变量 `i` 和 `j`，是在原数组上进行修改，没有使用额外的数组空间。
