# K 个一组翻转链表 (Reverse Nodes in k-Group)

## 1. 题目描述

给你一个链表的头节点 `head`，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

> **输入：** head = [1,2,3,4,5], k = 2  
> **输出：** [2,1,4,3,5]

**示例 2：**

> **输入：** head = [1,2,3,4,5], k = 3  
> **输出：** [3,2,1,4,5]

## 2. 实现思路

本题是“反转链表”的进阶版。我们需要将链表按照 `k` 个一组进行分组，然后对每一组进行反转。

核心思想是：**使用一个虚拟头节点（dummy node）简化操作，然后遍历链表，每次找出 `k` 个节点进行反转，并重新连接。**

主要难点在于：
1. 如何判断剩余节点是否足够 `k` 个。
2. 反转子链表后，如何正确地将其与前后的链表连接起来。

## 3. 详细步骤

1. 创建一个 `dummy` 节点，`dummy.next` 指向 `head`。
2. 定义 `pre` 和 `end` 指针，初始化都指向 `dummy`。`pre` 指向待反转区域的前一个节点，`end` 指向待反转区域的最后一个节点。
3. 进行循环：
    * 将 `end` 向后移动 `k` 步。
    * 如果在移动过程中 `end` 变为 `null`，说明剩余节点不足 `k` 个，不需要反转，直接退出循环。
    * 记录下 `end.next` 为 `next`（下一组的开始）。
    * 记录下 `pre.next` 为 `start`（本组的开始）。
    * 将 `end.next` 置为 `null`，断开本组与后面的连接，以便进行反转。
    * 调用反转函数 `reverse(start)`，将本组链表反转。
    * 将 `pre.next` 指向反转后的头节点（即原来的 `end`，现在反转函数的返回值）。
    * 将 `start.next` 指向 `next`，连接本组与下一组。
    * 更新 `pre` 和 `end` 指针：`pre` 移动到 `start`（反转后的尾节点），`end` 也重置为 `start`。
4. 返回 `dummy.next`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function reverseKGroup(head: ListNode | null, k: number): ListNode | null {
    if (!head || k === 1) return head;

    const dummy = new ListNode(0);
    dummy.next = head;
    let pre = dummy;
    let end = dummy;

    while (end.next !== null) {
        // 将 end 移动 k 步
        for (let i = 0; i < k && end !== null; i++) {
            end = end.next!;
        }
        // 如果剩余不足 k 个，跳出
        if (end === null) break;

        let start = pre.next!;
        let next = end.next;
        
        end.next = null; // 断开连接
        pre.next = reverse(start); // 反转子链表
        start.next = next; // 连接后面
        
        pre = start; // 移动 pre 到反转后的尾部
        end = pre; // 重置 end
    }

    return dummy.next;
}

// 辅助函数：反转链表
function reverse(head: ListNode): ListNode {
    let pre: ListNode | null = null;
    let curr: ListNode | null = head;
    while (curr !== null) {
        let next: ListNode | null = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre!;
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(n)$。其中 $n$ 是链表的长度。我们需要遍历链表两次（一次是寻找 `k` 个节点，一次是反转这 `k` 个节点），总体时间复杂度仍然是线性的。
* **空间复杂度**: $O(1)$。我们只需要常数个变量来维护指针，不需要额外的存储空间（不考虑递归栈空间，这里使用的是迭代法）。
