# 矩阵置零 (Set Matrix Zeroes)

## 1. 题目描述

给定一个 `m x n` 的矩阵，如果一个元素为 **0**，则将其所在行和列的所有元素都设为 **0**。请使用 **原地** 算法。

**进阶：**

* 一个直观的解决方案是使用 $O(mn)$ 的额外空间，但这并不是一个好的解决方案。
* 一个简单的改进方案是使用 $O(m + n)$ 的额外空间，但这仍然不是最好的解决方案。
* 你能想出一个仅使用常量空间的解决方案吗？

**示例 1:**

> **输入:** matrix = [[1,1,1],[1,0,1],[1,1,1]]
> **输出:** [[1,0,1],[0,0,0],[1,0,1]]

**示例 2:**

> **输入:** matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
> **输出:** [[0,0,0,0],[0,4,5,0],[0,3,1,0]]

## 2. 实现思路

为了让代码逻辑更加直观且易于理解，我们可以牺牲一点空间复杂度，使用 $O(m + n)$ 的额外空间。

我们可以使用两个集合（Set）分别记录所有包含 0 的行号和列号：

* 第一次遍历矩阵：如果 `matrix[i][j]` 为 0，就将行号 `i` 加入 `zeroRows` 集合，将列号 `j` 加入 `zeroCols` 集合。
* 第二次遍历矩阵：检查当前元素的行号 `i` 是否在 `zeroRows` 中，或者列号 `j` 是否在 `zeroCols` 中。只要满足其一，就将 `matrix[i][j]` 设为 0。

这种方法虽然空间复杂度不是最优的 $O(1)$，但逻辑非常清晰，避免了复用首行首列作为标记位带来的边界条件处理（如第一行/列本身是否有 0 的问题）。

## 3. 详细步骤

1. 创建两个 `Set`：`zeroRows` 和 `zeroCols`。
2. 遍历整个矩阵：
    * 如果发现 `matrix[i][j] == 0`，则执行 `zeroRows.add(i)` 和 `zeroCols.add(j)`。
3. 再次遍历整个矩阵：
    * 如果 `zeroRows.has(i)` 为真（说明该行原本有 0），或者 `zeroCols.has(j)` 为真（说明该列原本有 0），则将 `matrix[i][j]` 置为 0。

## 4. 代码实现 (TypeScript)

```typescript
/**
 Do not return anything, modify matrix in-place instead.
 */
export function setZeroes(matrix: number[][]): void {
  const m = matrix.length;
  const n = matrix[0].length;

  // 使用两个集合分别记录需要置零的行号和列号
  // 这种方法空间复杂度为 O(m+n)，但逻辑比利用首行首列标记 O(1) 更直观
  const zeroRows = new Set<number>();
  const zeroCols = new Set<number>();

  // 1. 遍历矩阵，记录所有为 0 的位置
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (matrix[i][j] === 0) {
        zeroRows.add(i);
        zeroCols.add(j);
      }
    }
  }

  // 2. 再次遍历矩阵，如果当前行或列在记录中，则置为 0
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (zeroRows.has(i) || zeroCols.has(j)) {
        matrix[i][j] = 0;
      }
    }
  }
};
```

## 5. 复杂度分析

* **时间复杂度**: $O(m \times n)$。我们需要遍历整个矩阵两次。
* **空间复杂度**: $O(m + n)$。我们需要两个集合来存储出现 0 的行号和列号，最坏情况下（例如对角线全是 0），需要存储 $m$ 个行号和 $n$ 个列号。
