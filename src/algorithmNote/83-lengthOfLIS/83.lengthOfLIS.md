# 83. 最长递增子序列

## 题目描述

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```text
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```text
输入：nums = [0,1,0,3,2,3]
输出：4
```

## 实现思路

我们使用贪心 + 二分查找的方法来实现，时间复杂度为 O(n log n)。

维护一个数组 `tails`，其中 `tails[i]` 表示**长度为 `i+1` 的所有递增子序列中，末尾元素的最小值**。

遍历数组 `nums` 中的每个元素 `num`：
1. 如果 `num` 大于 `tails` 的最后一个元素，说明 `num` 可以接在最长的递增子序列后面，构成一个更长的递增子序列，将 `num` 追加到 `tails` 末尾。
2. 否则，在 `tails` 中找到第一个大于等于 `num` 的元素，并将其更新为 `num`。这一步的意义是：用更小的末尾元素来替换原来的末尾元素，使得该长度的递增子序列更有潜力在未来变得更长（因为末尾元素越小，后面能接的元素就越多）。

查找过程可以使用二分查找。

最终 `tails` 的长度就是最长递增子序列的长度。

## 代码实现

```typescript
export function lengthOfLIS(nums: number[]): number {
  if (nums.length === 0) return 0;

  // tails[i] 存储长度为 i+1 的最长递增子序列的末尾元素的最小值
  const tails: number[] = [];

  for (const num of nums) {
    let i = 0, j = tails.length;
    // 二分查找
    while (i < j) {
      const m = Math.floor((i + j) / 2);
      if (tails[m] < num) {
        i = m + 1;
      } else {
        j = m;
      }
    }
    if (i === tails.length) {
      tails.push(num);
    } else {
      tails[i] = num;
    }
  }

  return tails.length;
}
```

## 复杂度分析

- **时间复杂度**：O(n log n)，遍历数组需要 O(n)，二分查找需要 O(log n)。
- **空间复杂度**：O(n)，`tails` 数组的长度最坏情况下为 n。
