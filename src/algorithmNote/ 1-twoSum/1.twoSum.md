# 两数之和 (Two Sum)

## 1. 题目描述

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

> **输入:** nums = [2, 7, 11, 15], target = 9  
> **输出:** [0, 1]  
> **解释:** 因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]

## 2. 实现思路

为了达到 $O(n)$ 的时间复杂度，我们可以利用 **哈希表 (Map)** 来存储已经遍历过的数字及其下标。

核心思想是：**我们在遍历数组的过程中，同时检查“由于之前遍历过某个数，是否能和当前数组成目标值”。**

具体逻辑如下：

1. 我们遍历数组 `nums`，对于当前遍历到的元素 `nums[i]`。
2. 我们计算出它需要的“另一半”：`diff = target - nums[i]`。
3. 我们查询哈希表，看 `diff` 是否存在：
    * **如果存在**：说明之前已经遍历过一个数等于 `diff`，它的下标是 `map.get(diff)`。那么现在我们找到了这两个数，直接返回它们的下标 `[i, map.get(diff)]`（或者 `[map.get(diff), i]`，视题目要求顺序而定）。
    * **如果不存在**：说明目前的数字还没有找到匹配对象，我们将当前的数字 `nums[i]` 和它的下标 `i` 存入哈希表，以供后面的数字匹配使用。

## 3. 详细步骤

1. 初始化一个空的哈希表 `map`。
2. 遍历数组 `nums`，索引从 `i = 0` 到 `n - 1`：
    * 计算当前数值需要的差值：`diff = target - nums[i]`。
    * 检查 `map` 中是否存在键为 `diff` 的记录。
    * 若存在，立即返回结果 `[i, map.get(diff)]`。
    * 若不存在，将当前数值 `nums[i]` 作为键，当前索引 `i` 作为值，存入 `map`。
3. 如果遍历结束仍未找到（按题目假设不会发生），返回空数组或其他标识。

## 4. 代码实现 (TypeScript)

```typescript
function twoSum(nums: number[], target: number): number[] {
  let map = new Map(), n = nums.length;
  let ans: number[] = [];
  for (let i = 0; i < n; i++) {
    let diff = target - nums[i];
    if (map.has(diff)) {
      // 注意：题目通常不限制返回顺序，这里返回 [当前索引, 之前索引]
      return [i, map.get(diff)];
    }
    map.set(nums[i], i);
  }
  return ans;
};
```

## 5. 复杂度分析

* **时间复杂度**: $O(n)$。我们只遍历了包含 $n$ 个元素的列表一次。在表中进行的每次查找只花费 $O(1)$ 的时间。
* **空间复杂度**: $O(n)$。所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 $n$ 个元素。
