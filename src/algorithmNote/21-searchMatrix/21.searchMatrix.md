# 搜索二维矩阵 II (Search a 2D Matrix II)

## 1. 题目描述

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

* 每行的元素从左到右升序排列。
* 每列的元素从上到下升序排列。

**示例 1:**

![searchgrid2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

> **输入:** matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5  
> **输出:** true

**示例 2:**

> **输入:** matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20  
> **输出:** false

## 2. 实现思路

由于矩阵的行和列都是排序的，我们可以利用这个性质来缩小搜索范围。

一种非常巧妙的方法是 **从矩阵的右上角 `(0, n-1)` 或者左下角 `(m-1, 0)` 开始搜索**。

**为什么选择这两个角？**
因为在这两个角上，我们可以根据当前值与目标值的大小关系，明确地排除一行或一列。

以 **右上角 `(row, col)`** 为例：

* `matrix[row][col]` 是当前行中最大的数，也是当前列中最小的数。
* **如果 `matrix[row][col] > target`**:
  * 说明当前列的所有元素（因为它们都比当前元素大或相等，且列是递增的）都必定大于 `target`。
  * 所以我们可以 **排除当前列**，向左移动 (`col--`)。
* **如果 `matrix[row][col] < target`**:
  * 说明当前行的所有元素（因为它们都比当前元素小或相等，且行是递增的）都必定小于 `target`。
  * 所以我们可以 **排除当前行**，向下移动 (`row++`)。
* **如果 `matrix[row][col] == target`**:
  * 找到了目标值，返回 `true`。

这种方法类似于二叉搜索树（BST）的查找过程。

## 3. 详细步骤

1. 初始化 `row = 0` (第一行) 和 `col = n - 1` (最后一列)。
2. 当 `row` 在矩阵范围内 (`row < m`) 且 `col` 在矩阵范围内 (`col >= 0`) 时，执行循环：
    * 获取当前位置的值 `current = matrix[row][col]`。
    * 如果 `current == target`，返回 `true`。
    * 如果 `current > target`，目标值在左侧，`col--`。
    * 如果 `current < target`，目标值在下方，`row++`。
3. 如果循环结束仍未找到，说明矩阵中不存在该目标值，返回 `false`。

## 4. 代码实现 (TypeScript)

```typescript
export function searchMatrix(matrix: number[][], target: number): boolean {
  if (matrix.length === 0 || matrix[0].length === 0) return false;

  const m = matrix.length;
  const n = matrix[0].length;

  // 从右上角开始 (row = 0, col = n - 1)
  let row = 0;
  let col = n - 1;

  while (row < m && col >= 0) {
    const current = matrix[row][col];

    if (current === target) {
      return true;
    } else if (current > target) {
      // 如果当前值大于目标值，说明当前列下方的所有值都大于目标值
      // 目标值只可能在左边
      col--;
    } else {
      // current < target
      // 如果当前值小于目标值，说明当前行左边的所有值都小于目标值
      // 目标值只可能在下方
      row++;
    }
  }

  return false;
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(m + n)$。在最坏的情况下（例如目标值小于矩阵左上角的元素，或者目标值大于矩阵右下角的元素），我们可能需要遍历一行和一列，即最多移动 $m + n$ 次。
* **空间复杂度**: $O(1)$。我们只需要常数空间来存储当前的坐标 `row` 和 `col`。
