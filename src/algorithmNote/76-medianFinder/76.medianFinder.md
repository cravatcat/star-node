# 76. 数据流的中位数

## 题目描述

中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() ` 初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10^-5` 以内的答案将被接受。

**示例 1：**

```text
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

## 实现思路

要高效地从数据流中找到中位数，我们可以维护两个堆：
1. **最大堆 (MaxHeap)**：存储较小的一半元素。
2. **最小堆 (MinHeap)**：存储较大的一半元素。

我们保持两个堆的平衡：
- 最大堆的大小等于最小堆的大小，或者比最小堆大 1。
- 最大堆的所有元素都小于等于最小堆的所有元素。

**addNum(num) 操作：**
1. 先将新元素加入最大堆。
2. 为了保证最大堆的所有元素都小于等于最小堆，我们将最大堆的堆顶元素弹出并加入最小堆。
3. 此时最小堆的大小可能会超过最大堆，我们需要调整：如果最小堆的大小大于最大堆，将最小堆的堆顶元素弹出并加入最大堆。

这样操作后，中位数就可以很容易得到：
- 如果最大堆元素多（奇数个总元素），中位数就是最大堆的堆顶。
- 如果两个堆元素一样多（偶数个总元素），中位数就是两个堆顶的平均值。

## 代码实现

```typescript
// 简单实现最小堆和最大堆，或者使用数组排序模拟（不推荐，性能差）
// 为了演示算法核心，这里实现两个简单的堆类

class MinHeap {
  private heap: number[] = [];

  push(val: number) {
    this.heap.push(val);
    this.bubbleUp(this.heap.length - 1);
  }

  pop(): number | undefined {
    if (this.heap.length === 0) return undefined;
    const min = this.heap[0];
    const last = this.heap.pop()!;
    if (this.heap.length > 0) {
      this.heap[0] = last;
      this.bubbleDown(0);
    }
    return min;
  }

  peek(): number | undefined {
    return this.heap[0];
  }

  size(): number {
    return this.heap.length;
  }
  // ... (bubbleUp and bubbleDown implementation)
}

class MaxHeap {
  // ... (Similar implementation but for max heap)
}

export class MedianFinder {
  private minHeap: MinHeap; // 存储较大的一半
  private maxHeap: MaxHeap; // 存储较小的一半

  constructor() {
    this.minHeap = new MinHeap();
    this.maxHeap = new MaxHeap();
  }

  addNum(num: number): void {
    // 先加入最大堆
    this.maxHeap.push(num);
    // 将最大堆堆顶（最大值）移到最小堆
    this.minHeap.push(this.maxHeap.pop()!);

    // 保持平衡：最大堆的大小要么等于最小堆，要么比最小堆大 1
    if (this.minHeap.size() > this.maxHeap.size()) {
      this.maxHeap.push(this.minHeap.pop()!);
    }
  }

  findMedian(): number {
    if (this.maxHeap.size() > this.minHeap.size()) {
      return this.maxHeap.peek()!;
    } else {
      return (this.maxHeap.peek()! + this.minHeap.peek()!) / 2;
    }
  }
}
```

## 复杂度分析

- **时间复杂度**：
  - `addNum`：O(log n)，堆的插入和弹出操作。
  - `findMedian`：O(1)，直接访问堆顶。
- **空间复杂度**：O(n)，存储所有元素。
