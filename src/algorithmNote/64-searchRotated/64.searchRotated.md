# 64. 搜索旋转排序数组

## 题目描述

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```text
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```text
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```text
输入：nums = [1], target = 0
输出：-1
```

## 实现思路

这是一个典型的二分查找变体问题。虽然数组被旋转了，但它仍然保持了部分有序的特性。

在二分查找的每一步中，我们将数组分为左右两部分 `[left, mid]` 和 `[mid + 1, right]`。由于旋转的特性，这两部分中 **至少有一部分是有序的**。

我们可以通过比较 `nums[left]` 和 `nums[mid]` 的大小来判断哪一部分是有序的：

1. **如果 `nums[left] <= nums[mid]`**：
   - 说明左半部分 `[left, mid]` 是有序的。
   - 此时，我们可以判断 `target` 是否在左半部分范围内：
     - 如果 `nums[left] <= target < nums[mid]`，则 `target` 肯定在左边，调整 `right = mid - 1`。
     - 否则，`target` 肯定在右边，调整 `left = mid + 1`。

2. **如果 `nums[left] > nums[mid]`**：
   - 说明右半部分 `[mid, right]` 是有序的（因为旋转点在左半部分）。
   - 此时，我们可以判断 `target` 是否在右半部分范围内：
     - 如果 `nums[mid] < target <= nums[right]`，则 `target` 肯定在右边，调整 `left = mid + 1`。
     - 否则，`target` 肯定在左边，调整 `right = mid - 1`。

通过这种方式，我们每次都能排除掉一半的区间，从而达到 O(log n) 的时间复杂度。

## 代码实现

```typescript
export function search(nums: number[], target: number): number {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) return mid;

    // 判断哪一部分是有序的
    // 注意：这里使用 <= 是因为当 left == mid 时，我们也认为左侧是有序的
    if (nums[left] <= nums[mid]) {
      // 左半部分有序 [left, mid]
      // 如果 target 在左半部分范围内
      if (nums[left] <= target && target < nums[mid]) {
        right = mid - 1;
      } else {
        // 否则去右半部分找
        left = mid + 1;
      }
    } else {
      // 右半部分有序 [mid, right]
      // 如果 target 在右半部分范围内
      if (nums[mid] < target && target <= nums[right]) {
        left = mid + 1;
      } else {
        // 否则去左半部分找
        right = mid - 1;
      }
    }
  }
  
  return -1;
}
```

## 复杂度分析

- **时间复杂度**：O(log n)，其中 n 是数组的长度。虽然数组旋转了，但我们每次迭代仍然排除了一半的元素。
- **空间复杂度**：O(1)，只使用了常数级额外空间。
