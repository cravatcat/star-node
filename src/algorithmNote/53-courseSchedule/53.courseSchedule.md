# 207. 课程表

## 题目描述

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程  `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

## 实现思路

这道题本质上是判断一个 **有向图** 是否存在 **环**。如果存在环，则无法完成所有课程（死锁）；如果不存在环，则可以完成。

我们可以使用 **拓扑排序 (Topological Sort)** 来解决这个问题。

**BFS (Kahn 算法) 步骤**：
1. **建图**：使用邻接表 `adj` 存储图结构，同时维护一个数组 `inDegree` 记录每个节点的 **入度**（有多少先修课程）。
2. **初始化**：将所有入度为 0 的节点（没有先修课程，可以直接学）加入队列 `queue`。
3. **BFS 过程**：
   - 从队列中取出一个节点 `curr`。
   - 将其计入已修课程数 `count`。
   - 遍历 `curr` 的所有邻居节点 `next`（即依赖 `curr` 的后续课程）。
   - 将 `next` 的入度减 1（表示满足了一个先修条件）。
   - 如果 `next` 的入度变为 0，说明所有先修条件都已满足，将其加入队列。
4. **结果判断**：如果最终已修课程数 `count` 等于总课程数 `numCourses`，说明没有环，返回 `true`；否则返回 `false`。

## 代码实现

```typescript
export function canFinish(numCourses: number, prerequisites: number[][]): boolean {
  const inDegree = new Array(numCourses).fill(0);
  // 邻接表，adj[i] 存储依赖于课程 i 的所有后续课程
  const adj: number[][] = Array.from({ length: numCourses }, () => []);

  // 1. 建图并统计入度
  for (const [course, pre] of prerequisites) {
    adj[pre].push(course);
    inDegree[course]++;
  }

  const queue: number[] = [];
  // 2. 将所有入度为 0 的课程入队
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }

  let count = 0;
  // 3. BFS 拓扑排序
  while (queue.length > 0) {
    const curr = queue.shift()!;
    count++;

    for (const next of adj[curr]) {
      inDegree[next]--;
      if (inDegree[next] === 0) {
        queue.push(next);
      }
    }
  }

  // 4. 如果能修完所有课（即没有环），返回 true
  return count === numCourses;
}
```

## 复杂度分析

- **时间复杂度**：O(V + E)，其中 V 是课程数 `numCourses`，E 是先修课程的要求数 `prerequisites.length`。建图需要 O(E)，BFS 过程中每个节点和每条边最多访问一次。
- **空间复杂度**：O(V + E)，需要邻接表和入度数组。
