# 69. 每日温度

## 题目描述

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```text
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```text
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```text
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

## 实现思路

这是一个经典的 **单调栈** 问题。

我们需要找到每个元素右边第一个比它大的元素。

我们可以维护一个 **单调递减栈**，栈中存储的是数组的 **索引**。
1. 遍历数组，对于每个元素 `temperatures[i]`：
2. 如果当前温度大于栈顶索引对应的温度，说明我们找到了栈顶元素的“下一个更高温度”。
   - 弹出栈顶索引 `prevIndex`。
   - 计算距离：`i - prevIndex`，并存入结果数组 `res[prevIndex]`。
   - 重复此过程，直到栈为空或当前温度小于等于栈顶温度。
3. 将当前索引 `i` 入栈。

这样，栈中的元素对应的温度始终是递减的（或者说非递增的）。

## 代码实现

```typescript
export function dailyTemperatures(temperatures: number[]): number[] {
  const n = temperatures.length;
  const res = new Array(n).fill(0);
  const stack: number[] = []; // 单调栈，存储索引

  for (let i = 0; i < n; i++) {
    const temp = temperatures[i];
    // 当当前温度大于栈顶索引对应的温度时，说明找到了栈顶元素的下一个更高温度
    while (stack.length > 0 && temp > temperatures[stack[stack.length - 1]]) {
      const prevIndex = stack.pop()!;
      res[prevIndex] = i - prevIndex;
    }
    stack.push(i);
  }

  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。每个元素最多入栈一次，出栈一次。
- **空间复杂度**：O(n)，最坏情况下（例如数组是递减的），栈的大小为 O(n)。
