# 91. 最大正方形

## 题目描述

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

```text
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

**示例 2：**

```text
输入：matrix = [["0","1"],["1","0"]]
输出：1
```

## 实现思路

这是一个动态规划问题。

定义 `dp[i][j]` 为以 `(i, j)` 为右下角的最大正方形的边长。
如果 `matrix[i][j]` 是 `'1'`，那么 `dp[i][j]` 取决于它的左边、上边和左上角的 `dp` 值：
`dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`

解释：只有当左边、上边、左上角都能构成正方形时，当前位置才能扩展出一个更大的正方形。受限于最小的那个边长。

如果 `matrix[i][j]` 是 `'0'`，那么 `dp[i][j] = 0`。

边界条件：
- 如果 `i=0` 或 `j=0`，且 `matrix[i][j] == '1'`，则 `dp[i][j] = 1`。

最终结果是 `maxSide * maxSide`。

## 代码实现

```typescript
export function maximalSquare(matrix: string[][]): number {
  if (matrix.length === 0 || matrix[0].length === 0) return 0;
  const m = matrix.length;
  const n = matrix[0].length;
  let maxSide = 0;

  // dp[i][j] 表示以 (i, j) 为右下角的最大正方形的边长
  const dp = Array.from({ length: m }, () => new Array(n).fill(0));

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (matrix[i][j] === '1') {
        if (i === 0 || j === 0) {
          dp[i][j] = 1;
        } else {
          dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
        }
        maxSide = Math.max(maxSide, dp[i][j]);
      }
    }
  }

  return maxSide * maxSide;
}
```

## 复杂度分析

- **时间复杂度**：O(m * n)，遍历整个矩阵。
- **空间复杂度**：O(m * n)，需要一个二维数组。可以优化到 O(n)。
