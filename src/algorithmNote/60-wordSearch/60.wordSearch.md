# 79. 单词搜索

## 题目描述

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

## 实现思路

这是一个典型的 **二维网格回溯** 问题。

我们需要在网格中寻找一条路径，使得路径上的字符连接起来等于 `word`。

**算法流程**：
1. 遍历网格的每一个格子 `(i, j)`，将其作为起点进行搜索。
2. `backtrack(i, j, k)` 函数：
   - `i, j`：当前格子的坐标。
   - `k`：当前匹配到 `word` 的第几个字符。
   - **结束条件**：如果 `k === word.length`，说明找到了完整的单词，返回 `true`。
   - **剪枝条件**：如果越界，或者当前格子字符不等于 `word[k]`，或者当前格子已被访问过，返回 `false`。
3. **标记访问**：为了防止重复使用同一个格子，我们在进入递归前将当前格子修改为一个特殊字符（如 `'#'`），递归返回后将其还原（回溯）。
4. **递归方向**：向上下左右四个方向递归搜索。

## 代码实现

```typescript
export function exist(board: string[][], word: string): boolean {
  const m = board.length;
  const n = board[0].length;

  function backtrack(i: number, j: number, k: number): boolean {
    // 找到完整单词
    if (k === word.length) {
      return true;
    }

    // 越界 或 字符不匹配 (注意：如果是 '#' 也不匹配)
    if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] !== word[k]) {
      return false;
    }

    const temp = board[i][j];
    board[i][j] = '#'; // 标记为已访问

    // 向四个方向探索
    const res = backtrack(i + 1, j, k + 1) ||
                backtrack(i - 1, j, k + 1) ||
                backtrack(i, j + 1, k + 1) ||
                backtrack(i, j - 1, k + 1);

    board[i][j] = temp; // 回溯：还原字符
    return res;
  }

  // 尝试从每个格子作为起点
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (backtrack(i, j, 0)) {
        return true;
      }
    }
  }

  return false;
}
```

## 复杂度分析

- **时间复杂度**：O(M * N * 3^L)，其中 M, N 是网格大小，L 是单词长度。除了起点的 4 个方向外，后续每个点最多有 3 个方向可走（不能回头）。
- **空间复杂度**：O(L)，递归栈的深度为单词长度。
