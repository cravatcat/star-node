# 437. 路径总和 III

## 题目描述

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

路径 **不需要** 从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

## 实现思路

### 方法一：双重递归（暴力法）

最直观的方法是：
1. 定义一个函数 `rootSum`，计算以当前节点为起点的路径中，和为 `targetSum` 的路径数量。
2. 遍历整棵树，对于每一个节点，都调用 `rootSum`。
3. 总数 = `rootSum(root, targetSum)` + `pathSum(root.left, targetSum)` + `pathSum(root.right, targetSum)`。

这种方法的时间复杂度是 O(N^2)，因为对于每个节点，我们都要向下遍历一遍。

### 方法二：前缀和（优化法）

我们可以利用 **前缀和** 的思想来优化。这道题其实可以看作是“数组中和为 K 的子数组”在树上的推广。

定义：从根节点到当前节点的路径上，所有节点值的和为 `currentSum`。
如果存在一条路径（从节点 A 到节点 B），其和为 `targetSum`，那么必然满足：
`prefixSum(root...B) - prefixSum(root...A) = targetSum`
即 `prefixSum(root...A) = prefixSum(root...B) - targetSum`。

我们只需要在遍历过程中，记录从根节点到当前节点的路径上，各个前缀和出现的次数。
当我们遍历到某个节点时，当前的前缀和为 `curr`，我们只需要查找哈希表中是否存在 `curr - targetSum`，如果存在，说明存在以当前节点结尾的路径满足条件。

**注意**：
1. 需要回溯。当从左/右子树返回时，需要将当前节点的前缀和从哈希表中移除，因为它不能被其他分支（如兄弟节点的分支）使用。
2. 初始时，哈希表中需要存入 `{0: 1}`，代表前缀和为 0 的路径有一条（即空路径），用于处理从根节点开始的路径。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function pathSum(root: TreeNode | null, targetSum: number): number {
  // key: 前缀和, value: 该前缀和出现的次数
  const prefixSumMap = new Map<number, number>();
  // 初始化：前缀和为 0 的路径有 1 条（用于处理从根节点开始的情况）
  prefixSumMap.set(0, 1);
  
  return dfs(root, 0, targetSum, prefixSumMap);
}

function dfs(node: TreeNode | null, currentSum: number, targetSum: number, prefixSumMap: Map<number, number>): number {
  if (!node) {
    return 0;
  }

  currentSum += node.val;
  
  // 核心逻辑：
  // 如果存在从根到某祖先节点的路径和为 (currentSum - targetSum)
  // 那么从该祖先节点到当前节点的路径和就为 targetSum
  let count = prefixSumMap.get(currentSum - targetSum) || 0;

  // 将当前前缀和加入 map
  prefixSumMap.set(currentSum, (prefixSumMap.get(currentSum) || 0) + 1);

  // 递归处理左右子树
  count += dfs(node.left, currentSum, targetSum, prefixSumMap);
  count += dfs(node.right, currentSum, targetSum, prefixSumMap);

  // 回溯：离开当前节点前，将其前缀和从 map 中移除
  // 因为这个前缀和只能用于当前节点的子节点，不能用于兄弟节点或更上层的其他分支
  prefixSumMap.set(currentSum, (prefixSumMap.get(currentSum) || 0) - 1);

  return count;
}
```

## 复杂度分析

- **时间复杂度**：O(N)，其中 N 是二叉树的节点数。每个节点只被访问一次。
- **空间复杂度**：O(N)，哈希表最坏情况下需要存储 N 个前缀和（树退化为链表时）。
