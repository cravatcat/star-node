# 两数相加 (Add Two Numbers)

## 1. 题目描述

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1:**

![addtwonumber1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

> **输入:** l1 = [2,4,3], l2 = [5,6,4]  
> **输出:** [7,0,8]  
> **解释:** 342 + 465 = 807.

**示例 2:**

> **输入:** l1 = [0], l2 = [0]  
> **输出:** [0]

**示例 3:**

> **输入:** l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]  
> **输出:** [8,9,9,9,0,0,0,1]

## 2. 实现思路

这道题实际上是模拟竖式加法的过程。由于数字是逆序存储的（即个位在链表头），这非常方便，我们直接从头节点开始相加即可。

**核心逻辑：**

1.  维护一个进位变量 `carry`，初始为 0。
2.  同时遍历两个链表 `l1` 和 `l2`。
3.  对于每一位，计算 `sum = val1 + val2 + carry`。
    *   如果链表已经遍历完，对应的 `val` 视为 0。
4.  更新进位 `carry = floor(sum / 10)`。
5.  创建新节点存储当前位的结果 `sum % 10`，并将其连接到结果链表。
6.  继续处理下一位。
7.  **注意：** 当两个链表都遍历完后，如果 `carry > 0`，还需要再追加一个节点（值为 `carry`）。

## 3. 详细步骤

1.  创建一个虚拟头节点 `dummy` 和一个指针 `current` 指向它。
2.  初始化 `carry = 0`。
3.  当 `l1` 不为空，或者 `l2` 不为空，或者 `carry > 0` 时，循环执行：
    *   获取 `l1` 的值 `val1`（如果 `l1` 为空则为 0）。
    *   获取 `l2` 的值 `val2`（如果 `l2` 为空则为 0）。
    *   计算 `sum = val1 + val2 + carry`。
    *   更新 `carry = Math.floor(sum / 10)`。
    *   创建新节点 `new ListNode(sum % 10)`，接到 `current.next`。
    *   `current` 向后移动。
    *   如果 `l1` 不为空，`l1 = l1.next`。
    *   如果 `l2` 不为空，`l2 = l2.next`。
4.  返回 `dummy.next`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    const dummy = new ListNode(0);
    let current = dummy;
    let carry = 0;

    // 只要 l1 或 l2 还有节点，或者还有进位，就继续循环
    while (l1 !== null || l2 !== null || carry > 0) {
        const val1 = l1 ? l1.val : 0;
        const val2 = l2 ? l2.val : 0;
        const sum = val1 + val2 + carry;

        carry = Math.floor(sum / 10); // 计算新的进位
        current.next = new ListNode(sum % 10); // 创建新节点存储当前位
        current = current.next;

        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
    }

    return dummy.next;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(\max(m, n))$。其中 $m$ 和 $n$ 分别为两个链表的长度。我们需要遍历较长的链表，如果最后有进位，可能多一次操作。
*   **空间复杂度**: $O(1)$。如果不计算返回结果所占用的空间（这是必须的），我们只使用了常数个辅助变量。
