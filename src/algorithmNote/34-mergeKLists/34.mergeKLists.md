# 合并 K 个升序链表 (Merge k Sorted Lists)

## 1. 题目描述

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

> **输入：** lists = [[1,4,5],[1,3,4],[2,6]]
> **输出：** [1,1,2,3,4,4,5,6]
> **解释：** 链表数组如下：
> [
>   1->4->5,
>   1->3->4,
>   2->6
> ]
> 将它们合并到一个有序链表中得到。
> 1->1->2->3->4->4->5->6

**示例 2：**

> **输入：** lists = []
> **输出：** []

**示例 3：**

> **输入：** lists = [[]]
> **输出：** []

## 2. 实现思路

这道题是 **合并两个有序链表** 的进阶版。有多种解法：

### 方法一：顺序合并

我们可以将第一个链表和第二个链表合并，然后将结果和第三个链表合并，依此类推。
时间复杂度：$O(k^2 n)$，其中 $k$ 是链表数量，$n$ 是每个链表的平均长度。效率较低。

### 方法二：最小堆 (Priority Queue)

维护一个大小为 $k$ 的最小堆，每次取出堆顶元素（最小的那个），将其加入结果链表，然后将该元素所在链表的下一个节点加入堆中。
时间复杂度：$O(kn \log k)$。需要额外的堆结构。

### 方法三：分治合并 (Divide and Conquer)

这是一种更优的解法，类似于 **归并排序**。
我们将 $k$ 个链表配对并将它们合并。
第一轮合并后，剩下 $k/2$ 个链表。
第二轮合并后，剩下 $k/4$ 个链表。
...
重复这个过程，直到只剩下一个链表。

时间复杂度：$O(kn \log k)$。
空间复杂度：$O(\log k)$ （递归调用栈的空间）。

我们这里采用 **分治合并** 的方法，因为它不需要额外实现复杂的数据结构（如堆），且效率很高。

## 3. 详细步骤 (分治法)

1.  **Base Case**：如果链表数组为空，返回 `null`。如果只有一个链表，返回该链表。
2.  **分解**：将链表数组从中间分为两半，`left` 和 `right`。
3.  **递归**：分别递归合并 `left` 和 `right` 部分，得到两个合并后的有序链表 `l1` 和 `l2`。
4.  **合并**：使用 `mergeTwoLists` 函数将 `l1` 和 `l2` 合并为一个有序链表并返回。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    if (lists.length === 0) return null;
    return merge(lists, 0, lists.length - 1);
}

// 辅助函数：分治合并
function merge(lists: Array<ListNode | null>, left: number, right: number): ListNode | null {
    // 只剩一个链表，直接返回
    if (left === right) {
        return lists[left];
    }

    // 计算中间位置
    const mid = left + Math.floor((right - left) / 2);
    
    // 递归合并左半部分
    const l1 = merge(lists, left, mid);
    // 递归合并右半部分
    const l2 = merge(lists, mid + 1, right);

    // 合并两个有序链表
    return mergeTwoLists(l1, l2);
}

// 辅助函数：合并两个有序链表 (同 LeetCode 21)
function mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    const dummy = new ListNode(0);
    let curr = dummy;

    while (l1 && l2) {
        if (l1.val < l2.val) {
            curr.next = l1;
            l1 = l1.next;
        } else {
            curr.next = l2;
            l2 = l2.next;
        }
        curr = curr.next;
    }

    curr.next = l1 || l2;
    return dummy.next;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(N \log k)$。
    *   其中 $k$ 是链表的数量，$N$ 是所有链表中节点的总数。
    *   分治算法的递归深度为 $\log k$。
    *   每一层递归中，我们需要遍历每个节点一次，耗时 $O(N)$。
*   **空间复杂度**: $O(\log k)$。
    *   递归调用栈的深度为 $\log k$。
