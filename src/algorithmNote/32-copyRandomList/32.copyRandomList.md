# 随机链表的复制 (Copy List with Random Pointer)

## 1. 题目描述

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://en.wikipedia.org/wiki/Object_copying#Deep_copy)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

*   `val`：一个表示 `Node.val` 的整数。
*   `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![e1](https://assets.leetcode.com/uploads/2019/12/18/e1.png)

> **输入：** head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
> **输出：** [[7,null],[13,0],[11,4],[10,2],[1,0]]

**示例 2：**

![e2](https://assets.leetcode.com/uploads/2019/12/18/e2.png)

> **输入：** head = [[1,1],[2,1]]
> **输出：** [[1,1],[2,1]]

**示例 3：**

![e3](https://assets.leetcode.com/uploads/2019/12/18/e3.png)

> **输入：** head = [[3,null],[3,0],[3,null]]
> **输出：** [[3,null],[3,0],[3,null]]

## 2. 实现思路

这道题的核心在于如何正确地复制 `random` 指针。因为 `random` 可能指向链表中任意一个节点（包括还没遍历到的节点），所以我们不能简单地在一次遍历中完成所有指针的构建。

通常有两种常见解法：

### 方法一：哈希表 (Map)

我们可以利用哈希表来存储 **原节点** 到 **新节点** 的映射关系。

1.  **第一次遍历**：遍历原链表，对于每个原节点，创建一个对应的新节点（只复制 `val`），并将 `Map<原节点, 新节点>` 存入哈希表。
2.  **第二次遍历**：再次遍历原链表，通过哈希表找到对应的 **新节点**，并根据原节点的 `next` 和 `random` 指向，在哈希表中找到对应的 **新 next 节点** 和 **新 random 节点**，将它们连接起来。

### 方法二：拼接 + 拆分 (空间优化)

如果不使用哈希表，我们可以利用链表本身的结构。

1.  **复制节点并拼接**：遍历原链表，对于每个节点 `curr`，创建一个新节点 `copy`，将其插入到 `curr` 和 `curr.next` 之间。即 `curr -> copy -> curr.next`。
2.  **构建 random 指针**：遍历拼接后的链表。对于每个节点 `curr`，它的新节点 `curr.next` 的 `random` 指针应该指向 `curr.random.next`（如果 `curr.random` 存在）。
3.  **拆分链表**：将混合链表拆分成原链表和新链表。恢复原链表的 `next` 指针，并提取出新链表。

这里我们采用 **方法一（哈希表）**，因为它逻辑更直观，且 TypeScript 中 `Map` 使用很方便。

## 3. 详细步骤 (哈希表法)

1.  如果 `head` 为空，直接返回 `null`。
2.  初始化一个 `Map<Node, Node>`。
3.  **第一轮遍历**：
    *   遍历原链表。
    *   对于每个节点 `curr`，创建一个新节点 `newNode`，值为 `curr.val`。
    *   将 `curr` 和 `newNode` 的映射关系存入 `Map`。
4.  **第二轮遍历**：
    *   重置 `curr` 到头节点。
    *   遍历原链表。
    *   从 `Map` 中取出对应的 `newNode`。
    *   设置 `newNode.next`：如果在 `Map` 中能找到 `curr.next` 对应的新节点，则指向它；否则为 `null`。
    *   设置 `newNode.random`：如果在 `Map` 中能找到 `curr.random` 对应的新节点，则指向它；否则为 `null`。
5.  返回 `Map` 中 `head` 对应的新节点。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for Node.
 * class Node {
 *     val: number
 *     next: Node | null
 *     random: Node | null
 *     constructor(val?: number, next?: Node, random?: Node) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *         this.random = (random===undefined ? null : random)
 *     }
 * }
 */

function copyRandomList(head: Node | null): Node | null {
    if (!head) return null;

    const map = new Map<Node, Node>();

    let curr: Node | null = head;
    // 1. 遍历链表，复制每个节点，并存入 map
    while (curr) {
        map.set(curr, new Node(curr.val));
        curr = curr.next;
    }

    curr = head;
    // 2. 再次遍历链表，构建新节点的 next 和 random 指向
    while (curr) {
        const newNode = map.get(curr);
        if (newNode) {
            newNode.next = curr.next ? map.get(curr.next) || null : null;
            newNode.random = curr.random ? map.get(curr.random) || null : null;
        }
        curr = curr.next;
    }

    return map.get(head) || null;
};
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。
    *   我们需要遍历链表两次。
*   **空间复杂度**: $O(n)$。
    *   我们需要维护一个哈希表来存储 $n$ 个节点的映射关系。
