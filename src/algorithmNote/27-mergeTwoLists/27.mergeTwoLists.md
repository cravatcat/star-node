# 合并两个有序链表 (Merge Two Sorted Lists)

## 1. 题目描述

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1:**

![merge_ex1](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

> **输入:** l1 = [1,2,4], l2 = [1,3,4]  
> **输出:** [1,1,2,3,4,4]

**示例 2:**

> **输入:** l1 = [], l2 = []  
> **输出:** []

**示例 3:**

> **输入:** l1 = [], l2 = [0]  
> **输出:** [0]

## 2. 实现思路

这道题是经典的链表操作题目，可以使用 **迭代法** 或 **递归法**。这里推荐使用迭代法，因为它更直观且空间复杂度更低。

**核心思想：**
我们可以创建一个 **哨兵节点 (dummy node)** 作为新链表的头，然后用一个指针 `current` 指向它。
接着比较 `list1` 和 `list2` 当前节点的值：
*   如果 `list1.val <= list2.val`，将 `current.next` 指向 `list1`，并将 `list1` 向后移动。
*   否则，将 `current.next` 指向 `list2`，并将 `list2` 向后移动。
*   无论哪种情况，`current` 指针都要向后移动。

当其中一个链表遍历完后，只需将另一个链表剩余的部分直接接在 `current` 后面即可。

## 3. 详细步骤

1.  创建一个虚拟头节点 `dummy`，值为任意值（如 -1）。
2.  创建一个指针 `current`，初始指向 `dummy`。
3.  当 `list1` 和 `list2` 都不为空时，循环执行：
    *   比较 `list1.val` 和 `list2.val`。
    *   如果 `list1.val` 小于等于 `list2.val`，则 `current.next = list1`，`list1 = list1.next`。
    *   否则，`current.next = list2`，`list2 = list2.next`。
    *   `current = current.next`。
4.  循环结束后，检查 `list1` 或 `list2` 是否还有剩余节点，如果有，直接接到 `current.next`。
5.  返回 `dummy.next`（真正的头节点）。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    // 创建一个虚拟头节点，方便操作
    const dummy = new ListNode(-1);
    let current = dummy;

    while (list1 !== null && list2 !== null) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }

    // 如果其中一个链表还有剩余，直接接到后面
    if (list1 !== null) {
        current.next = list1;
    } else {
        current.next = list2;
    }

    return dummy.next;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n + m)$。其中 $n$ 和 $m$ 分别是两个链表的长度。我们需要遍历两个链表的所有节点。
*   **空间复杂度**: $O(1)$。我们只需要常数空间来存放指针变量。
