# 208. 实现 Trie (前缀树)

## 题目描述

**Trie**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

## 实现思路

Trie 树的核心思想是 **空间换时间**，利用字符串的公共前缀来降低查询时间的开销。

1.  **数据结构设计**：
    - 每个节点包含一个哈希表（或数组）`children`，用于存储子节点（字符 -> 节点）。
    - 每个节点包含一个布尔值 `isEnd`，标记该节点是否是一个单词的结束。

2.  **Insert (插入)**：
    - 从根节点开始，遍历单词的每个字符。
    - 如果当前字符对应的子节点不存在，则创建一个新节点。
    - 移动到子节点。
    - 遍历结束后，将当前节点的 `isEnd` 设为 `true`。

3.  **Search (查找单词)**：
    - 从根节点开始，遍历单词的每个字符。
    - 如果某个字符对应的子节点不存在，说明单词不存在，返回 `false`。
    - 遍历结束后，检查当前节点的 `isEnd` 是否为 `true`。只有当它是单词结束节点时，才算找到。

4.  **StartsWith (查找前缀)**：
    - 与 `Search` 类似，但遍历结束后不需要检查 `isEnd`，只要能顺利遍历完前缀的所有字符，就返回 `true`。

## 代码实现

```typescript
class TrieNode {
  children: { [key: string]: TrieNode };
  isEnd: boolean;

  constructor() {
    this.children = {};
    this.isEnd = false;
  }
}

export class Trie {
  root: TrieNode;

  constructor() {
    this.root = new TrieNode();
  }

  insert(word: string): void {
    let node = this.root;
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
    }
    node.isEnd = true;
  }

  search(word: string): boolean {
    let node = this.root;
    for (const char of word) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    return node.isEnd;
  }

  startsWith(prefix: string): boolean {
    let node = this.root;
    for (const char of prefix) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    return true;
  }
}
```

## 复杂度分析

- **时间复杂度**：
  - `insert`: O(L)，其中 L 是单词的长度。
  - `search`: O(L)。
  - `startsWith`: O(L)。
- **空间复杂度**：O(N * L)，其中 N 是插入的单词数量，L 是单词的平均长度。最坏情况下，没有公共前缀，每个字符都占用一个节点。
