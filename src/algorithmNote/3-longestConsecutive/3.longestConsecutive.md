# 最长连续序列 (Longest Consecutive Sequence)

## 1. 题目描述

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

> **输入:** nums = [100, 4, 200, 1, 3, 2]  
> **输出:** 4  
> **解释:** 最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

**示例 2:**

> **输入:** nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]  
> **输出:** 9

## 2. 实现思路

题目要求时间复杂度为 `O(n)`，因此不能使用常规的排序（排序通常需要 `O(n log n)`）。我们可以利用 **哈希表 (Map)** 来记录每个数字所在连续序列的长度。

核心思想是：对于数组中的每一个数 `num`，如果它之前没有被处理过，我们查看它左右相邻的数 `num - 1` 和 `num + 1` 是否存在于哈希表中，从而获取它们所在序列的长度，然后将它们合并成一个更大的序列。

## 3. 详细步骤

1.  初始化一个空的哈希表 `map`，用于存储 `数字 -> 该数字所在连续序列的长度`。
2.  遍历数组 `nums` 中的每个数字 `num`。
3.  **去重检查**：如果 `num` 已经在 `map` 中，说明已经处理过，直接跳过。
4.  **获取相邻序列长度**：
    *   检查 `num - 1` 是否在 `map` 中，获取其长度 `left`（如果不存在则为 0）。
    *   检查 `num + 1` 是否在 `map` 中，获取其长度 `right`（如果不存在则为 0）。
5.  **计算当前序列长度**：`currentLen = left + right + 1`。
6.  **更新哈希表**：
    *   `map.set(num, currentLen)`：更新当前数字的长度（防止重复处理）。
    *   **关键点**：我们需要更新该序列 **左右边界** 的长度值，因为新加入的 `num` 连接了左右两部分（或者扩展了某一边）。
    *   左边界是 `num - left`，更新其长度为 `currentLen`。
    *   右边界是 `num + right`，更新其长度为 `currentLen`。
7.  **更新全局最大值**：`max = Math.max(max, currentLen)`。
8.  遍历结束后返回 `max`。

## 4. 代码实现 (TypeScript)

```typescript
function longestConsecutive(nums: number[]): number {
  if (nums.length === 0) return 0;

  const map = new Map();
  let max = 1;

  for (const num of nums) {
    // 如果 map 中已经存在该数字，说明已经处理过，跳过以避免重复计算
    if (!map.has(num)) {
      // 获取左边相邻数字所在序列的长度
      const leftLen = map.get(num - 1) ?? 0;
      // 获取右边相邻数字所在序列的长度
      const rightLen = map.get(num + 1) ?? 0;
      
      // 当前连续序列的总长度
      const currentLen = leftLen + rightLen + 1;

      // 更新当前数字的长度（主要是为了标记已访问）
      map.set(num, currentLen);
      
      // 更新序列左边界的长度
      map.set(num - leftLen, currentLen);
      
      // 更新序列右边界的长度
      map.set(num + rightLen, currentLen);

      // 更新全局最大长度
      max = Math.max(max, currentLen);
    }
  }

  return max;
};

export default longestConsecutive;
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。
    *   我们只遍历了一次数组。
    *   哈希表的查找和插入操作平均是 $O(1)$ 的。
*   **空间复杂度**: $O(n)$。
    *   需要一个哈希表来存储数组中的元素及其对应的序列长度。
