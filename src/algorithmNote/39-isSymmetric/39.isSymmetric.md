# 对称二叉树 (Symmetric Tree)

## 1. 题目描述

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1:**

![symtree1](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

> **输入:** root = [1,2,2,3,4,4,3]  
> **输出:** true

**示例 2:**

![symtree2](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

> **输入:** root = [1,2,2,null,3,null,3]  
> **输出:** false

## 2. 实现思路

要判断一个二叉树是否对称，实际上是要判断根节点的 **左子树** 和 **右子树** 是否镜像对称。

我们可以定义一个辅助函数 `check(p, q)` 来判断两棵树 `p` 和 `q` 是否镜像对称：
1.  如果 `p` 和 `q` 都为空，则对称，返回 `true`。
2.  如果 `p` 和 `q` 只有一个为空，则不对称，返回 `false`。
3.  如果 `p` 和 `q` 的值不相等，则不对称，返回 `false`。
4.  递归判断：
    *   `p` 的左子树 和 `q` 的右子树是否对称。
    *   `p` 的右子树 和 `q` 的左子树是否对称。
    *   只有两者都满足，才算对称。

## 3. 代码实现 (TypeScript)

```typescript
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function isSymmetric(root: TreeNode | null): boolean {
    if (root === null) return true;
    return check(root.left, root.right);
}

function check(p: TreeNode | null, q: TreeNode | null): boolean {
    // 1. 两个都为空，对称
    if (p === null && q === null) return true;
    // 2. 一个为空一个不为空，不对称
    if (p === null || q === null) return false;
    
    // 3. 值相等，且 外侧(p.left, q.right) 和 内侧(p.right, q.left) 都对称
    return p.val === q.val && check(p.left, q.right) && check(p.right, q.left);
}
```

## 4. 复杂度分析

*   **时间复杂度**: $O(n)$。其中 $n$ 是二叉树的节点数。我们需要遍历每个节点一次。
*   **空间复杂度**: $O(n)$。递归调用的栈空间，最坏情况下为 $O(n)$，平均情况下为 $O(\log n)$。
