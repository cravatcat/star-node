# 98. 验证二叉搜索树

## 题目描述

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

1. 节点的左子树只包含 **小于** 当前节点的数。
2. 节点的右子树只包含 **大于** 当前节点的数。
3. 所有左子树和右子树自身必须也是二叉搜索树。

## 实现思路

要验证二叉搜索树，单纯判断每个节点是否满足 "左 < 根 < 右" 是不够的，因为右子树中的某个节点可能小于根节点，或者左子树中的某个节点可能大于根节点。

我们需要在遍历树的过程中，维护一个合法的取值范围 `(lower, upper)`。

- 对于根节点，范围是 `(-Infinity, Infinity)`。
- 当我们遍历左子树时，当前节点的值成为了左子树中所有节点及其后代的 **上界**。
- 当我们遍历右子树时，当前节点的值成为了右子树中所有节点及其后代的 **下界**。

递归函数设计：`validate(node, lower, upper)`
1. 如果 `node` 为空，返回 `true`。
2. 如果 `node.val` 不在 `(lower, upper)` 范围内，返回 `false`。
3. 递归验证左子树 `validate(node.left, lower, node.val)` 和右子树 `validate(node.right, node.val, upper)`。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function isValidBST(root: TreeNode | null): boolean {
  return validate(root, -Infinity, Infinity);
}

function validate(node: TreeNode | null, min: number, max: number): boolean {
  if (!node) {
    return true;
  }

  if (node.val <= min || node.val >= max) {
    return false;
  }

  return validate(node.left, min, node.val) && validate(node.right, node.val, max);
}
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是二叉树的节点数。每个节点恰好被访问一次。
- **空间复杂度**：O(n)，最坏情况下（树退化为链表），递归栈的深度为 n。平均情况下深度为 O(log n)。
