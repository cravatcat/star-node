# 合并区间 (Merge Intervals)

## 1. 题目描述

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1:**

> **输入:** intervals = [[1,3],[2,6],[8,10],[15,18]]  
> **输出:** [[1,6],[8,10],[15,18]]  
> **解释:** 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

**示例 2:**

> **输入:** intervals = [[1,4],[4,5]]  
> **输出:** [[1,5]]  
> **解释:** 区间 [1,4] 和 [4,5] 可被视为重叠区间。

## 2. 实现思路

我们首先将所有区间按照 **左端点 (start)** 从小到大进行排序。

排序后，我们可以保证对于任意两个相邻的区间 `intervals[i]` 和 `intervals[i+1]`，一定有 `intervals[i][0] <= intervals[i+1][0]`。

然后我们将第一个区间加入 `merged` 数组中，并依次考虑之后的每个区间：

* 如果当前区间的左端点 `intervals[i][0]` 大于 `merged` 数组中最后一个区间的右端点 `merged[last][1]`，那么说明它们不重叠，直接将当前区间加入 `merged` 数组。
* 否则，说明它们重叠，我们需要用当前区间的右端点更新 `merged` 数组中最后一个区间的右端点，将其置为 `max(merged[last][1], intervals[i][1])`。

## 3. 详细步骤

1. 如果 `intervals` 为空，直接返回空数组。
2. 将 `intervals` 按照左端点升序排序。
3. 初始化一个结果数组 `merged`。
4. 遍历排序后的 `intervals`：
    * 如果 `merged` 为空，或者 `merged` 最后一个元素的右端点 < 当前区间的左端点：
        * 直接将当前区间加入 `merged`。
    * 否则（发生重叠）：
        * 更新 `merged` 最后一个元素的右端点为 `max(原右端点, 当前区间右端点)`。
5. 返回 `merged`。

## 4. 代码实现 (TypeScript)

```typescript
function merge(intervals: number[][]): number[][] {
  if (intervals.length === 0) return [];

  // 按照区间的左端点排序
  intervals.sort((a, b) => a[0] - b[0]);

  const merged: number[][] = [];
  
  for (const interval of intervals) {
    const L = interval[0], R = interval[1];
    
    // 如果列表为空，或者当前区间与上一区间不重合，直接添加
    if (merged.length === 0 || merged[merged.length - 1][1] < L) {
      merged.push([L, R]);
    } else {
      // 否则，我们将当前区间合并到上一区间
      // 更新上一区间的右端点，取两个区间右端点的最大值
      merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], R);
    }
  }

  return merged;
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(n \log n)$。其中 $n$ 为区间的数量。除去 $O(n)$ 的遍历时间，主要开销在于排序，排序的时间复杂度为 $O(n \log n)$。
* **空间复杂度**: $O(\log n)$。这里计算的是排序所需要的栈空间。如果忽略排序的开销，则是 $O(1)$（不包含存储结果的空间）。
