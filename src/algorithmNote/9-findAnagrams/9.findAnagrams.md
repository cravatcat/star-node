# 找到字符串中所有字母异位词 (Find All Anagrams in a String)

## 1. 题目描述

给定两个字符串 `s` 和 `p`，找到 `s` 中所有是 `p` 的 **字母异位词** 的子串，返回这些子串的起始索引。

**字母异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

> **输入:** s = "cbaebabacd", p = "abc"  
> **输出:** [0,6]  
> **解释:**  
> 起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。  
> 起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。

**示例 2:**

> **输入:** s = "abab", p = "ab"  
> **输出:** [0,1,2]  
> **解释:**  
> 起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。  
> 起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。  
> 起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。

## 2. 实现思路

这道题是 **固定长度的滑动窗口** 问题。

我们需要在字符串 `s` 中寻找长度与 `p` 相同的子串，判断该子串的字符组成是否与 `p` 相同。

1.  **字符计数**：由于题目只包含小写字母，我们可以使用长度为 26 的数组来代替哈希表统计字符出现的频率。
2.  **滑动窗口**：
    *   首先统计 `p` 的字符计数 `pCount`。
    *   初始化窗口：统计 `s` 中前 `p.length` 个字符的计数 `sCount`。
    *   比较 `pCount` 和 `sCount`，如果相同，则索引 `0` 是一个解。
    *   开始滑动：每次向右移动一位，将窗口最左边的字符移出（计数 -1），将窗口最右边新加入的字符移入（计数 +1）。
    *   每次移动后，再次比较 `pCount` 和 `sCount`。

## 3. 详细步骤

1.  获取 `s` 和 `p` 的长度 `sLen`, `pLen`。如果 `sLen < pLen`，直接返回空数组。
2.  初始化两个长度为 26 的数组 `sCount` 和 `pCount`。
3.  遍历 `p`，统计 `pCount`；同时统计 `s` 的前 `pLen` 个字符到 `sCount`。
4.  比较 `sCount` 和 `pCount`，如果相等，将 `0` 加入结果数组。
5.  从 `i = 0` 开始遍历（表示滑动窗口即将移出的元素的索引），直到 `sLen - pLen - 1`：
    *   移出字符：`sCount[s[i] - 'a']--`
    *   移入字符：`sCount[s[i + pLen] - 'a']++`
    *   比较 `sCount` 和 `pCount`，如果相等，将 `i + 1` 加入结果数组。
6.  返回结果数组。

## 4. 代码实现 (TypeScript)

```typescript
function findAnagrams(s: string, p: string): number[] {
    const sLen = s.length;
    const pLen = p.length;
    const ans: number[] = [];

    if (sLen < pLen) return ans;

    const pCount = new Array(26).fill(0);
    const sCount = new Array(26).fill(0);

    // 统计 p 的字符计数，以及 s 中前 pLen 个字符的计数
    for (let i = 0; i < pLen; i++) {
        pCount[p.charCodeAt(i) - 97]++;
        sCount[s.charCodeAt(i) - 97]++;
    }

    // 检查初始窗口
    if (arraysEqual(pCount, sCount)) {
        ans.push(0);
    }

    // 滑动窗口
    for (let i = 0; i < sLen - pLen; i++) {
        // 移除窗口最左边的字符
        sCount[s.charCodeAt(i) - 97]--;
        // 加入窗口最右边的字符 (当前 i 是移除的，i + pLen 是新加入的)
        sCount[s.charCodeAt(i + pLen) - 97]++;

        // 检查当前窗口
        if (arraysEqual(pCount, sCount)) {
            ans.push(i + 1);
        }
    }

    return ans;
};

function arraysEqual(arr1: number[], arr2: number[]): boolean {
    for (let i = 0; i < 26; i++) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$，其中 $n$ 是字符串 `s` 的长度。
    *   虽然每次滑动都需要比较两个数组，但数组长度固定为 26，可以视为常数时间 $O(1)$。
    *   总共滑动 $n$ 次。
*   **空间复杂度**: $O(1)$。
    *   我们只使用了两个长度为 26 的数组，与输入规模无关。
