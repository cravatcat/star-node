# 236. 二叉树的最近公共祖先

## 题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

## 实现思路

我们可以使用 **后序遍历**（自底向上）的递归思路。

对于当前节点 `root`，我们想知道 `p` 和 `q` 是否在它的子树中：
1. **终止条件**：
   - 如果 `root` 为空，返回 `null`。
   - 如果 `root` 等于 `p` 或 `q`，说明找到了其中一个，直接返回 `root`。

2. **递归步骤**：
   - 在左子树中寻找 `p` 和 `q` 的公共祖先，记为 `left`。
   - 在右子树中寻找 `p` 和 `q` 的公共祖先，记为 `right`。

3. **判断逻辑**：
   - 如果 `left` 和 `right` **都不为空**，说明 `p` 和 `q` 分别在 `root` 的左右两侧，那么 `root` 就是最近公共祖先。
   - 如果 `left` 不为空，`right` 为空，说明 `p`和 `q` 都在左子树中，返回 `left`。
   - 如果 `left` 为空，`right` 不为空，说明 `p`和 `q` 都在右子树中，返回 `right`。
   - 如果都为空，说明没找到，返回 `null`。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
  // 1. 终止条件：到达叶子节点或找到了 p 或 q
  if (!root || root === p || root === q) {
    return root;
  }

  // 2. 递归左右子树
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);

  // 3. 处理结果
  // 如果左右返回值都不为空，说明 p 和 q 分别在左右子树中，当前节点即为 LCA
  if (left && right) {
    return root;
  }

  // 如果只有一个不为空，说明 p 和 q 都在那一侧（或者只找到了其中一个，继续向上返回）
  return left ? left : right;
}
```

## 复杂度分析

- **时间复杂度**：O(N)，其中 N 是二叉树的节点数。我们需要遍历所有节点。
- **空间复杂度**：O(N)，最坏情况下（链状树）递归栈的深度为 N。
