# 最大子数组和 (Maximum Subarray)

## 1. 题目描述

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1:**

> **输入:** nums = [-2,1,-3,4,-1,2,1,-5,4]  
> **输出:** 6  
> **解释:** 连续子数组 [4,-1,2,1] 的和最大，为 6。

**示例 2:**

> **输入:** nums = [1]  
> **输出:** 1

**示例 3:**

> **输入:** nums = [5,4,-1,7,8]  
> **输出:** 23

## 2. 实现思路

这道题可以使用 **动态规划 (Dynamic Programming)** 的思想来解决，即著名的 **Kadane 算法**。

我们需要定义一个状态，假设 `f(i)` 代表以第 `i` 个数结尾的“连续子数组的最大和”。

那么对于 `nums[i]`，我们有两种选择：
1. **加入前面的子数组**：如果前面的子数组和 `f(i-1)` 大于 0，那么加上 `nums[i]` 会让和变得更大（或者至少比单独的 `nums[i]` 大）。此时 `f(i) = f(i-1) + nums[i]`。
2. **自己另起炉灶**：如果前面的子数组和 `f(i-1)` 小于等于 0，那么加上它反而会拖累 `nums[i]`。此时不如直接从 `nums[i]` 开始计算，即 `f(i) = nums[i]`。

综上所述，状态转移方程为：
$$ f(i) = \max(f(i-1) + nums[i], nums[i]) $$

我们只需要遍历一遍数组，计算出所有的 `f(i)`，然后取其中的最大值即可。

由于 `f(i)` 只和 `f(i-1)` 有关，我们可以用一个变量 `pre` 来维护当前的最大子数组和，从而将空间复杂度优化到 $O(1)$。

## 3. 详细步骤

1. 初始化变量 `pre` 为 0，用于记录以当前元素结尾的最大子数组和。
2. 初始化变量 `maxAns` 为 `nums[0]`，用于记录全局的最大和。
3. 遍历数组 `nums` 中的每一个元素 `x`：
    * 更新 `pre`：`pre = max(pre + x, x)`。这表示如果之前的累加和 `pre` 加上当前元素 `x` 还没有当前元素 `x` 本身大，那就丢弃之前的累加和，从 `x` 重新开始。
    * 更新 `maxAns`：`maxAns = max(maxAns, pre)`。比较当前计算出的最大子数组和与全局最大和。
4. 遍历结束后，`maxAns` 即为结果。

## 4. 代码实现 (TypeScript)

```typescript
function maxSubArray(nums: number[]): number {
  let pre = 0;
  let maxAns = nums[0];
  for (const x of nums) {
    // 如果前一个子数组和 pre > 0，则加上 x 能更大；
    // 否则不如直接用 x 作为一个新的子数组起点
    // 等价于 pre = Math.max(pre + x, x);
    pre = Math.max(pre + x, x);
    
    // 更新全局最大值
    maxAns = Math.max(maxAns, pre);
  }
  return maxAns;
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(n)$。其中 $n$ 为 `nums` 数组的长度。我们需要遍历一遍数组。
* **空间复杂度**: $O(1)$。我们只需要常数空间来存放 `pre` 和 `maxAns` 两个变量。
