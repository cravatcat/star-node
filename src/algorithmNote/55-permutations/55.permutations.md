# 46. 全排列

## 题目描述

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

## 实现思路

这是一个经典的 **回溯 (Backtracking)** 问题。我们可以把它看作是一棵决策树的遍历过程。

对于排列中的每一个位置，我们都需要从剩下的未使用的数字中选择一个填入。

**回溯算法框架**：
1. **路径 (`path`)**：记录当前已经选择的数字。
2. **选择列表**：当前还可以选择哪些数字？（通过 `used` 数组来标记哪些数字已经被选过）。
3. **结束条件**：当 `path` 的长度等于 `nums` 的长度时，说明已经形成了一个完整的排列，将其加入结果集 `res`。

**具体步骤**：
1. 定义一个 `backtrack` 函数。
2. 在函数内部，遍历 `nums` 中的每个数字：
   - 如果该数字已经被使用 (`used[i] === true`)，跳过。
   - 否则，做选择：将该数字加入 `path`，标记 `used[i] = true`。
   - 递归调用 `backtrack`。
   - 撤销选择（回溯）：将该数字从 `path` 移出，标记 `used[i] = false`。

## 代码实现

```typescript
export function permute(nums: number[]): number[][] {
  const res: number[][] = [];
  const path: number[] = [];
  // used 数组用于记录每个位置的数字是否被使用过
  const used = new Array(nums.length).fill(false);

  function backtrack() {
    // 触发结束条件
    if (path.length === nums.length) {
      res.push([...path]); // 注意要拷贝一份 path
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      // 如果该数字已被使用，跳过
      if (used[i]) {
        continue;
      }
      
      // 做选择
      path.push(nums[i]);
      used[i] = true;
      
      // 进入下一层决策树
      backtrack();
      
      // 取消选择
      path.pop();
      used[i] = false;
    }
  }

  backtrack();
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(N * N!)，其中 N 是数组的长度。全排列共有 N! 种，每次生成一个排列需要 O(N) 的时间（复制数组）。
- **空间复杂度**：O(N)，递归栈的深度为 N，`used` 数组和 `path` 数组也占用 O(N)。
