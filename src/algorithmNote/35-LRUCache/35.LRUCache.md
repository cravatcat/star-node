# LRU 缓存 (LRU Cache)

## 1. 题目描述

请你设计并实现一个满足  **[LRU (最近最少使用) 缓存](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)** 约束的数据结构。

实现 `LRUCache` 类：

*   `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存。
*   `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
*   `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 $O(1)$ 的平均时间复杂度运行。

**示例：**

> **输入**
> ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
> [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
> **输出**
> [null, null, null, 1, null, -1, null, -1, 3, 4]
>
> **解释**
> LRUCache lRUCache = new LRUCache(2);
> lRUCache.put(1, 1); // 缓存是 {1=1}
> lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
> lRUCache.get(1);    // 返回 1
> lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
> lRUCache.get(2);    // 返回 -1 (未找到)
> lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
> lRUCache.get(1);    // 返回 -1 (未找到)
> lRUCache.get(3);    // 返回 3
> lRUCache.get(4);    // 返回 4

## 2. 实现思路

要让 `get` 和 `put` 的时间复杂度都为 $O(1)$，我们需要结合使用 **哈希表 (HashMap)** 和 **双向链表 (Doubly Linked List)**。

*   **哈希表**：用于存储 `key` 到 `Node` 的映射，从而实现 $O(1)$ 的快速查找。
*   **双向链表**：用于维护节点的顺序（最近使用顺序）。
    *   链表 **头部** 存放最近使用的节点。
    *   链表 **尾部** 存放最久未使用的节点。

**具体操作逻辑：**

1.  **get(key)**:
    *   检查哈希表中是否存在 `key`。
    *   如果不存，返回 -1。
    *   如果存在，通过哈希表找到对应的节点。
    *   **关键步骤**：将该节点从链表中当前位置移动到 **头部**（表示最近刚刚使用过）。
    *   返回节点的值。

2.  **put(key, value)**:
    *   检查哈希表中是否存在 `key`。
    *   **如果存在**：
        *   更新节点的 `value`。
        *   将该节点移动到 **头部**。
    *   **如果不存在**：
        *   创建一个新节点。
        *   将新节点添加到 **头部**。
        *   在哈希表中添加映射。
        *   **检查容量**：如果当前节点数超过 `capacity`，需要删除 **尾部** 的节点（最久未使用的），并从哈希表中移除对应的映射。

为了简化链表操作（避免频繁判断 null），我们通常使用两个 **哨兵节点 (Dummy Nodes)**：`head` 和 `tail`，分别指向链表的头和尾。

## 3. 详细步骤

1.  定义双向链表节点类 `DListNode`，包含 `key`, `value`, `prev`, `next`。
2.  定义 `LRUCache` 类：
    *   属性：`capacity` (容量), `map` (哈希表), `head`, `tail` (虚拟头尾节点)。
    *   构造函数：初始化容量，创建 `map`，创建并连接 `head` 和 `tail`。
3.  辅助函数：
    *   `addToHead(node)`: 将节点插入到 `head` 之后。
    *   `removeNode(node)`: 从链表中删除指定节点。
    *   `moveToHead(node)`: 相当于 `removeNode(node)` + `addToHead(node)`。
    *   `removeTail()`: 删除并返回 `tail` 之前的节点（即真实的尾节点）。
4.  实现 `get` 和 `put` 逻辑（如思路中所述）。

## 4. 代码实现 (TypeScript)

```typescript
class DListNode {
    key: number;
    value: number;
    prev: DListNode | null;
    next: DListNode | null;

    constructor(key?: number, value?: number) {
        this.key = key === undefined ? 0 : key;
        this.value = value === undefined ? 0 : value;
        this.prev = null;
        this.next = null;
    }
}

class LRUCache {
    private capacity: number;
    private map: Map<number, DListNode>;
    private head: DListNode;
    private tail: DListNode;

    constructor(capacity: number) {
        this.capacity = capacity;
        this.map = new Map<number, DListNode>();
        
        // 使用虚拟头尾节点，简化边界处理
        this.head = new DListNode();
        this.tail = new DListNode();
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }

    get(key: number): number {
        if (!this.map.has(key)) {
            return -1;
        }

        // 存在该 key，将其移动到链表头部（表示最近使用）
        const node = this.map.get(key)!;
        this.moveToHead(node);
        return node.value;
    }

    put(key: number, value: number): void {
        if (this.map.has(key)) {
            // 如果 key 已存在，更新 value，并移到头部
            const node = this.map.get(key)!;
            node.value = value;
            this.moveToHead(node);
        } else {
            // 如果 key 不存在，创建新节点
            const newNode = new DListNode(key, value);
            this.map.set(key, newNode);
            this.addToHead(newNode);

            // 检查是否超出容量
            if (this.map.size > this.capacity) {
                const removed = this.removeTail();
                this.map.delete(removed.key);
            }
        }
    }

    private addToHead(node: DListNode): void {
        node.prev = this.head;
        node.next = this.head.next;
        this.head.next!.prev = node;
        this.head.next = node;
    }

    private removeNode(node: DListNode): void {
        node.prev!.next = node.next;
        node.next!.prev = node.prev;
    }

    private moveToHead(node: DListNode): void {
        this.removeNode(node);
        this.addToHead(node);
    }

    private removeTail(): DListNode {
        const node = this.tail.prev!;
        this.removeNode(node);
        return node;
    }
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(1)$。
    *   `get` 和 `put` 操作都只涉及哈希表查找（$O(1)$）和链表节点移动（$O(1)$）。
*   **空间复杂度**: $O(capacity)$。
    *   我们需要存储最多 `capacity` 个节点在哈希表和链表中。
