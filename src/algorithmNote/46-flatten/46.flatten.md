# 114. 二叉树展开为链表

## 题目描述

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

1. 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而 `left` 子指针始终为 `null` 。
2. 展开后的单链表应该与二叉树 **先序遍历** 顺序相同。

## 实现思路

我们需要将二叉树“拉直”。观察先序遍历的顺序（根 -> 左 -> 右），我们可以发现对于任意节点 `curr`：
1. 如果它有左子树，那么左子树应该被插入到 `curr` 和 `curr.right` 之间。
2. 具体来说，`curr` 的原始右子树，应该接到 `curr` 左子树中 **最右边** 的节点（即左子树中先序遍历的最后一个节点）的 `right` 指针上。
3. 然后，将 `curr.left` 移动到 `curr.right`，并将 `curr.left` 置空。

我们可以使用迭代的方式（寻找前驱节点）来实现，这种方法空间复杂度为 O(1)。

具体步骤：
1. 初始化 `curr` 指向 `root`。
2. 当 `curr` 不为空时：
   - 如果 `curr` 有左子节点：
     - 找到左子树的最右节点 `predecessor`。
     - 将 `curr.right` 接到 `predecessor.right` 上。
     - 将 `curr.left` 移到 `curr.right`。
     - 将 `curr.left` 置为 `null`。
   - `curr` 向右移动 (`curr = curr.right`)。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function flatten(root: TreeNode | null): void {
  let curr = root;
  
  while (curr) {
    if (curr.left) {
      const next = curr.left;
      let predecessor = next;
      
      // 找到左子树的最右节点
      while (predecessor.right) {
        predecessor = predecessor.right;
      }
      
      // 将原来的右子树接到左子树的最右节点后面
      predecessor.right = curr.right;
      
      // 将左子树移到右边
      curr.left = null;
      curr.right = next;
    }
    // 继续处理链表中的下一个节点
    curr = curr.right;
  }
}
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是二叉树的节点数。虽然有寻找前驱节点的循环，但每条边最多被访问两次，因此总体是线性的。
- **空间复杂度**：O(1)，直接在原树上修改指针，不需要额外的栈或队列空间。
