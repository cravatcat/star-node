# 994. 腐烂的橘子

## 题目描述

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数*。如果不可能，返回 `-1`。

## 实现思路

这道题是一个典型的 **多源广度优先搜索 (Multi-source BFS)** 问题。

我们可以把所有一开始就是腐烂的橘子看作是病毒的源头，它们同时开始向外扩散。每一轮扩散（即每一分钟），所有当前腐烂的橘子都会让它周围的新鲜橘子变腐烂。

步骤：
1. 遍历网格，将所有 **腐烂橘子** 的坐标加入队列 `queue`，并统计 **新鲜橘子** 的数量 `freshCount`。
2. 如果一开始就没有新鲜橘子 (`freshCount === 0`)，直接返回 0。
3. 开始 BFS 循环：
   - 只要队列不为空且 `freshCount > 0`，时间 `minutes` 加 1。
   - 取出当前队列中的所有橘子（代表这一分钟内腐烂的橘子）。
   - 遍历它们的上下左右四个邻居：
     - 如果邻居是新鲜橘子 (`1`)，将其标记为腐烂 (`2`)，`freshCount` 减 1，并加入队列。
4. 循环结束后，如果 `freshCount` 仍大于 0，说明还有橘子没被感染到（即不可达），返回 -1；否则返回 `minutes`。

## 代码实现

```typescript
export function orangesRotting(grid: number[][]): number {
  if (!grid || grid.length === 0) return 0;

  const m = grid.length;
  const n = grid[0].length;
  const queue: [number, number][] = [];
  let freshCount = 0;

  // 1. 初始化队列，统计新鲜橘子数量
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === 2) {
        queue.push([i, j]);
      } else if (grid[i][j] === 1) {
        freshCount++;
      }
    }
  }

  // 如果没有新鲜橘子，不需要等待
  if (freshCount === 0) return 0;

  let minutes = 0;
  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];

  // 2. BFS 开始
  // 注意条件：队列不为空 且 还有新鲜橘子
  // 如果新鲜橘子为 0 了，BFS 应该停止，避免多加一次 minutes
  while (queue.length > 0 && freshCount > 0) {
    const size = queue.length;
    minutes++; // 每一层代表一分钟

    for (let i = 0; i < size; i++) {
      const [currRow, currCol] = queue.shift()!;

      for (const [dr, dc] of dirs) {
        const newRow = currRow + dr;
        const newCol = currCol + dc;

        if (
          newRow >= 0 && newRow < m &&
          newCol >= 0 && newCol < n &&
          grid[newRow][newCol] === 1
        ) {
          grid[newRow][newCol] = 2; // 腐烂它
          freshCount--;
          queue.push([newRow, newCol]); // 加入队列，下一轮继续扩散
        }
      }
    }
  }

  // 3. 检查是否还有新鲜橘子
  return freshCount === 0 ? minutes : -1;
}
```

## 复杂度分析

- **时间复杂度**：O(M * N)，其中 M 和 N 是网格的行数和列数。每个格子最多进队一次。
- **空间复杂度**：O(M * N)，队列最坏情况下可能存储 M * N 个元素（全副武装）。
