# 排序链表 (Sort List)

## 1. 题目描述

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**进阶：** 你可以在 $O(n \log n)$ 时间复杂度和常数级空间复杂度下解决此问题吗？

**示例 1：**

![sort_list_1](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

> **输入：** head = [4,2,1,3]
> **输出：** [1,2,3,4]

**示例 2：**

![sort_list_2](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

> **输入：** head = [-1,5,3,4,0]
> **输出：** [-1,0,3,4,5]

**示例 3：**

> **输入：** head = []
> **输出：** []

## 2. 实现思路

题目要求 $O(n \log n)$ 的时间复杂度，这通常指向 **归并排序 (Merge Sort)**、**堆排序 (Heap Sort)** 或 **快速排序 (Quick Sort)**。

对于链表来说，**归并排序** 是最适合的算法，因为：

1. **归并排序** 在链表上实现时，不需要额外的辅助数组空间（除了递归栈空间），可以做到 $O(1)$ 辅助空间（如果是自底向上的归并排序）。
2. **快速排序** 在链表上实现相对复杂（主要是分区操作），且最坏情况可能退化为 $O(n^2)$。
3. **堆排序** 需要随机访问，不适合链表。

我们这里采用 **自顶向下 (Top-Down)** 的归并排序，虽然递归会占用 $O(\log n)$ 的栈空间，但代码逻辑更清晰，且符合大多数面试对“常数级空间”的宽容定义（通常指堆空间）。如果要严格 $O(1)$ 空间，可以使用 **自底向上 (Bottom-Up)** 的归并排序。

### 归并排序逻辑

1. **分割 (Split)**：找到链表的中点，将链表一分为二。我们可以使用 **快慢指针** 法来找到中点。
2. **递归 (Recursion)**：对左半部分和右半部分分别进行递归排序。
3. **合并 (Merge)**：将两个排序好的子链表合并成一个有序链表。这正是 **合并两个有序链表** (LeetCode 21) 的逻辑。

## 3. 详细步骤

1. **Base Case**：如果链表为空或只有一个节点，直接返回 `head`。
2. **找中点**：
    * 使用快慢指针 `fast` 和 `slow`。
    * `fast` 每次走两步，`slow` 每次走一步。
    * 当 `fast` 到达末尾时，`slow` 刚好在中间。
    * **注意**：为了正确断开链表，我们通常让 `fast` 初始为 `head.next`，或者在循环中记录 `slow` 的前驱节点。这里采用 `fast = head.next` 的方式，使得 `slow` 停在中间节点的前一个位置（偶数个节点时）或中间位置（奇数个节点时），方便断开。
3. **断链**：记录 `mid = slow.next`，然后将 `slow.next` 设为 `null`，将链表断开为 `head` 到 `slow` 和 `mid` 到末尾两段。
4. **递归排序**：
    * `left = sortList(head)`
    * `right = sortList(mid)`
5. **合并**：调用 `merge(left, right)` 将两段有序链表合并并返回。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function sortList(head: ListNode | null): ListNode | null {
    // 1. Base case: 0 or 1 node
    if (!head || !head.next) {
        return head;
    }

    // 2. Split the list into two halves
    // 使用快慢指针寻找中点
    // 让 fast 从 head.next 开始，可以保证 slow 停在前半段的最后一个节点
    let slow: ListNode | null = head;
    let fast: ListNode | null = head.next;
    
    while (fast && fast.next) {
        slow = slow!.next;
        fast = fast.next.next;
    }

    const mid = slow!.next;
    slow!.next = null; // 断开链表

    // 3. Recursively sort each half
    const left = sortList(head);
    const right = sortList(mid);

    // 4. Merge the sorted halves
    return merge(left, right);
}

// 合并两个有序链表 (参考 LeetCode 21)
function merge(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    const dummy = new ListNode(0);
    let curr = dummy;

    while (l1 && l2) {
        if (l1.val < l2.val) {
            curr.next = l1;
            l1 = l1.next;
        } else {
            curr.next = l2;
            l2 = l2.next;
        }
        curr = curr.next;
    }

    if (l1) {
        curr.next = l1;
    }
    if (l2) {
        curr.next = l2;
    }

    return dummy.next;
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(n \log n)$。
  * 归并排序将链表分成两半，深度为 $\log n$。
  * 每一层合并操作需要遍历所有节点，耗时 $O(n)$。
  * 总时间复杂度为 $O(n \log n)$。
* **空间复杂度**: $O(\log n)$。
  * 主要消耗在于递归调用栈的空间，递归深度为 $\log n$。
  * 如果是自底向上的归并排序，空间复杂度可以优化到 $O(1)$。
