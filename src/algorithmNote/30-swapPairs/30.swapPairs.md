# 两两交换链表中的节点 (Swap Nodes in Pairs)

## 1. 题目描述

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1:**

![swap_ex1](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

> **输入:** head = [1,2,3,4]
> **输出:** [2,1,4,3]

**示例 2:**

> **输入:** head = []
> **输出:** []

**示例 3:**

> **输入:** head = [1]
> **输出:** [1]

## 2. 实现思路

这道题要求两两交换链表中的节点。我们可以使用 **迭代** 的方式来解决。

为了方便处理头节点的交换（因为头节点也会变），我们可以创建一个 **虚拟头节点 (dummy node)**，让它的 `next` 指向真正的 `head`。

核心逻辑是：
1. 我们需要一个指针 `current` 指向要交换的两个节点的前一个节点（初始时指向 `dummy`）。
2. 每次判断 `current.next` 和 `current.next.next` 是否存在。如果都存在，说明后面至少有两个节点可以交换。
3. 设 `node1 = current.next`，`node2 = current.next.next`。
4. 进行交换操作：
    * `current.next` 指向 `node2`
    * `node1.next` 指向 `node2.next`
    * `node2.next` 指向 `node1`
5. 交换完成后，`current` 移动到 `node1`（因为 `node1` 现在是这一对的后一个节点），准备处理下一对。

## 3. 详细步骤

1. 创建一个 `dummy` 节点，`dummy.next = head`。
2. 初始化 `current = dummy`。
3. 当 `current.next` 和 `current.next.next` 都不为空时，循环执行以下步骤：
    * 定义 `node1 = current.next`。
    * 定义 `node2 = current.next.next`。
    * 将 `current.next` 指向 `node2`。
    * 将 `node1.next` 指向 `node2.next`（保存后续链表）。
    * 将 `node2.next` 指向 `node1`（完成交换）。
    * 更新 `current = node1`，移动到下一对的前面。
4. 返回 `dummy.next`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function swapPairs(head: ListNode | null): ListNode | null {
    const dummy = new ListNode(0);
    dummy.next = head;
    let current = dummy;

    while (current.next !== null && current.next.next !== null) {
        const node1 = current.next;
        const node2 = current.next.next;

        current.next = node2;
        node1.next = node2.next;
        node2.next = node1;

        current = node1;
    }

    return dummy.next;
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(n)$。我们需要遍历链表一次，每次交换操作是常数时间。
* **空间复杂度**: $O(1)$。我们只使用了常数个额外的指针变量，没有使用与链表长度相关的额外空间。
