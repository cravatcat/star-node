# 230. 二叉搜索树中第 K 小的元素

## 题目描述

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

## 实现思路

二叉搜索树（BST）具有一个重要性质：**中序遍历**（左子树 -> 根节点 -> 右子树）的结果是一个严格递增的有序序列。

基于这个性质，我们只需要对二叉搜索树进行中序遍历，并维护一个计数器。
1. 每遍历到一个节点，计数器加 1。
2. 当计数器等于 `k` 时，当前节点的值就是第 `k` 小的元素。

为了能够提前停止（找到第 k 个就返回，不用遍历完），我们可以使用 **迭代法**（使用栈模拟递归）来实现中序遍历。

## 代码实现

```typescript
export class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

export function kthSmallest(root: TreeNode | null, k: number): number {
  const stack: TreeNode[] = [];
  let current = root;
  let count = 0;

  while (current || stack.length > 0) {
    // 一路向左，将沿途节点压入栈
    while (current) {
      stack.push(current);
      current = current.left;
    }
    
    // 弹出栈顶元素，即为当前最小的元素
    current = stack.pop()!;
    count++;
    
    // 如果是第 k 个，直接返回
    if (count === k) {
      return current.val;
    }
    
    // 转向右子树
    current = current.right;
  }
  
  return -1;
}
```

## 复杂度分析

- **时间复杂度**：O(H + k)，其中 H 是树的高度。我们需要先花费 O(H) 的时间到达最左下的节点，然后遍历 k 个节点。平均情况下 H = log N，最坏情况下 H = N。
- **空间复杂度**：O(H)，栈中最多存储 H 个节点（树的高度）。
