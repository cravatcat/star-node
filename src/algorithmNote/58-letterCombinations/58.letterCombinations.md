# 17. 电话号码的字母组合

## 题目描述

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

- 2: abc
- 3: def
- 4: ghi
- 5: jkl
- 6: mno
- 7: pqrs
- 8: tuv
- 9: wxyz

## 实现思路

这也是一个 **回溯** 问题。

我们需要遍历输入数字字符串 `digits`，对于每个数字，我们可以在其对应的字母中选择一个。

**回溯算法框架**：
1. `index`：当前处理到 `digits` 的第几个数字。
2. `path`：当前已经组成的字母串。
3. **结束条件**：当 `index === digits.length` 时，说明已经处理完所有数字，生成了一个完整的组合。

**具体步骤**：
1. 建立数字到字母的映射表 `map`。
2. 定义 `backtrack(index)`。
3. 取出当前数字 `digits[index]` 对应的所有字母 `letters`。
4. 遍历 `letters`：
   - 做选择：`path.push(letter)`。
   - 递归：`backtrack(index + 1)`。
   - 撤销选择：`path.pop()`。

## 代码实现

```typescript
export function letterCombinations(digits: string): string[] {
  if (digits.length === 0) {
    return [];
  }

  const map: { [key: string]: string } = {
    '2': 'abc',
    '3': 'def',
    '4': 'ghi',
    '5': 'jkl',
    '6': 'mno',
    '7': 'pqrs',
    '8': 'tuv',
    '9': 'wxyz'
  };

  const res: string[] = [];
  const path: string[] = [];

  function backtrack(index: number) {
    // 结束条件：处理完了所有数字
    if (index === digits.length) {
      res.push(path.join(''));
      return;
    }

    const digit = digits[index];
    const letters = map[digit];

    for (const letter of letters) {
      // 做选择
      path.push(letter);
      // 递归下一层
      backtrack(index + 1);
      // 撤销选择
      path.pop();
    }
  }

  backtrack(0);
  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(3^M * 4^N)，其中 M 是对应 3 个字母的数字个数（2, 3, 4, 5, 6, 8），N 是对应 4 个字母的数字个数（7, 9）。
- **空间复杂度**：O(M + N)，递归栈的深度为数字的个数。
