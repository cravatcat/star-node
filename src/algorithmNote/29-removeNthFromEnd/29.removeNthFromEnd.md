# 删除链表的倒数第 N 个结点 (Remove Nth Node From End of List)

## 1. 题目描述

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1:**

![remove_ex1](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

> **输入:** head = [1,2,3,4,5], n = 2  
> **输出:** [1,2,3,5]

**示例 2:**

> **输入:** head = [1], n = 1  
> **输出:** []

**示例 3:**

> **输入:** head = [1,2], n = 1  
> **输出:** [1]

## 2. 实现思路

最容易想到的方法是先遍历一遍链表得到长度 `L`，然后再次遍历到第 `L-n` 个节点进行删除。这需要两次遍历。

更优的方法是 **双指针法 (快慢指针)**，只需要一次遍历。

**核心思想：**
1.  我们想让 `slow` 指针指向 **倒数第 `n + 1` 个节点**（即待删除节点的前一个节点）。
2.  如果让 `fast` 指针先走 `n + 1` 步，然后 `slow` 和 `fast` 同时移动。
3.  当 `fast` 走到链表末尾（`null`）时，`slow` 正好走了 `L - (n + 1)` 步。
4.  此时 `slow` 所在的位置就是倒数第 `n + 1` 个节点。

为了方便处理 **删除头节点** 的特殊情况（例如链表只有 1 个节点，删除倒数第 1 个），我们通常会创建一个 **哑节点 (dummy node)** 指向 `head`。让 `slow` 和 `fast` 最初都指向 `dummy`。

## 3. 详细步骤

1.  创建一个 `dummy` 节点，`dummy.next = head`。
2.  初始化 `fast` 和 `slow` 都指向 `dummy`。
3.  让 `fast` 先向前移动 `n + 1` 步。
4.  当 `fast` 不为 `null` 时，循环移动：
    *   `fast` 向前移动一步。
    *   `slow` 向前移动一步。
5.  此时 `slow` 指向待删除节点的前驱节点。
6.  执行删除操作：`slow.next = slow.next.next`。
7.  返回 `dummy.next`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
    const dummy = new ListNode(0, head);
    let fast: ListNode | null = dummy;
    let slow: ListNode | null = dummy;

    // 1. 让 fast 指针先移动 n + 1 步
    for (let i = 0; i <= n; i++) {
        fast = fast!.next;
    }

    // 2. 同时移动 fast 和 slow，直到 fast 到达末尾
    while (fast !== null) {
        fast = fast.next;
        slow = slow!.next;
    }

    // 3. 删除倒数第 n 个节点
    // 此时 slow 指向倒数第 n+1 个节点
    if (slow !== null && slow.next !== null) {
        slow.next = slow.next.next;
    }

    return dummy.next;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。其中 $n$ 是链表的长度。我们只需要遍历链表一次。
*   **空间复杂度**: $O(1)$。我们只使用了常数个指针变量。
