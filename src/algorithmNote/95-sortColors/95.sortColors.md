# 95. 颜色分类

## 题目描述

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、`1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

## 实现思路

这道题是经典的 **荷兰国旗问题**。

我们可以使用三个指针：
- `p0`：指向 0 的区域的右边界（即下一个 0 应该存放的位置）。
- `p2`：指向 2 的区域的左边界（即下一个 2 应该存放的位置）。
- `curr`：当前遍历的元素指针。

算法流程：
1. 初始化 `p0 = 0`, `p2 = n - 1`, `curr = 0`。
2. 当 `curr <= p2` 时：
   - 如果 `nums[curr] === 0`：说明是红色，应该放到前面。交换 `nums[curr]` 和 `nums[p0]`，然后 `p0` 和 `curr` 都向右移动（`p0++`, `curr++`）。
   - 如果 `nums[curr] === 2`：说明是蓝色，应该放到后面。交换 `nums[curr]` 和 `nums[p2]`，然后 `p2` 向左移动（`p2--`）。注意此时 `curr` **不移动**，因为交换回来的新元素还需要再次判断。
   - 如果 `nums[curr] === 1`：说明是白色，位置正确，直接 `curr++`。

## 代码实现

```typescript
/**
 Do not return anything, modify nums in-place instead.
 */
export function sortColors(nums: number[]): void {
  let p0 = 0; // 指向 0 的右边界
  let p2 = nums.length - 1; // 指向 2 的左边界
  let curr = 0; // 当前遍历指针

  while (curr <= p2) {
    if (nums[curr] === 0) {
      [nums[curr], nums[p0]] = [nums[p0], nums[curr]];
      p0++;
      curr++;
    } else if (nums[curr] === 2) {
      [nums[curr], nums[p2]] = [nums[p2], nums[curr]];
      p2--;
      // 这里 curr 不自增，因为交换回来的元素还需要判断
    } else {
      curr++;
    }
  }
}
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。只需要遍历一次数组。
- **空间复杂度**：O(1)，原地排序，只需要常数空间。
