# 轮转数组 (Rotate Array)

## 1. 题目描述

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

> **输入:** nums = [1,2,3,4,5,6,7], k = 3  
> **输出:** [5,6,7,1,2,3,4]  
> **解释:**  
> 向右轮转 1 步: [7,1,2,3,4,5,6]  
> 向右轮转 2 步: [6,7,1,2,3,4,5]  
> 向右轮转 3 步: [5,6,7,1,2,3,4]

**示例 2:**

> **输入:** nums = [-1,-100,3,99], k = 2  
> **输出:** [3,99,-1,-100]  
> **解释:**  
> 向右轮转 1 步: [99,-1,-100,3]  
> 向右轮转 2 步: [3,99,-1,-100]

## 2. 实现思路

解决这个问题有多种方法，例如使用额外的数组、环状替换等。其中，**数组翻转 (Array Reversal)** 方法在空间复杂度上最优 ($O(1)$)，且逻辑清晰易懂。

核心思想是：
1.  首先对整个数组进行翻转，这样尾部的 `k` 个元素就会移动到头部，但它们的内部顺序是反的。
2.  然后分别对前 `k` 个元素（现在的头部）和后 `n-k` 个元素（现在的尾部）进行翻转，恢复它们内部的正确顺序。

举例：`nums = [1, 2, 3, 4, 5, 6, 7]`, `k = 3`

1.  **翻转整个数组**: `[7, 6, 5, 4, 3, 2, 1]`
2.  **翻转前 k=3 个元素** (`[7, 6, 5]` -> `[5, 6, 7]`): `[5, 6, 7, 4, 3, 2, 1]`
3.  **翻转剩余 n-k=4 个元素** (`[4, 3, 2, 1]` -> `[1, 2, 3, 4]`): `[5, 6, 7, 1, 2, 3, 4]`

结果即为所求。

注意：`k` 可能会大于数组长度 `n`，所以实际移动的步数应该是 `k % n`。

## 3. 详细步骤

1.  获取数组长度 `n`。
2.  令 `k = k % n`，处理 `k` 大于 `n` 的情况。
3.  定义一个辅助函数 `reverse(start, end)`，用于翻转数组 `nums` 在区间 `[start, end]` 内的元素。
4.  调用 `reverse(0, n - 1)`，翻转整个数组。
5.  调用 `reverse(0, k - 1)`，翻转前 `k` 个元素。
6.  调用 `reverse(k, n - 1)`，翻转剩余的 `n - k` 个元素。

## 4. 代码实现 (TypeScript)

```typescript
/**
 Do not return anything, modify nums in-place instead.
 */
function rotate(nums: number[], k: number): void {
  const n = nums.length;
  k %= n; // 处理 k > n 的情况

  // 定义一个翻转辅助函数
  const reverse = (start: number, end: number) => {
    while (start < end) {
      [nums[start], nums[end]] = [nums[end], nums[start]];
      start++;
      end--;
    }
  };

  // 1. 翻转整个数组
  reverse(0, n - 1);
  // 2. 翻转前 k 个元素
  reverse(0, k - 1);
  // 3. 翻转剩余 n - k 个元素
  reverse(k, n - 1);
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。其中 $n$ 为数组的长度。每个元素被翻转了两次，总共有 $2n$ 个元素被访问。
*   **空间复杂度**: $O(1)$。我们只需要常数空间来存储变量，没有使用额外的数组空间（原地修改）。
