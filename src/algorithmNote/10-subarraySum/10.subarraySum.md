# 和为 K 的子数组 (Subarray Sum Equals K)

## 1. 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 **该数组中和为 `k` 的连续子数组的个数** 。

**示例 1:**

> **输入:** nums = [1,1,1], k = 2  
> **输出:** 2  
> **解释:** [1,1] (前两个) 和 [1,1] (后两个)

**示例 2:**

> **输入:** nums = [1,2,3], k = 3  
> **输出:** 2  
> **解释:** [1,2] 和 [3]

## 2. 实现思路

如果使用暴力解法（双重循环），时间复杂度为 $O(n^2)$，可能会超时。我们可以利用 **前缀和 + 哈希表** 将时间复杂度优化到 $O(n)$。

**核心思想**：
子数组 `nums[i...j]` 的和可以表示为 `preSum[j] - preSum[i-1]`。
如果我们要找和为 `k` 的子数组，实际上就是在找是否存在 `preSum[j] - preSum[i-1] == k`。
移项得：`preSum[i-1] == preSum[j] - k`。

这意味着，当我们遍历到位置 `j` 时，只需要查找 **之前** 是否出现过前缀和为 `preSum[j] - k`。如果出现过，出现的次数就是以 `j` 结尾的、和为 `k` 的子数组个数。

我们使用一个哈希表 `map` 来存储：
*   **键 (Key)**: 前缀和的值。
*   **值 (Value)**: 该前缀和出现的次数。

## 3. 详细步骤

1.  初始化一个哈希表 `map`，并预置 `{0: 1}`。
    *   这是为了处理子数组从下标 0 开始的情况（即 `preSum[j] - 0 = k`）。
2.  初始化变量 `count = 0` 用于统计结果，`preSum = 0` 用于计算当前前缀和。
3.  遍历数组 `nums` 中的每个元素 `num`：
    *   计算当前前缀和：`preSum += num`。
    *   检查 `map` 中是否存在键 `preSum - k`：
        *   如果存在，说明之前有若干个位置的前缀和满足条件，将 `map.get(preSum - k)` 累加到 `count` 中。
    *   更新 `map`：将当前 `preSum` 的计数加 1。
4.  返回 `count`。

## 4. 代码实现 (TypeScript)

```typescript
function subarraySum(nums: number[], k: number): number {
    const map = new Map<number, number>();
    // 初始化 map，前缀和为 0 的情况出现 1 次
    // 这是为了处理从数组开头开始的子数组和为 k 的情况
    map.set(0, 1);

    let count = 0;
    let preSum = 0;

    for (const num of nums) {
        preSum += num;
        
        // 如果存在一个前缀和 preSum - k，说明中间有一段子数组和为 k
        // preSum[j] - preSum[i] = k  =>  preSum[i] = preSum[j] - k
        if (map.has(preSum - k)) {
            count += map.get(preSum - k)!;
        }

        // 记录当前前缀和出现的次数
        map.set(preSum, (map.get(preSum) || 0) + 1);
    }

    return count;
};
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。
    *   我们只遍历了一次数组。
    *   哈希表的查找和插入操作平均是 $O(1)$ 的。
*   **空间复杂度**: $O(n)$。
    *   最坏情况下，所有前缀和都不同，哈希表需要存储 $n$ 个键值对。
