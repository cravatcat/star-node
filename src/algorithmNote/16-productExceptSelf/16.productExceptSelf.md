# 除自身以外数组的乘积 (Product of Array Except Self)

## 1. 题目描述

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法**，且在 $O(n)$ 时间复杂度内完成此题。

**示例 1:**

> **输入:** nums = [1,2,3,4]  
> **输出:** [24,12,8,6]

**示例 2:**

> **输入:** nums = [-1,1,0,-3,3]  
> **输出:** [0,0,9,0,0]

**进阶：**你可以在 $O(1)$ 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

## 2. 实现思路

题目要求不能使用除法，且时间复杂度为 $O(n)$。

如果不考虑空间复杂度优化，我们可以构造两个数组：
1.  `L[i]` 表示索引 `i` 左侧所有元素的乘积。
2.  `R[i]` 表示索引 `i` 右侧所有元素的乘积。
3.  最终结果 `answer[i] = L[i] * R[i]`。

为了满足 **进阶** 要求（$O(1)$ 额外空间），我们可以直接用输出数组 `answer` 来存储 `L` 数组的结果。对于 `R` 数组，我们其实不需要把所有右侧乘积都存下来，只需要在从右向左遍历时，动态维护一个变量 `R` 来记录当前位置右侧的乘积即可。

## 3. 详细步骤

1.  初始化数组 `answer`，长度与 `nums` 相同。
2.  **第一轮遍历（从左到右）**：
    *   `answer[0] = 1`（第一个元素左边没有数字，视为 1）。
    *   对于 `i > 0`，`answer[i] = nums[i-1] * answer[i-1]`。此时 `answer[i]` 存储的是 `i` 左侧所有元素的乘积。
3.  **第二轮遍历（从右到左）**：
    *   初始化变量 `R = 1`（表示右侧元素的乘积）。
    *   从 `i = n - 1` 倒序遍历到 `0`：
        *   `answer[i] = answer[i] * R`（此时 `answer[i]` 既包含了左边的乘积，又乘上了右边的乘积 `R`，即为最终结果）。
        *   更新 `R = R * nums[i]`，为计算下一个位置（更左边的位置）做准备。
4.  返回 `answer`。

## 4. 代码实现 (TypeScript)

```typescript
function productExceptSelf(nums: number[]): number[] {
  const n = nums.length;
  const answer = new Array(n);

  // answer[i] 表示索引 i 左侧所有元素的乘积
  // 因为索引 0 左侧没有元素，所以 answer[0] = 1
  answer[0] = 1;
  for (let i = 1; i < n; i++) {
    answer[i] = nums[i - 1] * answer[i - 1];
  }

  // R 为右侧所有元素的乘积
  // 刚开始右边没有元素，所以 R = 1
  let R = 1;
  for (let i = n - 1; i >= 0; i--) {
    // 对于索引 i，左边的乘积是 answer[i]，右边的乘积是 R
    answer[i] = answer[i] * R;
    // 更新 R，需要乘上当前元素 nums[i]
    R *= nums[i];
  }

  return answer;
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(n)$。其中 $n$ 为数组的长度。我们需要进行两次遍历。
*   **空间复杂度**: $O(1)$。题目说明输出数组不计入空间复杂度，我们只使用了常数个变量作为辅助空间。
