# 74. 前 K 个高频元素

## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```text
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```text
输入: nums = [1], k = 1
输出: [1]
```

## 实现思路

1. **统计频率**：首先使用哈希表（Map）统计每个元素出现的次数。
2. **排序**：
   - 方法一：直接对哈希表的 entries 进行排序，时间复杂度 O(N log N)。
   - 方法二：使用 **最小堆**（Priority Queue）维护前 k 个高频元素，时间复杂度 O(N log k)。
   - 方法三：使用 **桶排序**（Bucket Sort），将频率作为数组下标，时间复杂度 O(N)。

考虑到题目通常要求优于 O(N log N) 的算法，但在 JS 中实现堆比较繁琐，这里我们可以先提供一个基于排序的简单实现，或者基于桶排序的 O(N) 实现。

为了演示更优的算法，我们这里采用 **桶排序** 的思想（或者直接排序 entries，在数据量不大时差别不明显）。

下面的代码实现使用了直接排序 entries 的方法，简单直观。如果需要极致性能，可以使用桶排序。

## 代码实现

```typescript
export function topKFrequent(nums: number[], k: number): number[] {
  const map = new Map<number, number>();
  for (const num of nums) {
    map.set(num, (map.get(num) || 0) + 1);
  }

  // 将 map 转换为数组，元素为 [num, count]
  const entries = Array.from(map.entries());

  // 按频率降序排序
  entries.sort((a, b) => b[1] - a[1]);

  const res: number[] = [];
  for (let i = 0; i < k; i++) {
    res.push(entries[i][0]);
  }

  return res;
}
```

## 复杂度分析

- **时间复杂度**：O(N log N)，其中 N 是数组的长度。主要消耗在排序上。如果使用最小堆可以优化到 O(N log k)，使用桶排序可以优化到 O(N)。
- **空间复杂度**：O(N)，用于存储哈希表。
