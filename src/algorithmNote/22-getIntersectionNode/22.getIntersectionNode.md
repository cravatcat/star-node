# 相交链表 (Intersection of Two Linked Lists)

## 1. 题目描述

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示如下：

```
A:       a1 -> a2
                 \
                  c1 -> c2 -> c3
                 /
B: b1 -> b2 -> b3
```

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**示例 1:**

> **输入:** intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3  
> **输出:** Intersected at '8'  
> **解释:** 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

## 2. 实现思路

这道题最巧妙的解法是 **双指针法**。

假设链表 A 的非公共部分长度为 `a`，链表 B 的非公共部分长度为 `b`，公共部分长度为 `c`。

* 链表 A 的总长度：`a + c`
* 链表 B 的总长度：`b + c`

如果我们让两个指针 `pA` 和 `pB` 分别从 `headA` 和 `headB` 出发：

1. `pA` 走完链表 A 后，接着走链表 B。
2. `pB` 走完链表 B 后，接着走链表 A。

那么，当它们相遇时，它们走过的总路程是相同的：

* `pA` 走的路径：`A -> B`，长度为 `(a + c) + b`
* `pB` 走的路径：`B -> A`，长度为 `(b + c) + a`

显然 `a + c + b = b + c + a`。

**为什么会相遇在交点？**

因为 `a + c + b` 的最后一段必然是公共部分 `c`。当两个指针走了相同的总长度 `a + b + c` 时，它们必然同时到达公共部分的起点（即相交节点）。

如果两个链表不相交，那么 `c = 0`。

* `pA` 走过 `a + b`
* `pB` 走过 `b + a`
* 它们最终会同时指向 `null`，退出循环，返回 `null`。

## 3. 详细步骤

1. 判断边界条件：如果 `headA` 或 `headB` 为空，直接返回 `null`。
2. 初始化两个指针 `pA` 指向 `headA`，`pB` 指向 `headB`。
3. 开始循环，条件是 `pA !== pB`：
    * 如果 `pA` 为空，则将 `pA` 重置为 `headB`；否则 `pA` 移向下一个节点。
    * 如果 `pB` 为空，则将 `pB` 重置为 `headA`；否则 `pB` 移向下一个节点。
4. 当循环结束时，`pA` 和 `pB` 指向同一个节点（相交节点）或者都为 `null`（不相交）。
5. 返回 `pA`。

## 4. 代码实现 (TypeScript)

```typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

export function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
    if (!headA || !headB) return null;

    let pA: ListNode | null = headA;
    let pB: ListNode | null = headB;

    while (pA !== pB) {
        // pA 走完 A 链表后，转到 B 链表
        pA = pA === null ? headB : pA.next;
        // pB 走完 B 链表后，转到 A 链表
        pB = pB === null ? headA : pB.next;
    }

    return pA;
}
```

## 5. 复杂度分析

* **时间复杂度**: $O(m + n)$。其中 $m$ 和 $n$ 分别是两个链表的长度。最坏情况下，两个指针各遍历两个链表一次。
* **空间复杂度**: $O(1)$。我们只需要两个指针变量，不需要额外的存储空间。
