# 字母异位词分组 (Group Anagrams)

## 1. 题目描述

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是指由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

**示例:**

> **输入:** strs = ["eat", "tea", "tan", "ate", "nat", "bat"]  
> **输出:** [["bat"],["nat","tan"],["ate","eat","tea"]]

## 2. 实现思路

两个字符串如果是字母异位词，那么它们包含的字母种类和每个字母出现的次数一定是相同的。

基于这个特性，我们可以找到一种 **“标准形式”** 来代表这一组词。最简单的方法是将字符串中的字符进行 **排序**。

例如：`"eat"`, `"tea"`, `"ate"` 经过排序后都变成了 `"aet"`。

我们可以利用一个 **哈希表 (Map)**：
*   **键 (Key)**: 排序后的字符串（标准形式）。
*   **值 (Value)**: 一个列表，包含所有排序后等于该 Key 的原始字符串。

## 3. 详细步骤

1.  初始化一个空的哈希表 `map`。
2.  遍历输入数组 `strs` 中的每一个字符串 `str`：
    *   将 `str` 转换为字符数组，进行排序，然后再合并为字符串，得到 `sorted`。
    *   检查 `map` 中是否存在键 `sorted`。
    *   如果不存在，则在 `map` 中创建一个新的空数组 `[]` 作为值。
    *   将原始字符串 `str` 添加到 `map` 中对应键的数组中。
3.  遍历完成后，将 `map` 中的所有值（Values）转换为数组并返回。

## 4. 代码实现 (TypeScript)

```typescript
function groupAnagrams(strs: string[]): string[][] {
  const map = new Map();
  for (const str of strs) {
    // 将字符串拆分为字符数组 -> 排序 -> 重新组合成字符串
    const sorted = str.split('').sort().join('');
    
    // 如果 Map 中还没有这个 key，初始化一个空数组
    if (!map.has(sorted)) {
      map.set(sorted, []);
    }
    
    // 将原始字符串加入对应的分组
    map.get(sorted).push(str);
  }
  
  // 返回 Map 中所有的分组
  return Array.from(map.values());
};
```

## 5. 复杂度分析

假设数组中字符串的数量为 $N$，字符串的最大长度为 $K$。

*   **时间复杂度**: $O(N \cdot K \log K)$。
    *   我们需要遍历 $N$ 个字符串。
    *   对于每个字符串，排序需要 $O(K \log K)$ 的时间。
    *   总时间复杂度为 $O(N \cdot K \log K)$。
*   **空间复杂度**: $O(N \cdot K)$。
    *   需要用哈希表存储全部字符串。在最坏情况下（所有字符串都不互为异位词），我们需要存储 $N$ 个键和 $N$ 个值，总字符数为 $N \cdot K$。
