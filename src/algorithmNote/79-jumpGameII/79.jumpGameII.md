# 79. 跳跃游戏 II

## 题目描述

给定一个长度为 `n` 的 0 索引整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例 1:**

```text
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```text
输入: nums = [2,3,0,1,4]
输出: 2
```

## 实现思路

这也是一个贪心算法问题。我们需要维护两个变量：
1. `currentEnd`：当前跳跃步数能到达的最远边界。
2. `farthest`：在当前范围内，下一步能跳到的最远位置。

遍历数组（除了最后一个元素，因为我们要在到达最后一个元素之前计算步数）：
1. 更新 `farthest = max(farthest, i + nums[i])`。
2. 如果遍历到了 `currentEnd`，说明必须进行一次跳跃了，步数 `jumps` 加 1，并更新 `currentEnd = farthest`。

## 代码实现

```typescript
export function jump(nums: number[]): number {
  let jumps = 0;
  let currentEnd = 0;
  let farthest = 0;

  // 注意这里遍历到 nums.length - 2 即可
  // 因为当我们到达 nums.length - 1 时，不需要再跳了
  for (let i = 0; i < nums.length - 1; i++) {
    farthest = Math.max(farthest, i + nums[i]);
    if (i === currentEnd) {
      jumps++;
      currentEnd = farthest;
    }
  }
  return jumps;
}
```

## 复杂度分析

- **时间复杂度**：O(n)，只需要遍历一次数组。
- **空间复杂度**：O(1)，只需要常数个变量。
