# 85. 单词拆分

## 题目描述

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```text
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```text
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

## 实现思路

这也是一个动态规划问题。

定义 `dp[i]` 表示字符串 `s` 的前 `i` 个字符（即 `s[0...i-1]`）是否可以被拆分为字典中的单词。

状态转移方程：
`dp[i] = true` 当且仅当存在一个 `j` (0 <= j < i)，使得 `dp[j]` 为 `true` 且 `s[j...i-1]`（即从索引 `j` 到 `i-1` 的子串）存在于字典中。

初始条件：
- `dp[0] = true`，空字符串可以被拆分。

我们使用一个 Set 来存储字典，以便 O(1) 时间查找单词。

## 代码实现

```typescript
export function wordBreak(s: string, wordDict: string[]): boolean {
  const wordSet = new Set(wordDict);
  const n = s.length;
  // dp[i] 表示字符串 s 的前 i 个字符 s[0...i-1] 是否可以被拆分
  const dp = new Array(n + 1).fill(false);
  dp[0] = true; // 空字符串可以被拆分

  for (let i = 1; i <= n; i++) {
    for (let j = 0; j < i; j++) {
      // 如果 s[0...j-1] 可以被拆分，且 s[j...i-1] 在字典中
      if (dp[j] && wordSet.has(s.substring(j, i))) {
        dp[i] = true;
        break; // 只要找到一种拆分方式即可
      }
    }
  }

  return dp[n];
}
```

## 复杂度分析

- **时间复杂度**：O(n^2)，其中 n 是字符串的长度。外层循环遍历 i，内层循环遍历 j，字符串截取和哈希查找的时间复杂度通常视为 O(1)（平均）或 O(L)（L 为单词平均长度）。
- **空间复杂度**：O(n)，需要一个长度为 `n + 1` 的 `dp` 数组。
