# 5.3 useInsertionEffect 💡

`useInsertionEffect` 是 React 18 引入的一个专门用于 CSS-in-JS 库的 Hook。它的执行时机非常特殊，旨在解决并发渲染模式下 CSS 注入的性能问题。

## 1. 原理讲解

### 核心概念

在 React 18 的并发模式下，如果我们在渲染过程中（render phase）或副作用执行时（commit phase）动态注入 CSS，可能会导致浏览器在每一帧中多次重新计算样式，这被称为 "Runtime CSS Injection" 的性能瓶颈。

`useInsertionEffect` 的设计初衷就是为了在 **DOM 变更之前** 注入样式。

- **执行时机**：在 DOM 变更（Mutation）之前同步执行。
- **目的**：确保在 `useLayoutEffect` 读取布局信息之前，样式标签（`<style>`）已经被插入到 DOM 中。
- **限制**：不能访问 refs（因为 DOM 还没更新），也不能调度更新（setState）。

### 模拟实现

虽然我们无法完全模拟 React 内部的微任务调度和 DOM 提交阶段的精确时机，但我们可以通过理解其执行顺序来模拟其行为：它比 `useLayoutEffect` 更早执行。

```javascript
// 模拟实现：useInsertionEffect
// 注意：这只是为了演示执行顺序，真实实现依赖于 React 内部的 Fiber 协调过程

function useInsertionEffect(effect, deps) {
  // 在 React 源码中，useInsertionEffect 的 effect 会在
  // "commitMutationEffects" 阶段之前执行
  // 而 useLayoutEffect 会在 "commitLayoutEffects" 阶段执行
  
  // 这里我们无法在用户态代码中精确模拟 "DOM 变更前"，
  // 但可以理解为它是一个优先级最高的同步副作用
  
  const isFirstMount = useRef(true);
  const oldDeps = useRef(deps);

  if (isFirstMount.current || !depsAreSame(oldDeps.current, deps)) {
    // 真实场景下，这里会立即执行，并且是在 DOM 真正更新之前
    effect();
    
    isFirstMount.current = false;
    oldDeps.current = deps;
  }
}
```

## 2. 执行顺序对比

为了更直观地理解，我们可以看下三个 Effect Hook 的执行流：

1. **Render Phase**: 组件函数执行，构建 Virtual DOM。
2. **Commit Phase (Start)**: 准备提交 DOM 变更。
3. **`useInsertionEffect`**: **👉 在这里执行**。此时可以插入 `<style>` 标签。
4. **DOM Mutation**: React 更新真实的 DOM 节点。
5. **`useLayoutEffect`**: DOM 更新后同步执行。此时可以安全地读取布局（layout）。
6. **Paint**: 浏览器绘制屏幕。
7. **`useEffect`**: 绘制完成后异步执行。

```javascript
import { useEffect, useLayoutEffect, useInsertionEffect } from 'react';

function App() {
  useInsertionEffect(() => {
    console.log('1. useInsertionEffect - 注入样式');
  });

  useLayoutEffect(() => {
    console.log('2. useLayoutEffect - 读取布局');
  });

  useEffect(() => {
    console.log('3. useEffect - 异步副作用');
  });

  return <div>Hello</div>;
}
```

## 3. 使用场景

**普通开发者几乎不需要使用这个 Hook。** 它主要是为了 CSS-in-JS 库（如 styled-components, Emotion）的作者准备的。

### 场景：动态 CSS 注入

在 CSS-in-JS 库中，我们经常需要根据组件的 props 动态生成 CSS 类名并插入到 `<style>` 标签中。

如果不使用 `useInsertionEffect`：
-如果在 `useLayoutEffect` 中插入样式：浏览器必须先计算一次旧样式的布局，然后 React 更新 DOM，接着 `useLayoutEffect` 插入新样式，浏览器又要重新计算新样式的布局。这会导致布局抖动（Layout Thrashing）。

使用 `useInsertionEffect`：

- 在 DOM 更新前就把样式插好了。当 React 更新 DOM 时，浏览器只需要计算一次布局。

```javascript
// 伪代码：CSS-in-JS 库内部实现
function useCSS(rule) {
  useInsertionEffect(() => {
    if (!isRuleInserted(rule)) {
      insertRuleIntoStyleTag(rule);
    }
  });
  return className;
}
```

## 4. 常见问题

### Q: 为什么不能在 `useInsertionEffect` 中使用 refs？

**A:** 因为 `useInsertionEffect` 执行的时候，DOM 还没有更新。refs.current 可能还是旧的 DOM 节点，或者如果是初次挂载，它是 null。

### Q: 它和 `useLayoutEffect` 的主要区别是什么？

**A:**

- `useInsertionEffect`: DOM 更新 **前** 执行。用于注入样式。无法访问最新 DOM。
- `useLayoutEffect`: DOM 更新 **后** 执行。用于读取布局。可以访问最新 DOM。

### Q: 我应该用它来做数据获取吗？

**A:** 绝对不要。数据获取应该在 `useEffect` 中进行，或者使用支持 Suspense 的数据获取库。`useInsertionEffect` 应该尽量保持轻量，只做样式注入相关的工作。
