# 4.4 useContext 深度解析

`useContext` 是 React 中用于解决组件树间数据共享（跨层级通信）的核心 Hook。它配合 `Context.Provider` 使用，能够避免繁琐的 "Props Drilling"（属性透传）问题。

## 1. Context 原理

### 1.1 核心概念

* **Provider (生产者)**：在组件树的上层提供数据。
* **Consumer / useContext (消费者)**：在组件树的任意下层订阅并读取数据。
* **传播机制**：当 Provider 的 `value` 发生变化时，所有订阅了该 Context 的组件都会强制重新渲染，**无论它们的父组件是否更新**（跳过 `React.memo`）。

### 1.2 模拟实现：createContext + useContext

我们可以利用闭包和订阅发布模式来模拟一个简单的 Context 系统。

```javascript
// 模拟 React 内部的 Context 栈（真实 React 在 Fiber 节点上维护）
const contextStack = []; 

function createContext(defaultValue) {
  const context = {
    _id: Symbol('Context'), // 唯一标识
    _defaultValue: defaultValue,
    Provider: ({ value, children }) => {
      // 1. 入栈 (Push)：记录当前 Provider 的值
      // 真实 React 会在 beginWork 阶段入栈
      contextStack.push({ contextId: context._id, value });
      
      // 2. 渲染子组件
      // ... 子组件渲染过程中调用 useContext ...
      
      // 3. 出栈 (Pop)：(伪代码) 渲染完成后清理
      // 真实 React 会在 completeWork 阶段出栈
      // contextStack.pop(); 
      
      return children;
    }
  };
  return context;
}

function useContext(context) {
  // 1. 查找：从栈顶向下遍历，找到最近的匹配 Provider
  for (let i = contextStack.length - 1; i >= 0; i--) {
    if (contextStack[i].contextId === context._id) {
      return contextStack[i].value;
    }
  }
  // 2. 兜底：未找到 Provider，返回默认值
  return context._defaultValue;
}
```

*注：真实的 React 实现要复杂得多，涉及 Fiber 树的遍历、依赖收集（Dependencies List）以及在 `value` 变化时精确找到并标记所有消费者组件进行更新。*

---

## 2. Context 性能优化 🌟

这是 Context 最容易被误用和导致性能问题的地方。

### 2.1 问题根源

当 Provider 的 `value` 变化时，**所有**使用 `useContext` 的组件都会重新渲染。如果 `value` 是一个对象，且每次父组件渲染时都生成一个新的对象引用，那么即使对象内部属性没变，也会触发消费者重渲染。

```javascript
// ❌ 糟糕的写法
function App() {
  // 每次 App 重渲染，value 都是一个新对象
  return (
    <ThemeContext.Provider value={{ color: 'red', toggle }}>
      <Child />
    </ThemeContext.Provider>
  );
}
```

### 2.2 优化策略

#### 策略一：使用 useMemo 缓存 Value

确保只有在真正需要更新时，`value` 的引用才发生变化。

```javascript
// ✅ 推荐写法
function App() {
  const [color, setColor] = useState('red');
  
  const value = useMemo(() => ({
    color,
    toggle: () => setColor(c => c === 'red' ? 'blue' : 'red')
  }), [color]); // 只有 color 变了，value 引用才变

  return (
    <ThemeContext.Provider value={value}>
      <Child />
    </ThemeContext.Provider>
  );
}
```

#### 策略二：拆分 Context (Split Context)

将多变的数据和不变的数据（或变化频率不同的数据）拆分到不同的 Context 中。

**场景**：一个 Context 同时包含 `user` 信息（很少变）和 `theme` 信息（经常变）。

**优化前**：

```javascript
<AppContext.Provider value={{ user, theme }}>
```

`theme` 变化会导致只关心 `user` 的组件也重渲染。

**优化后**：

```javascript
<UserContext.Provider value={user}>
  <ThemeContext.Provider value={theme}>
    <Content />
  </ThemeContext.Provider>
</UserContext.Provider>
```

#### 策略三：配合 React.memo

`useContext` 有一个特性：**它会穿透 `React.memo`**。这意味着，即使组件被 `React.memo` 包裹，只要 Context Value 变了，组件依然会强制重渲染。

**那为什么还需要 React.memo 呢？**

是为了防止**父组件**的渲染带动子组件渲染。

**场景**：`App` 组件里有 `count`（经常变）和 `ThemeContext`（很少变）。

```javascript
// 子组件：只关心 ThemeContext
const Child = React.memo(() => {
  console.log("Child render");
  const theme = useContext(ThemeContext);
  return <div style={{ color: theme.color }}>I am Child</div>;
});

function App() {
  const [count, setCount] = useState(0);
  const [theme, setTheme] = useState({ color: 'red' });

  return (
    <ThemeContext.Provider value={theme}>
      {/* 1. 点击按钮修改 count，App 重渲染 */}
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      
      {/* 2. Child 被 memo 包裹，且 props 没变，所以 Child 不会重渲染 */}
      <Child /> 
      
      {/* 3. 如果修改 setTheme，Context 变了，Child 会穿透 memo 强制重渲染 */}
      <button onClick={() => setTheme({ color: 'blue' })}>Change Theme</button>
    </ThemeContext.Provider>
  );
}
```

**总结**：

1. **阻断父组件引起的渲染**：`App` 更新 `count` -> `Child` 也就是 props 没变 -> `React.memo` 拦截 -> **不渲染**（优化点）。
2. **响应 Context 变化**：`App` 更新 `theme` -> `Child` 内部 `useContext` 收到通知 -> **强制渲染**（正确行为）。

如果不加 `React.memo`，每次 `count` 变化，`Child` 都会跟着傻傻地重渲染，即使它根本不关心 `count`。

---

## 3. 常见问题

### Q1: Context vs Redux / Zustand？

* **Context**：
  * **定位**：依赖注入（Dependency Injection），解决跨层级传值。
  * **缺点**：缺乏细粒度的性能优化（一旦变了全量更新），不适合高频变化的数据。
  * **适用**：主题、用户信息、多语言等低频更新的全局状态。
* **Redux / Zustand**：
  * **定位**：状态管理库。
  * **优点**：支持选择器（Selector），只有关注的数据变了才更新；有中间件、DevTools 等生态。
  * **适用**：复杂业务逻辑、高频交互数据。

### Q2: Context 会导致 "Props Drilling" 消失吗？

是的，它就是为了解决这个问题而生的。但是滥用 Context 会导致组件复用性降低（组件依赖了特定的 Context 环境）。

### Q3: useReducer + useContext 能替代 Redux 吗？

**理论上可以，但性能有差距**。

* `useReducer` 管理复杂状态逻辑。
* `useContext` 传递 `dispatch` 和 `state`。
* **缺陷**：无法像 Redux 那样使用 `useSelector` 进行细粒度订阅。如果 Context Value 是一个大对象，任何属性变化都会导致所有消费者渲染。需要配合 `useMemo` 和拆分 Context 才能达到接近 Redux 的性能。
