# 8.2 useDeferredValue

`useDeferredValue` 是 React 18 引入的另一个并发 Hook。它允许你延迟更新某个值的“副本”，从而推迟基于该值的部分 UI 渲染。

## 1. 核心作用

`useDeferredValue` 类似于“防抖（debounce）”或“节流（throttle）”，但它更智能。
-   **防抖/节流**：基于固定的时间间隔（如 300ms）。
-   **useDeferredValue**：基于渲染能力。React 会尝试尽快更新，但如果系统繁忙（如正在处理高优先级输入），它会推迟更新这个值，且**不会阻塞主线程**。

它主要用于解决：**一个状态同时驱动“快更新”和“慢更新”** 的场景。

## 2. 语法

```javascript
const deferredValue = useDeferredValue(value);
```

*   **value**: 你想要延迟的原始值。
*   **deferredValue**: React 返回的延迟值。
    *   在初始渲染时，`deferredValue` 等于 `value`。
    *   当 `value` 更新时，React 首先使用旧的 `deferredValue` 进行重新渲染（保持 UI 响应），然后在后台使用新的 `value` 进行计算和渲染。

## 3. 使用示例

### 3.1 搜索结果延迟渲染

这就类似于 `useTransition` 的例子，但 `useDeferredValue` 是作用于**值**，而不是**设置状态的函数**。这在只能接收 props 而无法控制状态更新的子组件中非常有用。

```javascript
import React, { useState, useDeferredValue, useMemo } from 'react';

function App() {
  const [query, setQuery] = useState('');
  // 生成一个延迟版本的 query
  const deferredQuery = useDeferredValue(query);

  return (
    <div>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <SlowList query={deferredQuery} />
    </div>
  );
}

const SlowList = React.memo(({ query }) => {
  // 模拟耗时操作：仅当 deferredQuery 变化时才重新计算
  const items = useMemo(() => {
    console.log('Calculating list for:', query);
    const result = [];
    for (let i = 0; i < 10000; i++) {
      if (String(i).includes(query)) {
        result.push(i);
      }
    }
    return result;
  }, [query]);

  return (
    <ul>
      {items.map(item => <li key={item}>{item}</li>)}
    </ul>
  );
});
```

**流程解析：**
1.  用户输入 "a"。
2.  `query` 变为 "a"。App 组件重新渲染。
3.  `deferredQuery` 此时仍然是旧值（""）。
4.  `SlowList` 接收到旧的 `deferredQuery` ("")，由于 `React.memo`，它可能跳过渲染或快速渲染。
5.  React 完成高优先级的输入框更新。
6.  React 在后台开始新的渲染，此时 `deferredQuery` 变为 "a"。
7.  `SlowList` 接收到 "a"，开始昂贵的计算和渲染。如果此时用户又输入了 "b"，这个后台渲染会被中断。

## 4. useTransition vs useDeferredValue

它们的目标是一致的：**非阻塞渲染**。区别在于使用场景：

| 特性 | useTransition | useDeferredValue |
| :--- | :--- | :--- |
| **控制对象** | **状态更新函数** (`setState`) | **状态值** (props 或 state) |
| **使用位置** | 通常在**父组件**或拥有 state 的组件 | 通常在**子组件**或接收 props 的地方 |
| **能否获取 Pending 状态** | 能 (`isPending`) | 不能 (需要自己比较 `value !== deferredValue`) |

**选择指南：**
-   如果你能控制状态更新（例如调用 `setQuery`），优先使用 `useTransition`。
-   如果你只能拿到一个值（例如从 props 传下来的），或者想把延迟逻辑封装在组件内部，使用 `useDeferredValue`。

## 5. 如何判断是否处于延迟状态？

虽然 `useDeferredValue` 没有返回 `isPending`，但你可以通过比较值来判断：

```javascript
const deferredQuery = useDeferredValue(query);
const isStale = query !== deferredQuery; // true 表示正在等待后台更新

return (
  <div style={{ opacity: isStale ? 0.5 : 1 }}>
    <SlowList query={deferredQuery} />
  </div>
);
```
这种模式可以给用户一个视觉反馈（如变灰），提示内容正在更新。
