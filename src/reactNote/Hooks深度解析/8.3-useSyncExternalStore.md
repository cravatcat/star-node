# 8.3 useSyncExternalStore

`useSyncExternalStore` 是 React 18 引入的一个专门用于**订阅外部数据源**的 Hook。它主要为了解决并发渲染（Concurrent Rendering）下可能出现的“撕裂（Tearing）”问题。

## 1. 什么是“撕裂”？

在并发渲染模式下，React 可能会暂停渲染，先去处理更高优先级的任务，然后再回来继续渲染。
如果在暂停期间，**外部数据源**（如 Redux store、全局变量、DOM 状态）发生了变化，那么：
-   组件的前半部分渲染使用的是旧值。
-   组件的后半部分渲染（恢复后）使用的是新值。

这就导致了 UI 显示不一致，称为“撕裂”。`useSyncExternalStore` 通过强制 React 在更新期间同步读取外部存储来避免这个问题（实际上是一旦发现外部存储变化，就强制同步重渲染，退回到非并发模式）。

## 2. 语法

```javascript
const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?);
```

*   **subscribe**: 一个函数，接收一个 `callback`。当 store 变化时，调用 `callback` 通知 React。该函数需要返回一个取消订阅的函数。
*   **getSnapshot**: 一个函数，返回 store 的当前状态快照。React 用它来检查数据是否变化。
*   **getServerSnapshot** (可选): 用于服务端渲染（SSR）或 Hydration 阶段获取初始快照。

## 3. 使用示例

### 3.1 订阅浏览器网络状态

浏览器提供的 `navigator.onLine` 是一个外部数据源。

```javascript
import { useSyncExternalStore } from 'react';

// 1. 定义 getSnapshot
function getSnapshot() {
  return navigator.onLine;
}

// 2. 定义 subscribe
function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}

function OnlineStatus() {
  const isOnline = useSyncExternalStore(subscribe, getSnapshot);
  return <h1>{isOnline ? '在线' : '离线'}</h1>;
}
```

### 3.2 实现简易的状态管理库

这是该 Hook 最主要的使用场景：编写像 Redux、Zustand 这样的状态管理库。

```javascript
// store.js - 一个简单的外部 Store
let state = { count: 0 };
let listeners = new Set();

export const store = {
  getState() {
    return state;
  },
  dispatch(action) {
    if (action.type === 'INC') {
      state = { ...state, count: state.count + 1 };
    }
    listeners.forEach(listener => listener());
  },
  subscribe(listener) {
    listeners.add(listener);
    return () => listeners.delete(listener);
  }
};

// useStore.js - 自定义 Hook
import { useSyncExternalStore } from 'react';
import { store } from './store';

export function useStore() {
  // 直接连接外部 store
  const state = useSyncExternalStore(store.subscribe, store.getState);
  return state;
}
```

## 4. 注意事项

1.  **普通开发者很少直接用**：这个 Hook 主要是给库作者（Library Authors）用的。如果你只是开发业务应用，通常使用 `useState`、`useReducer` 或现成的库（Redux Toolkit, Zustand 等，它们内部已经使用了这个 Hook）。
2.  **快照一致性**：`getSnapshot` 返回的值必须是不可变的（Immutable）或者每次返回同一个引用（如果没变）。如果每次 `getSnapshot` 都返回一个新对象（例如 `return { val: store.val }`），会导致死循环或无限重渲染。
3.  **性能**：`useSyncExternalStore` 触发的更新是**同步**的（不可中断），因为它要保证数据一致性。这意味着它不能享受并发渲染带来的某些性能红利（如时间切片）。因此，尽量不要把所有状态都塞进外部 Store，局部状态还是用 `useState` 最好。

## 5. 对比 useEffect

在 React 18 之前，我们通常用 `useEffect` 来订阅外部源：

```javascript
// ❌ 旧写法 (React 18 并发模式下可能导致撕裂)
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  return width;
}
```

**为什么不行？**
因为 `useEffect` 是异步执行的，状态更新可能滞后于 React 的渲染流程，导致在并发渲染的间隙发生数据不一致。`useSyncExternalStore` 则是为了解决这个问题而生的标准 API。
