# 4.1 useState 深度解析

## 1. 原理讲解

`useState` 是 React Hooks 中最基础的状态管理 Hook。它的核心原理是利用**闭包**来保存状态，并使用**链表**（在 Fiber 架构中）或**数组**（在简化模型中）来维护组件的 Hook 状态序列。

### 1.1 核心概念

1. **闭包存储**：函数组件每次渲染都会重新执行，`useState` 利用闭包确保状态在多次渲染之间保持持久化。
2. **顺序依赖**：React 依赖 Hooks 调用的顺序来将 state 对应到正确的 Hook 上。这也是为什么"不能在条件语句或循环中调用 Hooks"的原因。
3. **触发更新**：`setState` 不仅更新数据，还会触发视图的重新渲染（re-render）。

### 1.2 模拟实现：极简版 useState

为了理解原理，我们可以用数组和索引来模拟一个简单的 `useState`。

```javascript
let hooks = []; // 存放所有 hooks 的状态
let currentHookIndex = 0; // 当前 hook 的索引

// 模拟的 render 函数
function render(Component) {
  currentHookIndex = 0; // 每次渲染重置索引
  const app = Component();
  app.render();
  return app;
}

function useState(initialState) {
  const index = currentHookIndex; // 锁定当前 hook 的索引
  
  // 初始化状态（仅在第一次）
  if (hooks[index] === undefined) {
    hooks[index] = typeof initialState === 'function' ? initialState() : initialState;
  }

  const setState = (newState) => {
    // 支持函数式更新
    if (typeof newState === 'function') {
      hooks[index] = newState(hooks[index]);
    } else {
      hooks[index] = newState;
    }
    // 触发重新渲染（模拟）
    render(App); 
  };

  currentHookIndex++; // 移动索引到下一个 hook
  return [hooks[index], setState];
}
```

## 2. 批量更新机制 (Batching)

你可能遇到过这样的情况：连续多次调用 `setState`，但 React 只渲染了一次。这就是**批量更新**。

### 2.1 为什么要批量更新？

为了性能。如果每次 `setState` 都立即触发布局计算和 DOM 更新，浏览器会不堪重负。

### 2.2 实现原理

React 使用一个"批处理上下文"标记（如 `isBatchingUpdates`）。

1. **事件处理函数开始**：设置 `isBatchingUpdates = true`。
2. **执行 setState**：并不立即更新，而是将更新任务推入队列。
3. **事件处理函数结束**：设置 `isBatchingUpdates = false`，并清空队列，执行一次重新渲染。

### 2.3 React 18 的自动批处理

在 React 18 之前，只有在 React 事件处理函数（如 `onClick`）中会自动批处理。在 `setTimeout`、`Promise` 或原生事件中，`setState` 会同步更新（即不批处理）。

**React 18** 引入了自动批处理（Automatic Batching），无论在哪里调用 `setState`，默认都会进行批处理。如果需要强制同步更新，可以使用 `flushSync`。

```javascript
import { flushSync } from 'react-dom';

function handleClick() {
  flushSync(() => {
    setCount(c => c + 1); // 立即更新 DOM
  });
  // 此时 DOM 已经更新
  flushSync(() => {
    setFlag(f => !f); // 立即更新 DOM
  });
}
```

## 3. 函数式更新

### 3.1 解决闭包陷阱

当 `setState` 的更新依赖于前一个 state 时，推荐使用函数式更新。

```javascript
const [count, setCount] = useState(0);

function handleDelayAdd() {
  setTimeout(() => {
    // 错误写法：count 也就是闭包中的旧值 0
    // setCount(count + 1); 
    
    // 正确写法：prev 是最新的 state
    setCount(prev => prev + 1); 
  }, 1000);
}
```

### 3.2 模拟实现中的支持

在上面的模拟实现中，我们已经加入了对函数参数的支持：

```javascript
if (typeof newState === 'function') {
  hooks[index] = newState(hooks[index]);
}
```

## 4. 常见问题

### 4.1 闭包陷阱（Capture Value）

**问题**：为什么 `setTimeout` 中的 log 输出的是旧值？
**答案**：函数组件每次渲染都是一次独立的执行，拥有自己独立的 props 和 state 作用域（闭包）。`setTimeout` 捕获的是创建该定时器那次渲染时的 state，而非最新值。
**解决**：

1. 使用函数式更新 `setState(prev => ...)`。
2. 使用 `useRef` 保存最新值，因为 ref 对象在组件生命周期内保持不变。

### 4.2 useState vs useReducer

`useState` 实际上是 `useReducer` 的语法糖/简化版。当状态逻辑复杂，或者下一个 state 依赖前一个 state 时，推荐使用 `useReducer`。

### 4.3 为什么 Hooks 不能写在条件语句里？

**答案**：React 依赖 Hooks 的**调用顺序**来对应 state。如果在条件语句中，导致某次渲染跳过了一个 Hook，后续的所有 Hook 索引都会错位，导致 state 混乱（例如把 `surname` 的 state 赋给了 `width`）。

**详细案例分析**：

假设我们有这样一个组件：

```javascript
function Form() {
  // Hook 1: name
  const [name, setName] = useState('Mary');

  // 🔴 错误：在条件语句中使用 Hook
  if (name !== '') {
    // Hook 2: effect
    useEffect(function persistForm() {
      localStorage.setItem('formData', name);
    });
  }

  // Hook 3: surname
  const [surname, setSurname] = useState('Poppins');

  // Hook 4: width
  const [width, setWidth] = useState(window.innerWidth);
}
```

#### 第一次渲染 (name = 'Mary')

此时条件 `name !== ''` 为真，所有 Hooks 依次执行。React 内部存储的状态列表如下：

| 索引 | Hook 类型 | 存储的值         | 变量名    |
| :--- | :-------- | :--------------- | :-------- |
| 0    | useState  | 'Mary'           | `name`    |
| 1    | useEffect | persistForm 函数 | (effect)  |
| 2    | useState  | 'Poppins'        | `surname` |
| 3    | useState  | 1024             | `width`   |

#### 第二次渲染 (name = '')

用户清空了输入框，`name` 变为空字符串。此时 `if (name !== '')` 条件为假，**Hook 2 被跳过**。React 尝试按顺序读取状态：

| 索引 | 代码中的 Hook        | React 内部匹配             | 结果         |
| :--- | :------------------- | :------------------------- | :----------- |
| 0    | `useState` (name)    | 索引 0: 'Mary' (更新为 '') | ✅ 正常       |
| 1    | `useState` (surname) | 索引 1: persistForm 函数   | ❌ **错位！** |
| 2    | `useState` (width)   | 索引 2: 'Poppins'          | ❌ **错位！** |

**后果**：

1. `surname` 本该拿到字符串 'Poppins'，结果拿到了上一次渲染的 `persistForm` 函数（或者 useEffect 对应的内部对象）。
2. `width` 本该拿到数字，结果拿到了字符串 'Poppins'。
3. 程序通常会直接报错，因为类型不匹配或者读取了不存在的属性。

这就是为什么 React 官方文档强调：**不要在循环，条件或嵌套函数中调用 Hook**。

### 4.4 这里是同步还是异步？

* **React 18+**：绝大多数情况是**异步**（批处理）的。
* **React 17 及以下**：在 React 事件中是异步的，在 `setTimeout`/原生事件中是同步的。
* **理解**：这里的"异步"指的是更新是延迟的、批量的，而不是 JS 语言层面的 Promise 异步。
