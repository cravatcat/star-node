# 6.2 useCallback

`useCallback` 是 React 提供的一个用于性能优化的 Hook，它返回一个**记忆化（memoized）**的回调函数。该回调函数仅在某个依赖项改变时才会更新。

## 1. 原理讲解

### 1.1 核心概念

`useCallback` 接收两个参数：

1. **callback**：需要缓存的函数。
2. **deps**：依赖数组。

它的主要作用是**保持函数引用的稳定性**。在 JavaScript 中，每次组件重新渲染时，组件内部定义的函数都会重新创建，这意味着它们在内存中是不同的引用。`useCallback` 帮助我们在多次渲染之间重用同一个函数实例，除非依赖项发生变化。

### 1.2 实现思路

`useCallback` 的实现逻辑与 `useMemo` 非常相似，区别在于它缓存的是**函数本身**，而不是函数的执行结果。

当组件重新渲染时：

1. React 比较当前的依赖项和上一次的依赖项。◊
2. 如果依赖项没有变化，返回上一次缓存的函数引用。
3. 如果依赖项发生了变化，返回新的函数引用，并更新缓存。

### 1.3 模拟实现

我们可以基于 `useMemo` 或者独立模拟 `useCallback`：

```javascript
// 模拟 React 内部存储
let hookStates = [];
let hookIndex = 0;

function useCallback(callback, deps) {
  const oldHook = hookStates[hookIndex];
  
  const hasChanged = oldHook ? !deps.every((dep, i) => Object.is(dep, oldHook.deps[i])) : true;

  if (hasChanged) {
    // 依赖变化，缓存新函数和依赖
    hookStates[hookIndex] = { callback, deps };
    hookIndex++;
    return callback;
  } else {
    // 依赖未变，返回旧函数
    hookIndex++;
    return oldHook.callback;
  }
}
```

## 2. 与 useMemo 的关系

`useCallback` 其实是 `useMemo` 的语法糖。

```javascript
useCallback(fn, deps)
```

等价于：

```javascript
useMemo(() => fn, deps)
```

- **useMemo**：缓存 `create()` 的返回值。
- **useCallback**：缓存 `callback` 本身。

如果你想用 `useMemo` 缓存一个函数，你需要把它包一层：`useMemo(() => () => { console.log('fn') }, [])`，这比较繁琐，所以有了 `useCallback`。

## 3. 使用场景

### 3.1 传递给经过优化的子组件

这是 `useCallback` 最主要的使用场景。当我们将函数作为 props 传递给被 `React.memo` 包裹的子组件时，如果父组件重新渲染导致函数引用变化，子组件也会随之重新渲染，导致 `React.memo` 失效。

```javascript
const Child = React.memo(({ onClick }) => {
  console.log("Child render");
  return <button onClick={onClick}>Click me</button>;
});

function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  // 🔴 错误：每次 Parent 渲染，handleClick 都是新引用
  // const handleClick = () => console.log(text);

  // 🟢 正确：只有 text 变化时，handleClick 引用才变
  const handleClick = useCallback(() => {
    console.log(text);
  }, [text]);

  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <Child onClick={handleClick} />
    </>
  );
}
```

### 3.2 作为其他 Hook 的依赖

如果你自定义的 Hook 接收一个函数作为参数，并将其作为 `useEffect` 的依赖，那么使用者就需要用 `useCallback` 包裹该函数，防止死循环或频繁执行 Effect。

```javascript
function useEvent(handler) {
  useEffect(() => {
    const cleanUp = handler();
    return cleanUp;
  }, [handler]); // handler 必须稳定
}

function Component() {
  // 如果不用 useCallback，每次渲染都会触发 useEvent 内部的 Effect
  const handler = useCallback(() => {
    // ...
  }, []);
  
  useEvent(handler);
}
```

## 4. 常见问题

### 4.1 闭包陷阱

由于 `useCallback` 缓存了函数，该函数创建时的闭包环境也被“冻结”了。如果依赖项数组写得不完整，函数内部可能访问到旧的 state 或 props。

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  // 🔴 错误：依赖项为空，永远只能看到初始的 count (0)
  const handleLog = useCallback(() => {
    console.log(count);
  }, []); 

  // 🟢 正确：添加 count 作为依赖
  const handleLogCorrect = useCallback(() => {
    console.log(count);
  }, [count]);
}
```

### 4.2 什么时候不需要 useCallback？

1. **原生 DOM 事件**：直接传给 `<button onClick={handleClick} />` 的函数不需要 `useCallback`，因为原生 DOM 组件不在乎 props 引用变化（除非你在做非常极端的优化）。
2. **子组件未被 React.memo 包裹**：如果子组件没有 memo 化，无论 props 变不变它都会重渲染，此时 `useCallback` 只有开销没有收益。
3. **简单组件**：过度优化会增加代码复杂度，对于渲染开销很小的组件，通常不需要。

### 4.3 性能权衡

`useCallback` 本身也有开销（创建依赖数组、比较依赖项）。只有当“函数引用变化导致子组件重渲染的开销” **大于** “useCallback 的开销”时，使用它才是有意义的。
