# 7.2 useImperativeHandle

`useImperativeHandle` 是一个用于自定义暴露给父组件的实例值（instance value）的 Hook。通常与 `forwardRef` 一起使用。

## 1. 核心作用

默认情况下，你在父组件中通过 ref 获取子组件时，如果子组件是函数组件，你什么也拿不到（因为函数组件没有实例）；如果子组件是 DOM 元素，你拿到的是 DOM 节点。

`useImperativeHandle` 允许你**自定义**这个 ref 包含的内容。也就是说，你可以决定父组件通过 ref 能调用子组件的哪些方法或访问哪些属性，从而实现**受控暴露**。

## 2. 语法

```javascript
useImperativeHandle(ref, createHandle, [deps])
```

*   **ref**: `forwardRef` 传递进来的 ref 对象。
*   **createHandle**: 一个函数，返回一个对象。这个对象中的属性和方法就是父组件能访问到的内容。
*   **deps**: 依赖数组。当依赖变化时，`createHandle` 会重新执行。

## 3. 使用示例

### 3.1 暴露指定方法

假设我们有一个 `FancyInput` 组件，我们不想让父组件直接访问底层的 `<input>` DOM 节点（因为那样父组件可以做任何事），而是只想暴露一个 `focus` 方法和一个 `shake` 动画方法。

```javascript
import React, { useRef, useImperativeHandle, forwardRef } from 'react';

const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    // 暴露 focus 方法
    focus: () => {
      inputRef.current.focus();
    },
    // 暴露自定义的动画方法
    shake: () => {
      console.log('Input is shaking!');
      // 实际动画逻辑...
    }
  }));

  return <input ref={inputRef} />;
});

// 父组件
function Parent() {
  const fancyInputRef = useRef();

  return (
    <>
      <FancyInput ref={fancyInputRef} />
      <button onClick={() => fancyInputRef.current.focus()}>Focus</button>
      <button onClick={() => fancyInputRef.current.shake()}>Shake</button>
    </>
  );
}
```

## 4. 为什么需要它？

1.  **封装性**：隐藏内部实现细节。父组件不需要知道子组件内部是用 `<input>` 还是 `<textarea>`，也不需要直接操作 DOM。
2.  **安全性**：只暴露必要的 API，防止父组件随意修改子组件状态或 DOM。
3.  **命令式编程**：在某些场景下（如动画、焦点管理、媒体播放控制），命令式调用比声明式 Props 更自然。

## 5. 最佳实践

*   **少用**：React 推荐声明式编程（通过 Props 传递状态）。只有在确实需要命令式交互（如 `focus`、`scroll`、`play/pause`）时才使用 ref。
*   **配合 forwardRef**：`useImperativeHandle` 必须配合 `forwardRef` 使用，否则无法接收到 `ref` 参数。

## 6. 源码浅析

`useImperativeHandle` 的内部实现其实就是用 `useEffect`（或 `useLayoutEffect`）来更新 ref.current。

```javascript
// 简易模拟
function useImperativeHandle(ref, createHandle, deps) {
  useLayoutEffect(() => {
    if (typeof ref === 'function') {
      ref(createHandle());
    } else if (ref !== null) {
      ref.current = createHandle();
    }
  }, deps);
}
```
*注：React 官方源码中确实使用了 `useLayoutEffect` 的时机，以确保在 DOM 更新后立即挂载 handle，避免闪烁。*
