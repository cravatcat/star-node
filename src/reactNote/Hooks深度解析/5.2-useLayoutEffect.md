# 5.2 useLayoutEffect ⭐

`useLayoutEffect` 是 `useEffect` 的一个版本，它在所有的 DOM 变更之后**同步**触发。

## 1. 原理讲解

### 核心特性

- **同步执行**：在浏览器执行绘制（paint）之前执行。
- **阻塞渲染**：会阻塞浏览器的绘制，直到回调函数执行完毕。
- **执行时机**：DOM 更新 -> `useLayoutEffect` -> 浏览器绘制 -> `useEffect`。

### 为什么需要它？

有时候我们需要在 DOM 更新后立即进行一些操作（如测量 DOM 元素的尺寸、位置），并根据这些信息再次更新状态。如果使用 `useEffect`，浏览器会先绘制一次中间状态，然后再执行 `useEffect` 更新状态，导致用户看到闪烁（FOUC - Flash of Unstyled Content）。`useLayoutEffect` 可以保证在浏览器绘制之前完成所有的状态更新，从而避免闪烁。

### 模拟实现

```javascript
function useLayoutEffect(callback, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;

  if (currentHook) {
    // 更新阶段
    const prevDeps = currentHook.memoizedState.deps;
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return;
    }
  }

  // 保存 effect，标记为 Layout 类型
  hook.memoizedState = {
    tag: 'Layout', 
    create: callback,
    deps: nextDeps,
    // ...其他属性
  };
  
  // 在 commit 阶段的 Layout 子阶段同步执行
  scheduleLayoutEffect(callback); 
}
```

## 2. vs useEffect

| 特性 | useEffect | useLayoutEffect |
| :--- | :--- | :--- |
| **执行时机** | 浏览器绘制**后**异步执行 | DOM 变更后，浏览器绘制**前**同步执行 |
| **对渲染的影响** | 不阻塞渲染，用户体验更好 | 阻塞渲染，可能导致页面卡顿 |
| **用途** | 数据获取、订阅、日志、不影响布局的操作 | DOM 测量、DOM 变更引起的同步动画、避免闪烁 |
| **服务端渲染 (SSR)** | 不执行 | 会报警告（因为服务端没有 Layout），通常需要用 `useEffect` 或条件判断替代 |

## 3. 使用场景

### 3.1 避免闪烁 (FOUC)

当你需要根据 DOM 的尺寸或位置来调整 UI 时。

```javascript
import { useLayoutEffect, useState, useRef } from 'react';

function Tooltip({ children, targetRect }) {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
    // 如果这里用 useEffect，用户可能会先看到位置不对的 Tooltip，然后瞬间跳到正确位置
  }, []);

  let top = targetRect.bottom;
  if (top + tooltipHeight > window.innerHeight) {
    top = targetRect.top - tooltipHeight;
  }

  return (
    <div ref={ref} style={{ position: 'absolute', top, left: targetRect.left }}>
      {children}
    </div>
  );
}
```

### 3.2 复杂的动画同步

在某些复杂的动画场景中，需要精确控制每一帧的 DOM 状态，确保动画的起始状态是正确的。

## 4. 常见问题

### Q: 什么时候该用 `useLayoutEffect`？

**A:** 默认使用 `useEffect`。只有当你发现使用 `useEffect` 会导致页面闪烁（例如先显示一个值，然后瞬间变成另一个值），或者你需要精确测量 DOM 布局信息时，才考虑使用 `useLayoutEffect`。

### Q: SSR 中的警告怎么办？

**A:** React 会在 SSR 时警告 `useLayoutEffect` 不会在服务端执行。
解决方案：

1. 如果逻辑不依赖布局，改用 `useEffect`。
2. 如果逻辑依赖布局，确保组件只在客户端渲染（例如使用 `useEffect` 设置一个 `isMounted` 状态）。
3. 使用 `useIsomorphicLayoutEffect` 模式：

   ```javascript
   const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;
   ```

### Q: 性能影响？

**A:** 因为 `useLayoutEffect` 是同步执行的，如果回调函数执行时间过长，会阻塞浏览器绘制，导致页面看起来卡顿。所以尽量保持回调函数轻量，避免进行昂贵的计算或同步网络请求。
