# 6.3 React.memo

`React.memo` 是一个高阶组件（HOC），用于优化函数组件的性能。它的作用类似于类组件中的 `PureComponent`，通过浅比较 props 来决定是否需要重新渲染组件。

## 1. 原理讲解

### 1.1 核心概念

React 的默认行为是：只要父组件重新渲染，所有子组件都会重新渲染（无论 props 是否变化）。
`React.memo` 改变了这一行为：

1. 它会缓存渲染结果。
2. 在组件更新前，将新的 props 与旧的 props 进行**浅比较**。
3. 如果 props 没有变化，则跳过渲染，直接复用上一次的结果。
4. 如果 props 变了，则重新渲染。

### 1.2 模拟实现

我们可以用一个高阶组件来模拟 `React.memo` 的行为：

```javascript
function memo(Component, arePropsEqual) {
  return class MemoizedComponent extends React.Component {
    shouldComponentUpdate(nextProps) {
      // 如果提供了自定义比较函数，使用它
      if (arePropsEqual) {
        // 注意：shouldComponentUpdate 返回 true 表示更新，
        // 而 arePropsEqual 返回 true 表示相等（不更新），所以要取反
        return !arePropsEqual(this.props, nextProps);
      }
      
      // 默认进行浅比较
      // 如果 props 浅比较相等，返回 false（不更新）
      return !shallowEqual(this.props, nextProps);
    }

    render() {
      return <Component {...this.props} />;
    }
  };
}

// 简单的浅比较实现
function shallowEqual(objA, objB) {
  if (Object.is(objA, objB)) return true;
  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) return false;

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
```

## 2. 自定义比较函数

`React.memo` 接收第二个参数 `arePropsEqual`，允许你自定义比较逻辑。

```javascript
const MyComponent = React.memo(Component, (prevProps, nextProps) => {
  // 返回 true：props 相等，跳过渲染
  // 返回 false：props 不等，重新渲染
  return prevProps.id === nextProps.id;
});
```

**注意**：这与 `shouldComponentUpdate` 的返回值含义相反！

- `shouldComponentUpdate`: 返回 `true` 更新，`false` 不更新。
- `arePropsEqual`: 返回 `true` 不更新（相等），`false` 更新。

## 3. 使用场景

### 3.1 纯展示组件

如果一个组件渲染开销较大（如复杂的图表、大列表），且 props 更新频率较低，非常适合使用 `React.memo`。

### 3.2 避免“株连”渲染

当父组件更新时，所有子组件默认都会更新。对于树叶节点的组件，如果它们完全不依赖父组件变动的数据，使用 `React.memo` 可以作为防火墙，阻止渲染波及。

## 4. 常见问题

### 4.1 为什么加了 React.memo 反而更慢？

`React.memo` 本身有比较 props 的开销。

- 如果组件渲染非常快（简单的 DOM 节点），比较 props 的时间可能比直接渲染还长。
- 如果 props 经常变化（几乎每次都变），那么比较 props 的工作就是白费的，因为最终还是要渲染。

### 4.2 浅比较的陷阱

如果 props 中包含对象或数组，且每次父组件渲染都创建新的引用（例如内联对象、箭头函数），`React.memo` 将失效，因为浅比较会认为它们不同。

**失效案例：**

```javascript
function Parent() {
  // 每次渲染都会生成新的 style 对象
  const style = { color: 'red' }; 
  // 每次渲染都会生成新的函数
  const handleClick = () => {};

  // Child 即使被 memo 包裹，也会每次都重渲染
  return <Child style={style} onClick={handleClick} />;
}
```

**解决方案：**
配合 `useMemo` 和 `useCallback` 保持引用稳定。

```javascript
function Parent() {
  const style = useMemo(() => ({ color: 'red' }), []);
  const handleClick = useCallback(() => {}, []);

  return <Child style={style} onClick={handleClick} />;
}
```

### 4.3 vs PureComponent

- `React.memo` 是给**函数组件**用的。
- `PureComponent` 是给**类组件**用的。
- 原理相同，都是做 props（和 state）的浅比较。
