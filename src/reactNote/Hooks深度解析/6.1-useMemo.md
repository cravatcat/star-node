# 6.1 useMemo

`useMemo` 是 React 提供的一个用于性能优化的 Hook，它允许你在渲染期间缓存计算结果。只有当依赖项发生变化时，才会重新计算该值。

## 1. 原理讲解

### 1.1 核心概念

`useMemo` 接收两个参数：

1. **create**：一个创建函数，用于计算并返回需要缓存的值。
2. **deps**：依赖数组，当数组中的任何值发生变化时，才会重新执行 create 函数。

它的主要作用是**记忆（Memoization）**。在计算机科学中，Memoization 是一种优化技术，主要通过存储昂贵函数调用的结果，并在相同的输入再次发生时返回缓存的结果，从而加速程序。

### 1.2 实现思路

React 在内部维护了一个 hook 链表。对于 `useMemo`，它会保存上一次的计算结果（memoizedValue）和依赖项（deps）。
当组件重新渲染时：

1. 取出上一次的依赖项。
2. 将当前的依赖项与上一次的进行浅比较（Object.is）。
3. 如果依赖项没有变化，直接返回上一次缓存的结果。
4. 如果依赖项发生了变化，执行 create 函数，更新并返回新的结果。

### 1.3 模拟实现

我们可以用一个简单的闭包来模拟 `useMemo` 的核心逻辑（简化版，不考虑 Fiber 架构的复杂性）：

```javascript
// 模拟 React 内部的 hook 存储
let hookStates = [];
let hookIndex = 0;

function useMemo(create, deps) {
  const oldHook = hookStates[hookIndex];
  
  // 检查是否有旧的 hook 状态以及依赖是否变化
  const hasChanged = oldHook ? !deps.every((dep, i) => Object.is(dep, oldHook.deps[i])) : true;

  if (hasChanged) {
    // 依赖变化或初次渲染，重新计算
    const newValue = create();
    hookStates[hookIndex] = { value: newValue, deps };
    hookIndex++;
    return newValue;
  } else {
    // 依赖未变，返回缓存值
    hookIndex++;
    return oldHook.value;
  }
}

// 模拟渲染过程
function render() {
  hookIndex = 0; // 重置 hook 索引
  // ... 组件渲染逻辑
}
```

在真实的 React 源码中，`useMemo` 分为 `mountMemo`（初次挂载）和 `updateMemo`（更新）两个阶段，逻辑更加严谨。

## 2. 使用场景

### 2.1 昂贵的计算

这是 `useMemo` 最直观的用途。如果一个计算过程非常耗时（例如处理大量数据、复杂的数学运算），我们不希望每次组件重渲染都执行它。

```javascript
const expensiveResult = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
```

**什么算昂贵？**
一般来说，创建数组、过滤列表、简单的数学运算通常都非常快，不需要 `useMemo`。如果计算耗时超过 1ms（在现代设备上这通常意味着数千次循环），或者涉及到大量的对象创建和遍历，才考虑使用。

### 2.2 保持引用稳定性

这是 `useMemo` 更常见且更重要的用途。

**场景一：作为其他 Hook 的依赖**
如果一个对象或数组被用作 `useEffect` 或其他 Hook 的依赖，你需要保证它的引用稳定性，否则会导致 Effect 频繁触发。

```javascript
const config = useMemo(() => ({
  color: theme.color,
  layout: theme.layout
}), [theme]);

useEffect(() => {
  // 只有当 config 真的变化时才执行
  setup(config);
}, [config]);
```

**场景二：配合 React.memo 避免子组件不必要的重渲染**
如果将一个对象或函数传递给被 `React.memo` 包裹的子组件，且该对象在每次父组件渲染时都重新创建，那么 `React.memo` 将失效。

```javascript
const Child = React.memo(({ data }) => {
  console.log("Child render");
  return <div>{data.text}</div>;
});

function Parent() {
  const [count, setCount] = useState(0);

  // 如果不使用 useMemo，每次 Parent 渲染，data 都是新引用
  // 导致 Child 即使 props 内容没变也会重新渲染
  const data = useMemo(() => ({ text: "Hello" }), []);

  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <Child data={data} />
    </>
  );
}
```

## 3. 注意事项

### 3.1 避免过度优化

不要默认在所有地方都使用 `useMemo`。

1. **开销**：`useMemo` 本身也有开销（分配内存、依赖比较）。对于简单的计算，缓存的开销可能比直接计算还要大。
2. **可读性**：过多的 `useMemo` 会降低代码可读性。

### 3.2 语义保证

React 官方文档提到：**你可以把 `useMemo` 作为性能优化的手段，但不要把它当成语义上的保证。**
虽然 React 目前会缓存值，但在未来，React 可能会选择“遗忘”一些 memoized 的值（例如为了释放内存），并在下次渲染时重新计算。因此，你的代码在没有 `useMemo` 的情况下也应该能正常工作。

## 4. 常见问题

### 4.1 useMemo vs useCallback

它们非常相似，区别在于缓存的内容：

- `useMemo` 缓存**函数的执行结果**。
- `useCallback` 缓存**函数本身**。

`useCallback(fn, deps)` 等价于 `useMemo(() => fn, deps)`。

### 4.2 为什么我的 useMemo 不生效？

1. **依赖项数组每次都变**：检查依赖项中是否有每次渲染都重新生成的对象或数组。
2. **React.memo 缺失**：如果你用 `useMemo` 优化传给子组件的 props，但子组件没有用 `React.memo` 包裹，那么子组件依然会跟随父组件重渲染。

### 4.3 什么时候不应该使用 useMemo？

- 计算非常简单（如 `a + b`）。
- 依赖项变化非常频繁，导致缓存几乎每次都失效。
- 为了“美观”或盲目遵循“最佳实践”。
