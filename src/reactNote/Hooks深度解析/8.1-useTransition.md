# 8.1 useTransition

`useTransition` 是 React 18 引入的一个用于并发渲染（Concurrent Rendering）的 Hook。它允许你将某些状态更新标记为“过渡”（Transition），即非紧急的更新。

## 1. 核心作用

在 React 中，状态更新通常分为两类：
1.  **紧急更新（Urgent updates）**：反映直接的交互，如输入、点击、按键。这些更新需要立即响应，否则用户会觉得卡顿。
2.  **过渡更新（Transition updates）**：如从一个视图切换到另一个视图、搜索结果的渲染等。用户预期这些操作可能需要一点时间。

`useTransition` 的作用就是将第二类更新标记为低优先级，允许 React 在渲染这些更新的过程中被紧急更新打断。

## 2. 语法

```javascript
const [isPending, startTransition] = useTransition();
```

*   **isPending**: 布尔值，表示是否存在待处理的过渡更新。可以用来显示加载状态（如 Spinner）。
*   **startTransition**: 一个函数，接受一个回调。回调中的状态更新会被标记为 transition。

## 3. 使用示例

### 3.1 优化卡顿的列表渲染

假设我们有一个输入框，输入内容后会过滤并渲染一个巨大的列表（例如 10000 项）。如果直接更新，输入框会卡顿。

```javascript
import React, { useState, useTransition } from 'react';

function App() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    // 1. 紧急更新：立即更新输入框显示
    setInput(e.target.value);

    // 2. 过渡更新：低优先级更新列表
    startTransition(() => {
      // 模拟耗时操作：生成大列表
      const l = [];
      for (let i = 0; i < 10000; i++) {
        l.push(`${e.target.value} Item ${i}`);
      }
      setList(l);
    });
  };

  return (
    <div>
      <input value={input} onChange={handleChange} />
      {isPending ? <p>Loading...</p> : (
        <ul>
          {list.map(item => <li key={item}>{item}</li>)}
        </ul>
      )}
    </div>
  );
}
```

**效果对比：**
-   **不使用 useTransition**：输入字符时，界面会卡死，直到列表渲染完成。
-   **使用 useTransition**：输入字符非常流畅，React 会优先处理输入框的更新，列表的更新会在后台进行，如果用户连续输入，旧的列表渲染会被打断。

## 4. 原理简析

当调用 `startTransition` 时，React 内部会做两件事：
1.  将当前的更新优先级降低（设置为 Transition Lane）。
2.  立即触发一次渲染（用于更新 `isPending` 为 true），然后开启一个并发渲染任务来处理回调中的状态更新。

如果在并发渲染期间有更高优先级的更新（如新的输入），React 会暂停或废弃当前的 Transition 渲染，优先处理高优先级任务。

## 5. 注意事项

1.  **不要滥用**：只用于确实会导致卡顿的慢速更新。对于快速更新，使用 transition 只会增加开销。
2.  **不能用于受控输入**：不要把输入框的 `value` 更新放在 `startTransition` 中，否则输入会变卡（因为变成了低优先级）。应该像上面的例子一样，把 `input` 分离出来。
3.  **同步执行**：传递给 `startTransition` 的函数必须是同步的。React 会立即执行它来捕获状态更新。

## 6. 与 setTimeout 的区别

*   `setTimeout` 仅仅是推迟了执行时间，一旦执行开始，仍然会阻塞主线程。
*   `useTransition` 是**并发**的。它允许渲染过程中断，让出主线程给更重要的任务。
