# 4.3 useImmer 深度解析

`useImmer` 是一个非常流行的第三方 Hook（通常由 `use-immer` 库提供），它结合了 React 的 `useState` 和 Immer 库的功能。它允许我们以**可变（Mutable）**的语法来修改状态，但最终生成**不可变（Immutable）**的新状态，从而解决了 React 中深层对象更新繁琐的问题。

## 1. Immer 原理

Immer 的核心思想是 **Copy-on-write (写时复制)**。

### 1.1 核心概念

* **Current State**: 当前状态。
* **Draft State**: 草稿状态，它是 Current State 的一个代理（Proxy）。我们可以随意修改它。
* **Next State**: 根据 Draft State 的修改生成的最终不可变状态。

### 1.2 模拟实现简易 Immer (produce)

Immer 的魔法在于 ES6 的 `Proxy`。

```javascript
// 这是一个极简版的 produce，用于理解原理
// 真实 immer 支持嵌套 Proxy 和结构共享
function produce(baseState, recipe) {
  // 1. 如果没有 recipe，直接返回
  if (!recipe) return baseState;

  // 2. 存储修改过的副本
  const copies = new Map();

  // 3. 创建 Proxy 处理器
  const handler = {
    get(target, prop) {
      // 如果该节点已被修改（有副本），从副本读取
      if (copies.has(target)) return copies.get(target)[prop];
      // 否则读取原值
      return target[prop];
    },
    set(target, prop, value) {
      // 写时复制 (Copy-on-write)
      // 第一次修改该对象时，创建一个浅拷贝
      if (!copies.has(target)) {
        copies.set(target, { ...target });
      }
      // 在副本上修改
      copies.get(target)[prop] = value;
      return true;
    }
  };

  // 4. 创建根节点的 Proxy (Draft)
  const draft = new Proxy(baseState, handler);

  // 5. 执行修改逻辑 (recipe 中修改的是 draft)
  recipe(draft);

  // 6. 返回结果
  // 如果 baseState 被修改过（在 copies 中），返回副本；否则返回原值
  return copies.has(baseState) ? copies.get(baseState) : baseState;
}
```

*注：真正的 Immer 实现要复杂得多，涉及递归 Proxy 和结构共享（Structural Sharing），即未修改的节点保持引用不变，修改的节点及其父链生成新引用。*

---

## 2. useImmer 实现

`useImmer` 本质上就是 `useState` + `produce`。

### 2.1 模拟实现

```javascript
import { useState, useCallback } from 'react';
// 假设引入了 immer 的 produce (实际项目中需 npm install immer)
import { produce } from 'immer'; 

function useImmer(initialValue) {
  const [val, setVal] = useState(initialValue);

  const updateValue = useCallback((updater) => {
    if (typeof updater === 'function') {
      // 如果是函数：setVal(old => produce(old, draft => { ... }))
      setVal(oldValue => produce(oldValue, updater));
    } else {
      // 如果是直接值，直接设置
      setVal(updater);
    }
  }, []);

  return [val, updateValue];
}
```

### 2.2 使用对比

#### 场景：修改深层嵌套对象

```javascript
const [person, setPerson] = useState({
  name: 'John',
  address: { city: 'New York', zip: 10001 }
});
```

#### ❌ 传统 useState (痛苦的展开运算符)

```javascript
setPerson(prev => ({
  ...prev,
  address: {
    ...prev.address,
    city: 'San Francisco' // 只想改这一个字段
  }
}));
```

#### ✅ 使用 useImmer (直观的可变语法)

```javascript
const [person, updatePerson] = useImmer({
  name: 'John',
  address: { city: 'New York', zip: 10001 }
});

updatePerson(draft => {
  // 直接修改 draft，像写 Vue 或普通 JS 对象一样
  draft.address.city = 'San Francisco';
});
```

---

## 3. 常见问题

### Q1: 为什么要使用不可变数据 (Immutable Data)？

1. **可预测性**：状态变更可追踪，数据流向清晰。
2. **性能优化**：React 的 `memo` 和 `PureComponent` 依赖**浅比较 (Shallow Compare)**。
   * 如果直接修改对象属性（Mutation），对象引用没变，React 检测不到变化，不会触发重渲染。
   * 如果为了安全每次都深拷贝（Deep Clone），性能开销太大。
   * Immutable (结构共享) 完美平衡了这两点。
3. **功能支持**：方便实现“时间旅行”（Time Travel，撤销/重做）功能。

### Q2: Immer 和深拷贝 (Deep Clone) 有什么区别？

* **Deep Clone (如 `JSON.parse(JSON.stringify(obj))` 或 `lodash.cloneDeep`)**：
  * 复制**整个**对象树。
  * 如果对象很大，**极其消耗 CPU 和内存**。
  * 生成全新的引用，所有节点都变了。
* **Immer (结构共享 Structural Sharing)**：
  * **只复制**修改节点及其父路径上的节点。
  * **未修改**的分支完全与旧状态共享引用。
  * 既保证了不可变性（新旧引用不同），又极大优化了内存和性能。

### Q3: Proxy vs Object.defineProperty?

这也是 Vue 2 和 Vue 3 响应式原理的核心区别，同样适用于 Immer。

| 特性 | Object.defineProperty (Vue 2) | Proxy (Vue 3 / Immer) |
| :--- | :--- | :--- |
| **拦截范围** | 只能拦截属性的读写 (get/set) | 拦截对象几乎所有操作 (读写、删除、遍历、函数调用等) |
| **数组支持** | 不支持 (需重写 push/pop 等方法 hack) | 原生支持数组索引修改和 length 变化 |
| **动态属性** | 不支持 (需 Vue.set) | 支持新增/删除属性 |
| **性能** | 需递归遍历初始化 (启动慢) | 惰性代理 (访问时才拦截，性能好) |
