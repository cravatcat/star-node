# 7.1 useRef

`useRef` 是 React 提供的一个用于在组件的整个生命周期内持久保存值的 Hook。它的返回值是一个可变的 ref 对象，该对象的 `.current` 属性被初始化为传入的参数。

## 1. 原理讲解

### 1.1 核心概念

`useRef` 就像是组件的一个“盒子”或“实例变量”。
-   **持久化**：在组件的多次渲染之间，`ref` 对象本身保持不变（引用地址不变）。
-   **可变性**：你可以随意修改 `.current` 属性。
-   **不触发渲染**：与 `useState` 不同，修改 `.current` **不会**触发组件重新渲染。

### 1.2 模拟实现

`useRef` 的实现非常简单，它本质上就是 `useState` 或 `useMemo` 的一个特例。

```javascript
function useRef(initialValue) {
  const [hookState] = useState(() => ({
    current: initialValue
  }));
  return hookState;
}
```
*注意：React 源码中通常将 ref 存储在 Fiber 节点的 `memoizedState` 链表中。*

## 2. 使用场景

### 2.1 访问 DOM 节点

这是 `useRef` 最常见的用途。通过将 ref 对象传递给 React 元素的 `ref` 属性，React 会在挂载时将 DOM 节点赋值给 `.current`。

```javascript
function TextInput() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus</button>
    </>
  );
}
```

### 2.2 保存可变值（Mutable Value）

由于修改 ref 不会触发渲染，它非常适合保存那些“不需要参与渲染”的数据。

**场景示例：**
-   **定时器 ID**：`clearInterval` 需要用到 ID，但 ID 本身不需要显示在界面上。
-   **上一次的 Props/State**：用于实现 `usePrevious` Hook。
-   **避免闭包陷阱**：在 `useEffect` 或 `useCallback` 中访问最新的 state，而不将其列为依赖。

```javascript
// 实现 usePrevious
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value; // 在渲染后更新
  });
  return ref.current; // 返回上一次的值
}
```

## 3. 常见问题

### 3.1 useRef vs useState

| 特性 | useRef | useState |
| :--- | :--- | :--- |
| **返回值** | `{ current: ... }` | `[value, setValue]` |
| **修改方式** | 直接修改 `.current` | 调用 `setValue` |
| **触发渲染** | **否** | **是** |
| **用途** | DOM、定时器、实例变量 | UI 数据、状态逻辑 |

### 3.2 为什么 ref 不作为依赖项？

在 `useEffect` 或 `useCallback` 的依赖数组中，通常不需要写 ref。
因为 React 保证了 ref 对象的引用在组件的整个生命周期内是**稳定**的（即内存地址不变）。

### 3.3 ref 的更新时机

React 会在 **Commit 阶段**（DOM 更新后）更新 ref。这意味着在渲染阶段（Render Phase）读取 ref 可能会得到旧值或 null（如果是首次渲染）。因此，**不要在渲染逻辑中读取或写入 ref.current**，而应该在 `useEffect` 或事件处理函数中操作。
