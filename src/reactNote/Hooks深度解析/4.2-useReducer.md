# 4.2 useReducer 深度解析

`useReducer` 是 React 提供的一个用于管理复杂状态逻辑的 Hook。它接收一个 reducer 函数和初始状态，返回当前状态和一个 dispatch 函数。在某些场景下，它是 `useState` 的替代方案，更适合处理包含多个子值或下一个 state 依赖于前一个 state 的复杂状态逻辑。

## 1. 原理讲解

### 1.1 核心概念

`useReducer` 的核心思想来源于 Redux，它将状态更新逻辑从组件中剥离出来，统一放在 reducer 函数中处理。

* **Reducer**: `(state, action) => newState` 的纯函数。
* **Dispatch**: 用于触发 action 的函数。
* **Action**: 描述发生了什么的对象，通常包含 `type` 和 `payload`。

### 1.2 模拟实现

我们可以基于 `useState` 来模拟实现一个简单的 `useReducer`，或者更底层地理解它的工作原理。

#### 基于 useState 的简易实现

```javascript
import { useState, useCallback } from 'react';

function useReducer(reducer, initialState, init) {
  // 处理惰性初始化
  const [state, setState] = useState(
    init ? () => init(initialState) : initialState
  );

  const dispatch = useCallback((action) => {
    setState((prevState) => reducer(prevState, action));
  }, [reducer]);

  return [state, dispatch];
}
```

#### 底层实现思路 (简化版)

在 React 内部，`useReducer` 和 `useState` 共享底层结构（Fiber节点上的 hooks 链表）。

```javascript
let hookState = []; // 存储 hooks 状态
let hookIndex = 0;  // 当前 hook 索引

function useReducer(reducer, initialState) {
  const currentHookIndex = hookIndex;
  
  // 初始化状态 (仅第一次)
  if (!hookState[currentHookIndex]) {
    hookState[currentHookIndex] = {
      value: initialState,
      reducer: reducer
    };
  }

  const hook = hookState[currentHookIndex];

  const dispatch = (action) => {
    // 获取新的 state
    const newState = hook.reducer(hook.value, action);
    
    // 如果 state 改变，更新并触发重渲染
    if (newState !== hook.value) {
      hook.value = newState;
      render(); // 模拟 React 的重渲染机制
    }
  };

  hookIndex++; // 移动到下一个 hook
  return [hook.value, dispatch];
}
```

---

## 2. 与 useState 的关系

### 2.1 useState 是简化的 useReducer

在 React 源码中，`useState` 实际上是 `useReducer` 的一个语法糖（或者说特例）。

当我们在 React 内部调用 `useState(initialState)` 时，它大致等价于：

```javascript
function useState(initialState) {
  // 使用一个内置的 basicStateReducer
  // basicStateReducer 只是简单地返回新的 action（如果是值）或执行 update function
  return useReducer(basicStateReducer, initialState);
}

function basicStateReducer(state, action) {
  // 如果 action 是函数，则执行函数更新：setCount(prev => prev + 1)
  // 否则直接返回 action：setCount(1)
  return typeof action === 'function' ? action(state) : action;
}
```

### 2.2 用 useReducer 实现 useState

我们可以利用 `useReducer` 轻松实现 `useState`：

```javascript
const useState = (initialState) => {
  // reducer 负责处理状态更新逻辑
  const reducer = (state, action) => {
    if (typeof action === 'function') {
      return action(state);
    }
    return action;
  };

  return useReducer(reducer, initialState);
};
```

---

## 3. 使用场景

虽然 `useState` 能解决大部分问题，但在以下场景中 `useReducer` 更具优势：

### 3.1 复杂的状态逻辑

当状态是一个复杂的对象，且更新逻辑包含多个子步骤或依赖关系时。

```javascript
// ❌ 使用 useState 可能需要多个 set
const [data, setData] = useState([]);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);

// ✅ 使用 useReducer 统一管理
const initialState = {
  loading: false,
  error: null,
  data: []
};

function reducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, data: action.payload };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
}
```

### 3.2 下一个 State 依赖于前一个 State

虽然 `useState` 的函数式更新也能做到，但 `useReducer` 的 `reducer` 天然接收 `state` 作为第一个参数，逻辑更清晰。

### 3.3 性能优化 (传递 dispatch 而非回调)

在深层组件树中，传递 `dispatch` 往往比传递回调函数更好。因为 `dispatch` 在组件的整个生命周期中是保持不变的（stable），所以传递 `dispatch` 给子组件时，不会引起子组件不必要的重渲染（配合 `React.memo`）。

```javascript
// 父组件
const [state, dispatch] = useReducer(reducer, initialState);

// 这里传递 dispatch 不会变，Child 组件配合 memo 可有效避免重渲染
<Child dispatch={dispatch} />
```

---

## 4. 常见问题

### Q1: useReducer 和 Redux 的区别？

| 特性 | useReducer | Redux |
| :--- | :--- | :--- |
| **范围** | 组件级状态管理 (Context 可扩展为全局) | 全局状态管理 |
| **中间件** | 不支持 (需自行封装) | 支持 (Thunk, Saga 等) |
| **DevTools** | 较弱 | 强大 (时间旅行等) |
| **使用复杂度** | 低，React 内置 | 高，需要引入额外库 |
| **适用场景** | 复杂组件逻辑、简单的全局状态 | 大型应用、复杂数据流 |

### Q2: 如何使用 useReducer + useContext 替代 Redux？

这是常见的轻量级全局状态管理方案：

1. **创建 Context**: `const StateContext = createContext(); const DispatchContext = createContext();`
2. **提供 Provider**: 在顶层组件中使用 `useReducer`，将 `state` 和 `dispatch` 分别通过 Context 传递。
3. **消费**: 子组件通过 `useContext` 获取 `state` 或 `dispatch`。

**优点**: 轻量、无外部依赖。
**缺点**: 无法像 Redux 那样细粒度地选择状态（Selector），Context 更新会导致所有消费者重渲染（除非做细致的优化或拆分 Context）。

### Q3: 惰性初始化 (Lazy Initialization) 是什么？

`useReducer` 的第三个参数 `init` 允许我们惰性地创建初始状态。这对于初始状态需要经过昂贵计算的场景很有用。

**核心作用：**

1. **性能优化**：避免每次渲染都重新计算初始状态（类似 `useMemo` 的效果）。
2. **重置状态 (Reset)**：这是它比 `useMemo` 更强大的地方，**reducer 内部可以复用 init 函数来重置状态**。

#### 场景演示：重置状态

```javascript
function init(initialCount) {
  return { count: initialCount };
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'reset':
      // ✨ 关键点：reducer 内部可以直接调用 init 来重置状态
      // 这样保证了初始化逻辑和重置逻辑的完全一致
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({ initialCount }) {
  // init 函数只会在初始化渲染时调用
  // 实际初始 state = init(initialCount)
  const [state, dispatch] = useReducer(reducer, initialCount, init);

  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      </button>
    </>
  );
}
```

#### 思考：为什么不用 useMemo？

虽然 `useMemo` 也能避免重复计算初始值：

```javascript
const initialState = useMemo(() => init(props.count), [props.count]);
const [state, dispatch] = useReducer(reducer, initialState);
```

但使用 **第三个参数 (init)** 有两个独特优势：

1. **重置复用**：如上例所示，`reducer` 内部可以直接调用 `init` 函数进行重置，逻辑闭环。如果用 `useMemo`，`reducer` 内部无法访问那个计算逻辑，必须由组件外部再传一次初始值进去。
2. **语义保证**：`init` 保证只执行一次。而 `useMemo` 主要是性能优化手段，React 官方不保证它在未来特定策略下（如内存回收）不会被重新计算。
