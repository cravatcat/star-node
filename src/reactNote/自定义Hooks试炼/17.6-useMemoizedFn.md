# 17.6 useMemoizedFn

## 1. 实现思路

持久化函数引用，同时能访问最新 state（类似 ahooks 的 useMemoizedFn）。

## 2. 代码实现

```typescript
import { useRef, useMemo } from 'react';

function useMemoizedFn<T extends (...args: any[]) => any>(fn: T) {
  const fnRef = useRef<T>(fn);

  // 每次渲染都更新 ref.current
  fnRef.current = fn;

  const memoizedFn = useMemo(() => {
    return ((...args: any[]) => {
      return fnRef.current(...args);
    }) as T;
  }, []);

  return memoizedFn;
}

export default useMemoizedFn;
```

## 3. 使用示例

```tsx
const memoizedSubmit = useMemoizedFn(() => {
  console.log(count); // Always latest count
});
```

## 4. 常见问题

- **优势**：相比 useCallback，不需要手动管理依赖数组，且函数引用永远不变。
