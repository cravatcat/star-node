# 事件委托机制

React 并不会将事件监听器直接绑定到真实的 DOM 节点上（除了少数特殊的如 scroll），而是采用**事件委托**的方式。

## 1. 委托目标的变化
*   **React 16**：委托到 `document`。
*   **React 17+**：委托到 React 应用的根节点（`root` 容器）。

**变更原因**：
如果页面上有多个 React 应用（微前端架构），或者 React 和 jQuery/原生代码共存。
*   在 React 16 中，`e.stopPropagation()` 无法阻止事件冒泡到 `document`，可能导致其他 React 应用或原生代码意外捕获事件。
*   在 React 17 中，事件只冒泡到各自的 `root`，实现了应用间的隔离。

## 2. 事件注册与分发

### 2.1 注册阶段
在组件挂载（Mount）时，React 会检查 props 中的事件属性（如 `onClick`），但**不会**在 DOM 上 `addEventListener`。它只是将事件监听器保存到内部的数据结构中。

### 2.2 绑定阶段
React 启动时，会在根节点（root）上为所有支持的事件类型（click, input, change...）统一注册原生的 `addEventListener`。

### 2.3 分发阶段 (Dispatch)
当原生事件触发时：
1.  **捕获目标**：React 监听到根节点的事件。
2.  **获取目标源**：通过 `nativeEvent.target` 找到触发事件的真实 DOM。
3.  **寻找实例**：通过 DOM 节点上的内部属性（`__reactFiber...`）找到对应的 Fiber 节点。
4.  **收集路径**：从目标 Fiber 节点向上遍历直到根节点，收集沿途所有该类型（如 onClick）的监听函数。
5.  **模拟流转**：
    *   先执行**捕获阶段**的监听器（onClickCapture）。
    *   再执行**冒泡阶段**的监听器（onClick）。
6.  **执行回调**：依次调用收集到的函数。如果某处调用了 `e.stopPropagation()`，则停止执行后续函数。

## 3. 模拟实现：简单的事件系统

```javascript
const root = document.getElementById('root');

// 1. 统一绑定
root.addEventListener('click', dispatchEvent);

// 2. 分发中心
function dispatchEvent(nativeEvent) {
  let target = nativeEvent.target;
  let paths = []; // 收集冒泡路径
  
  // 3. 向上查找 React 组件实例
  while (target && target !== root) {
    const fiber = getFiberFromDOM(target);
    if (fiber) {
      const handler = fiber.props.onClick;
      if (handler) {
        paths.push(handler);
      }
    }
    target = target.parentNode;
  }
  
  // 4. 模拟冒泡执行
  // 合成事件对象
  const syntheticEvent = createSyntheticEvent(nativeEvent);
  
  for (let i = 0; i < paths.length; i++) {
    if (syntheticEvent.isPropagationStopped) break;
    paths[i](syntheticEvent);
  }
}
```

## 4. 常见问题
### Q: 为什么 React 需要自己实现事件冒泡？
**A:** 浏览器的原生冒泡在不同浏览器间表现可能不一致。React 通过自己收集路径并依次执行，完全控制了事件流，保证了行为的一致性，并且使得 `Portal` 组件（渲染到 DOM 树的其他位置）也能遵循 React 组件树的层级进行冒泡，而不是 DOM 树的层级。

### Q: Portal 中的事件冒泡？
**A:** 
```jsx
<div onClick={handleClick}>
  <Portal>
    <button>Click me</button>
  </Portal>
</div>
```
虽然 `button` 在 DOM 上可能是在 `body` 下，不属于 `div` 的子节点。但在 React Fiber 树中，`button` 是 `div` 的子节点。React 的事件冒泡是基于 **Fiber 树** 的，所以 `handleClick` 能捕获到事件。
