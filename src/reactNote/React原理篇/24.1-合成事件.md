# 合成事件 (SyntheticEvent)

React 实现了一套自己的事件系统，称为合成事件。它是浏览器原生事件的跨浏览器包装器。

## 1. 为什么需要合成事件？
1.  **跨浏览器兼容**：抹平不同浏览器（IE vs Chrome）之间的差异，提供统一的 API（如 `e.nativeEvent`）。
2.  **性能优化**：
    *   **事件委托**：利用事件冒泡，将所有事件绑定在根节点，减少内存消耗。
    *   **对象复用**（React 17 之前）：使用事件池机制，减少垃圾回收（GC）。

## 2. 合成事件对象
React 事件处理函数接收到的 `event` 参数不是原生的 DOM 事件对象，而是 `SyntheticEvent` 的实例。

```javascript
function handleClick(e) {
  e.preventDefault(); // 统一的阻止默认行为
  e.stopPropagation(); // 统一的阻止冒泡
  console.log(e.nativeEvent); // 访问原生事件
}
```

## 3. 事件池 (Event Pooling) - 历史遗留
**注意：React 17 已移除事件池。**

在 React 16 及之前，为了性能，`SyntheticEvent` 对象会被放入池中复用。事件回调执行完后，对象属性会被清空。

```javascript
// React 16
function handleChange(e) {
  // 错误：异步访问 e，此时 e 已经被清空回收了
  setTimeout(() => {
    console.log(e.target.value); // null
  }, 100);
  
  // 正确：保留事件对象
  e.persist();
}
```

**React 17+ 变更**：由于现代浏览器 JS 引擎性能提升，且事件池机制容易导致心智负担（异步访问 bug），React 17 移除了事件池，`e.persist()` 变成了空函数。

## 4. 模拟实现：简单的合成事件

```javascript
class SyntheticEvent {
  constructor(nativeEvent) {
    this.nativeEvent = nativeEvent;
    this.target = nativeEvent.target;
    this.type = nativeEvent.type;
    this.isPropagationStopped = false;
    this.isDefaultPrevented = false;
  }

  stopPropagation() {
    this.isPropagationStopped = true;
    if (this.nativeEvent.stopPropagation) {
      this.nativeEvent.stopPropagation();
    }
  }

  preventDefault() {
    this.isDefaultPrevented = true;
    if (this.nativeEvent.preventDefault) {
      this.nativeEvent.preventDefault();
    }
  }
}
```

## 5. 常见问题
### Q: 合成事件和原生事件混用要注意什么？
**A:** 尽量避免混用。
*   **执行顺序**：原生事件（document 上）通常先于 React 合成事件执行（因为 React 委托在 root/document 上，且处理逻辑可能不同）。
*   **阻止冒泡**：在 React 中 `e.stopPropagation()` 只能阻止 React 合成事件的冒泡，无法阻止原生事件冒泡到 document（除非 React 捕获到了）。

### Q: React 17 为什么要移除事件池？
**A:** 
1.  现代浏览器性能足够好，对象创建销毁的开销不再是瓶颈。
2.  事件池机制导致异步代码中访问事件对象容易出错，增加了学习成本。
