# Hooks 规则原理

React 官方文档强调了两条 Hooks 规则，这两条规则直接由 Hooks 的底层实现原理（链表 + 索引/顺序）决定。

## 规则 1：只在最顶层使用 Hook
**不要在循环，条件或嵌套函数中调用 Hook。**

### 原理分析
React 在 `update` 阶段，是按照**调用顺序**依次从 `currentFiber.memoizedState` 链表中取出 Hook 节点的。

假设有如下代码：
```javascript
function App() {
  const [name, setName] = useState('Mary'); // Hook 1
  
  if (name !== '') {
    useEffect(() => { ... });               // Hook 2
  }
  
  const [surname, setSurname] = useState('Poppins'); // Hook 3
}
```

**第一次渲染 (name='Mary')**
链表结构：`Hook1(State) -> Hook2(Effect) -> Hook3(State)`

**第二次渲染 (name='')**
1.  遇到 `useState`，取出 Hook1。匹配成功。
2.  条件为 false，跳过 `useEffect`。
3.  遇到 `useState`，React 以为这是第二个 Hook，于是取出 Hook2 (Effect) 来匹配。
4.  **崩溃**：React 发现 Hook2 是 Effect 类型，但现在请求的是 State 类型，或者状态读取错误。

### 模拟场景
如果 React 允许这样做，它必须为每个 Hook 生成唯一 ID（如 symbol 或 hash），但这会带来巨大的运行时开销和复杂性。React 选择了**依赖顺序**这种轻量级的实现方式。

## 规则 2：只在 React 函数中调用 Hook
**不要在普通的 JavaScript 函数中调用 Hook。**

### 原理分析
Hook 需要获取当前的渲染上下文（Current Fiber）。
1.  React 维护了一个全局变量 `ReactCurrentDispatcher.current`。
2.  在组件渲染开始前，React 会设置这个变量指向当前的 Dispatcher。
3.  组件渲染结束后，重置为 null。

如果在普通函数（非组件渲染过程）中调用 Hook：
*   此时 `ReactCurrentDispatcher.current` 为 null 或错误的值。
*   Hook 无法找到对应的 Fiber 节点来存储状态。
*   抛出错误：`Invalid hook call`.

## 3. Lint 插件
`eslint-plugin-react-hooks` 是如何工作的？
它是通过静态代码分析（AST 分析）来强制执行这些规则的：
*   检查 Hook 调用是否在控制流语句（if/for/while）内部。
*   检查调用 Hook 的函数是否符合组件命名规范（大写开头或 use 开头）。

## 4. 总结
Hooks 的规则并非人为的限制，而是**链表存储结构**和**全局调度机制**下的必然要求。遵守这些规则，React 才能准确地在多次渲染之间保持状态的一致性。
