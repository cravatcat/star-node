# Diff 算法

React 的 Diff 算法是协调（Reconciliation）过程的核心，用于比较新旧两棵虚拟 DOM 树，找出差异并更新真实 DOM。

## 1. Diff 策略
为了将算法复杂度从 O(n^3) 降低到 O(n)，React 制定了三个策略：

1.  **同层比较**：只比较同一层级的节点，不跨层级比较。
2.  **类型比较**：如果节点类型（type）不同，直接销毁旧树，创建新树。
3.  **Key 优化**：通过 key 标识子节点，在同一层级移动节点时复用，而不是销毁重建。

## 2. 单节点 Diff
当新节点只有一个时：
1.  判断旧节点是否存在。
2.  如果存在，判断 key 是否相同。
3.  如果 key 相同，判断 type 是否相同。
    *   都相同：复用旧节点（更新 props）。
    *   type 不同：将旧节点标记为删除，新建节点。
    *   key 不同：将旧节点标记为删除，继续查找兄弟节点（在多节点情况）。

```javascript
function reconcileSingleElement(returnFiber, currentFirstChild, element) {
  const key = element.key;
  let child = currentFirstChild;
  
  // 遍历旧链表寻找可复用节点
  while (child !== null) {
    // key 相同
    if (child.key === key) {
      // type 相同 -> 复用
      if (child.type === element.type) {
        // 删除剩余的兄弟节点
        deleteRemainingChildren(returnFiber, child.sibling);
        // 复用节点
        const existing = useFiber(child, element.props);
        existing.return = returnFiber;
        return existing;
      } else {
        // key 相同但 type 不同，不能复用，且同一 key 的节点唯一，删除该节点及其兄弟
        deleteRemainingChildren(returnFiber, child);
        break;
      }
    } else {
      // key 不同，删除当前旧节点，继续找
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }

  // 没找到可复用节点，创建新 Fiber
  const created = createFiberFromElement(element, returnFiber.mode, expirationTime);
  created.return = returnFiber;
  return created;
}
```

## 3. 多节点 Diff (Array)
当新节点是数组时，涉及节点的更新、新增、删除和移动。React 使用两轮遍历和 Map 来优化。

### 第一轮遍历：处理更新
从头开始遍历新旧节点：
1.  如果 key 和 type 都相同，复用节点。
2.  如果 key 不同，立即结束第一轮遍历。
3.  如果新/旧节点遍历完，结束。

### 第二轮遍历：处理剩余节点
**情况 1：新节点没遍历完，旧节点遍历完了**
说明有新增节点，将剩余新节点全部创建并插入。

**情况 2：新节点遍历完了，旧节点没遍历完**
说明有删除节点，将剩余旧节点全部标记删除。

**情况 3：新旧节点都没遍历完（最复杂，涉及移动）**
1.  将剩余**旧节点**存入 Map (key -> Fiber)。
2.  遍历剩余**新节点**，在 Map 中寻找可复用节点。
    *   找到：复用，并从 Map 中移除。
    *   没找到：新建。
3.  **移动逻辑**：
    *   维护 `lastPlacedIndex`（最后一个可复用节点在旧列表中的位置）。
    *   如果当前复用节点的 `oldIndex < lastPlacedIndex`，说明该节点需要向右移动。
    *   否则，更新 `lastPlacedIndex = oldIndex`。
4.  最后，Map 中剩余的旧节点全部标记删除。

## 4. Key 的作用
Key 是 React 识别节点的唯一标识。

### 为什么不推荐使用 Index 作为 Key？
如果列表顺序发生变化（如插入、删除、排序）：
1.  **性能问题**：React 会认为所有节点都变了（key 对应不上或错位），导致错误复用或不必要的重建。
2.  **状态错乱**：如果子组件有内部状态（如 input 输入框），使用 index 可能导致状态保留在错误的组件上。

**示例：**
```javascript
// 旧
<ul>
  <li key="0">A</li>
  <li key="1">B</li>
</ul>

// 新（在头部插入 C）
<ul>
  <li key="0">C</li> // React 认为这是 A 变了 C
  <li key="1">A</li> // React 认为这是 B 变了 A
  <li key="2">B</li> // 新增 B
</ul>
```
如果使用唯一 ID 作为 Key，React 就能识别出 C 是新增，A 和 B 只是移动了位置。

## 5. 常见问题
### Q: Diff 算法的时间复杂度？
**A:** O(n)。通过上述三个策略，避免了全量比较。

### Q: 为什么不建议跨层级移动节点？
**A:** React 的 Diff 算法不会跨层级寻找节点。如果一个节点跨层级移动，React 会直接销毁旧节点，并在新位置重新创建，这会丢失组件状态且性能较差。
