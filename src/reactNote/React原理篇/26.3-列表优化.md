# 列表渲染优化

在 React 中处理长列表（成百上千项）是常见的性能瓶颈。主要有两个优化方向：虚拟列表（Virtualization）和 Key 优化。

## 1. 虚拟列表 (Virtual List)
如果一个列表有 1000 项，但在视口中只能看到 10 项，渲染所有 1000 个 DOM 节点是极大的浪费。
**虚拟列表**的核心思想是：**只渲染可视区域内的节点**。

### 1.1 实现原理 (以 react-window 为例)
1.  **容器高度**：设置一个外部容器，高度为 `itemCount * itemHeight`，撑开滚动条。
2.  **计算可视范围**：监听 `scroll` 事件，根据 `scrollTop` 计算当前可视区域的 `startIndex` 和 `endIndex`。
3.  **绝对定位**：只渲染 `startIndex` 到 `endIndex` 之间的数据，并通过 `transform: translateY` 将它们定位到正确的位置。

```javascript
// 简易实现思路
function VirtualList({ itemCount, itemHeight, windowHeight, renderItem }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const innerHeight = itemCount * itemHeight;
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    itemCount - 1,
    Math.floor((scrollTop + windowHeight) / itemHeight)
  );
  
  const items = [];
  for (let i = startIndex; i <= endIndex; i++) {
    items.push(
      <div 
        key={i} 
        style={{ 
          position: 'absolute', 
          top: `${i * itemHeight}px`,
          height: `${itemHeight}px`
        }}
      >
        {renderItem(i)}
      </div>
    );
  }
  
  return (
    <div 
      style={{ height: windowHeight, overflowY: 'auto', position: 'relative' }}
      onScroll={e => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: innerHeight }}>
        {items}
      </div>
    </div>
  );
}
```

## 2. Key 的优化
在列表渲染中，`key` 是 React Diff 算法判断节点是否可复用的唯一依据。

### 2.1 最佳实践
*   **使用唯一 ID**：如数据库 ID (`user.id`)。
*   **避免使用 Index**：
    *   如果列表顺序发生变化（排序、筛选、插入、删除），使用 Index 会导致 React 错误地复用组件，可能导致状态错乱或性能下降。
    *   **例外**：如果列表是静态的（不排序、不增删），使用 Index 是安全的。

### 2.2 反模式示例
```jsx
// 错误：使用 index 作为 key，且列表可变
{list.map((item, index) => (
  <ListItem key={index} {...item} />
))}

// 正确
{list.map((item) => (
  <ListItem key={item.id} {...item} />
))}
```

## 3. 常见问题
### Q: 虚拟列表在滚动快时出现白屏？
**A:** 因为滚动是异步的，计算渲染跟不上滚动速度。
**优化**：使用 `overscan`（缓冲区），在可视区域上下多渲染几项（如上下各多渲染 5 项），作为缓冲。

### Q: 动态高度的虚拟列表怎么做？
**A:** 需要预估高度或缓存已渲染项的高度。通常库（如 `react-virtualized`）会提供 `CellMeasurer` 组件来动态测量内容高度并更新缓存。
