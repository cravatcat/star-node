# 调度原理 (Scheduler)

React Scheduler 是一个独立的包，负责任务的**优先级管理**和**时间切片**。它是 React 实现并发特性的动力源。

## 1. 核心目标
1.  **提高响应性**：保证高优先级任务（如用户输入）优先执行。
2.  **防止阻塞**：避免长任务占用主线程过久，导致掉帧。

## 2. 优先级模型 (Lane Model)
React 曾使用 `expirationTime`（过期时间）来管理优先级，React 18 全面转向了 `Lane` 模型。

### 2.1 为什么用 Lane？
Lane 使用 31 位二进制掩码表示优先级。
*   **表达能力强**：可以表示多个优先级的组合（通过位运算 `|`）。
*   **计算快**：位运算速度极快。
*   **分离概念**：将任务的“类型”与“时间”解耦。

### 2.2 优先级等级
Scheduler 内部将 Lane 映射为 5 个优先级等级：
1.  `ImmediatePriority` (1): 立即执行（同步更新，不能被中断）。
2.  `UserBlockingPriority` (2): 用户阻塞（点击、输入，250ms 内执行）。
3.  `NormalPriority` (3): 正常优先级（数据请求，5s 内执行）。
4.  `LowPriority` (4): 低优先级（10s 内执行）。
5.  `IdlePriority` (5): 空闲优先级（永不过期）。

## 3. 时间切片 (Time Slicing)
Scheduler 利用浏览器的 API 来实现任务的中断和恢复。

### 3.1 实现方式
*   **早期**：使用 `requestIdleCallback`。但它兼容性差，且触发频率不稳定（依赖浏览器空闲）。
*   **现在**：使用 `MessageChannel` + `requestAnimationFrame` (polyfill) 模拟。
    *   React 默认分配 **5ms** 的时间片。
    *   如果在 5ms 内任务没做完，Scheduler 会中断任务，把控制权还给浏览器，让浏览器去绘制一帧。
    *   并在下一个宏任务中继续执行剩余任务。

### 3.2 shouldYield
判断是否需要让出主线程：
1.  当前时间 - 任务开始时间 > 5ms。
2.  有更高优先级的任务插队。

## 4. 模拟实现：简易调度器

```javascript
// 最小堆，存放任务
const taskQueue = [];
let isHostCallbackScheduled = false;

function scheduleCallback(priority, callback) {
  const startTime = getCurrentTime();
  const timeout = getTimeoutByPriority(priority);
  const expirationTime = startTime + timeout;
  
  const newTask = {
    callback,
    priority,
    startTime,
    expirationTime,
    sortIndex: expirationTime, // 排序依据
  };
  
  push(taskQueue, newTask);
  
  if (!isHostCallbackScheduled) {
    isHostCallbackScheduled = true;
    requestHostCallback(flushWork);
  }
}

// 模拟 MessageChannel
const channel = new MessageChannel();
const port = channel.port2;
channel.port1.onmessage = performWorkUntilDeadline;

function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  port.postMessage(null); // 触发宏任务
}
```

## 5. 常见问题
### Q: 为什么不用 setTimeout?
**A:** `setTimeout(fn, 0)` 即使设置为 0，在嵌套层级深时也会有 4ms 的最小延迟，对于高频调度来说太慢了。

### Q: 为什么不用 Generator?
**A:** Generator 虽然可以暂停函数执行，但它是有传染性的（async/await），需要重写整个架构。React 希望对现有代码侵入性最小，所以选择了在循环中手动检查时间的方式来实现“中断”。
