# Hooks 执行流程

React Hooks 在组件的不同生命周期（Mount 和 Update）会调用不同的调度器（Dispatcher）。

## 1. Dispatcher 切换
React 内部有两个主要的 Dispatcher 对象：
1.  `HooksDispatcherOnMount`：组件首次渲染时使用。
2.  `HooksDispatcherOnUpdate`：组件更新时使用。

```javascript
// 伪代码：React 内部根据阶段切换
ReactCurrentDispatcher.current = 
  currentFiber === null || currentFiber.memoizedState === null
    ? HooksDispatcherOnMount
    : HooksDispatcherOnUpdate;
```

## 2. Mount 阶段
在首次渲染时，主要任务是**初始化** Hook 节点并挂载到链表上。

以 `useState` 为例：
1.  创建 Hook 对象。
2.  初始化 `memoizedState`。
3.  创建更新队列 `queue`。
4.  绑定 `dispatch` 函数（即 setState）。

```javascript
function mountState(initialState) {
  const hook = mountWorkInProgressHook(); // 创建并挂载
  hook.memoizedState = initialState;
  
  const queue = { pending: null };
  hook.queue = queue;
  
  // 绑定 dispatch，预置 fiber 和 queue
  const dispatch = dispatchAction.bind(null, currentlyRenderingFiber, queue);
  return [hook.memoizedState, dispatch];
}
```

## 3. Update 阶段
在更新时，主要任务是**按顺序获取** Hook 节点，并计算新状态。

1.  移动指针找到对应的 Hook 节点。
2.  遍历 `queue` 中的 update，计算新 state。
3.  返回新 state 和 dispatch。

```javascript
function updateState(initialState) {
  const hook = updateWorkInProgressHook(); // 获取对应的旧 Hook
  const queue = hook.queue;
  
  let newState = hook.memoizedState;
  const pendingQueue = queue.pending;
  
  if (pendingQueue !== null) {
    // 遍历环形链表计算状态
    let firstUpdate = pendingQueue.next;
    let update = firstUpdate;
    do {
      const action = update.action;
      newState = typeof action === 'function' 
        ? action(newState) 
        : action;
      update = update.next;
    } while (update !== firstUpdate);
  }
  
  hook.memoizedState = newState;
  return [newState, dispatch];
}
```

## 4. dispatchAction 原理
当我们调用 `setState` (即 dispatchAction) 时：
1.  创建 update 对象。
2.  将 update 插入到 queue 环形链表中。
3.  **触发调度**（`scheduleUpdateOnFiber`），请求重新渲染。

```javascript
function dispatchAction(fiber, queue, action) {
  const update = {
    action,
    next: null
  };
  
  // 入队逻辑（环形链表）
  // ...
  
  scheduleUpdateOnFiber(fiber);
}
```

## 5. 常见问题
### Q: 为什么 useState 可以接受函数？
**A:** 为了支持根据前一个状态计算新状态（`setCount(c => c + 1)`）。在 `updateState` 中会判断 `action` 类型，如果是函数则执行 `action(prevState)`。

### Q: 为什么 useEffect 的依赖数组是浅比较？
**A:** 在 `updateEffect` 中，React 会对比新旧依赖数组。它使用 `Object.is` 遍历比较数组中的每一项。只要有一项不同，就认为依赖变了，需要执行 Effect。
