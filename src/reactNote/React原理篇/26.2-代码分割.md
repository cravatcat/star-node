# 代码分割 (Code Splitting)

代码分割是现代前端应用性能优化的关键，它通过将 bundle 拆分成更小的 chunk，实现按需加载，显著降低首屏加载时间（FCP/LCP）。

## 1. React.lazy 原理
`React.lazy` 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。

### 1.1 使用方式
```javascript
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </Suspense>
  );
}
```

### 1.2 实现原理
`React.lazy` 返回一个 LazyComponent 对象。

1.  **初始化**：状态为 `Uninitialized` (-1)。
2.  **首次渲染**：
    *   执行 `ctor` (即 `() => import(...)`)。
    *   抛出一个 Promise（这与 Suspense 机制配合）。
    *   状态变为 `Pending` (0)。
3.  **Promise Resolve**：
    *   模块加载成功。
    *   状态变为 `Resolved` (1)。
    *   结果存储在 `result` 中（即组件模块）。
4.  **再次渲染**：
    *   直接返回 `result.default`（加载好的组件）。

```javascript
function lazy(ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: {
      _status: -1,
      _result: ctor,
    },
    _init: lazyInitializer,
  };
}
```

## 2. 路由级分割
最常见的分割策略是基于路由。
使用 `React Router` + `React.lazy` + `Suspense`。

```javascript
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
);
```

**原理**：Webpack 等打包工具识别到 `import()` 语法时，会自动创建一个新的 chunk 文件。当路由切换匹配到该组件时，浏览器发起网络请求加载该 JS 文件。

## 3. 组件级分割
对于大型组件（如富文本编辑器、复杂图表），也可以单独分割。
只有当用户通过交互（如点击按钮打开弹窗）需要显示该组件时，才去加载。

## 4. 常见问题
### Q: 动态 import 失败怎么办？
**A:** 使用 `ErrorBoundary` 包裹 `Suspense`。如果网络请求失败，`lazy` 返回的 Promise 会 reject，错误会被 ErrorBoundary 捕获，展示错误 UI（如重试按钮）。

### Q: 为什么 Suspense 必须配合 lazy 使用？
**A:** `React.lazy` 是数据的生产者（抛出 Promise），`Suspense` 是消费者（捕获 Promise 并展示 Fallback）。它们是 React 并发模式下异步数据流处理的一套组合拳。
