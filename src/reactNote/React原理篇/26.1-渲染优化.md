# 渲染优化原理

React 的渲染性能优化主要围绕“减少不必要的渲染”和“加速渲染过程”展开。

## 1. Bailout 策略 (跳过渲染)
在 React 的 Render 阶段，在处理每个 Fiber 节点之前，会先检查是否可以跳过（Bailout）。

### 1.1 触发条件
必须同时满足以下条件，React 才会复用旧节点（Clone current fiber）并跳过子树的渲染：
1.  **Props 相等**：`oldProps === newProps` (全等比较)。
2.  **Context 未变化**：Legacy Context 或 New Context 均未变。
3.  **Type 未变化**：组件类型没变。
4.  **无更新**：当前节点及子树没有待处理的 Update (Lanes 为空)。

### 1.2 强制 Bailout
*   **Class 组件**：`shouldComponentUpdate` 返回 false，或继承 `PureComponent`（自动浅比较 props 和 state）。
*   **Function 组件**：使用 `React.memo` 包裹（自动浅比较 props）。

## 2. React.memo 原理
`React.memo` 是一个高阶组件（HOC），它返回一个新的组件类型 `MemoComponent`。

在 Render 阶段处理 `MemoComponent` 时：
1.  React 会对新旧 props 进行浅比较（Shallow Compare）。
2.  如果 props 没变，且 ref 没变，且没有 state 更新，则直接 Bailout，跳过函数执行。

```javascript
function updateMemoComponent(current, workInProgress, Component, nextProps) {
  const prevProps = current.memoizedProps;
  
  if (shallowEqual(prevProps, nextProps)) {
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }
  
  // props 变了，正常渲染
  const newChild = createFunctionComponent(Component, nextProps);
  reconcileChildren(current, workInProgress, newChild);
  return workInProgress.child;
}
```

## 3. useMemo & useCallback 原理
这两个 Hook 并不是为了阻止当前组件渲染，而是为了**保持引用稳定性**，从而配合子组件的 `React.memo` 生效。

*   **useMemo**：缓存计算结果。只有依赖变了才重新计算。
*   **useCallback**：缓存函数引用。
    *   原理：`useCallback(fn, deps)` 等价于 `useMemo(() => fn, deps)`。

如果不使用 useCallback，每次父组件渲染都会创建新的函数引用。如果这个函数作为 prop 传给被 `React.memo` 包裹的子组件，会导致子组件的浅比较失败，从而导致不必要的重渲染。

## 4. 状态下放 (State Colocation)
一种不需要 `memo` 的优化技巧。
将频繁变化的状态（如 input 输入）下放到独立的子组件中，这样状态更新只会触发该子组件渲染，而不会影响父组件和其他兄弟组件。

## 5. 常见问题
### Q: 为什么不默认给所有组件加上 React.memo？
**A:**
1.  **比较成本**：浅比较 props 需要遍历对象属性，这也是有开销的。如果组件本身渲染很快，或者 props 经常变，比较的开销反而比直接渲染还大。
2.  **内存占用**：Memo 需要保存旧的 props 以便比较。
3.  **最佳实践**：只在组件树较大、且 Props 更新不频繁的组件上使用。
