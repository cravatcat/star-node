# 并发渲染 (Concurrent Rendering)

并发渲染是 React 18 的核心特性，它允许 React 同时准备多个版本的 UI，即“**可中断渲染**”。

## 1. 核心概念
*   **同步渲染 (Sync)**：一旦开始渲染，必须直到完成，不可中断。
*   **并发渲染 (Concurrent)**：渲染过程可以被中断，让出主线程给高优先级任务，之后再恢复。

## 2. 实现机制

### 2.1 时间切片 (Time Slicing)
将长任务拆分成多个时间片（默认 5ms）。每处理完一个 Fiber 节点，检查时间是否用完。

### 2.2 优先级 (Lane 模型)
React 使用二进制位掩码（Bitmask）表示优先级。
*   `SyncLane` (1): 同步更新
*   `InputContinuousLane`: 连续输入（拖拽）
*   `DefaultLane`: 默认优先级（请求数据）
*   `IdleLane`: 空闲优先级

### 2.3 双缓冲 + 优先级
高优先级任务可以打断低优先级任务的渲染。被打断的低优先级 workInProgress 树会被丢弃，等高优先级完成后重新开始（Rebase）。

## 3. 关键特性

### 3.1 useTransition
将某些更新标记为低优先级（Transition），允许 UI 保持响应。

```javascript
const [isPending, startTransition] = useTransition();

function handleClick() {
  // 高优先级：立即更新输入框
  setInputValue(input);
  
  startTransition(() => {
    // 低优先级：更新列表（可能很耗时）
    setList(newList);
  });
}
```

### 3.2 Suspense
允许组件在渲染时“等待”某些异步操作（如数据获取）。
1.  组件抛出 Promise。
2.  React 捕获 Promise（像 Catch Error 一样）。
3.  渲染 Fallback UI。
4.  Promise Resolve 后，重新渲染组件。

### 3.3 useDeferredValue
延迟更新某个值，类似于防抖/节流，但基于渲染优先级。

## 4. 模拟实现：可中断渲染

```javascript
function workLoop(deadline) {
  let shouldYield = false;
  
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    // 检查剩余时间
    shouldYield = deadline.timeRemaining() < 1;
  }

  if (nextUnitOfWork) {
    requestIdleCallback(workLoop);
  }
}
```

## 5. 常见问题
### Q: 并发模式一定更快吗？
**A:** 不一定。并发模式增加了调度的开销，对于简单的应用，绝对性能可能略低。但它极大地提升了**用户体验**（响应性），让应用感觉更流畅，不会因为重计算而阻塞交互。

### Q: 什么是 Tearing（撕裂）？
**A:** 当 UI 的不同部分显示了不一致的数据状态时（比如一个列表，上半部分是新数据，下半部分是旧数据）。React 18 的 `useSyncExternalStore` 就是为了解决并发渲染下的 tearing 问题。
