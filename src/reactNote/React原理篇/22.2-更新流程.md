# 更新流程

React 的更新流程始于状态变化（State Change），终于视图更新（View Update）。

## 1. 触发更新的方式
*   **this.setState** (Class Component)
*   **useState / useReducer dispatch** (Function Component)
*   **ReactDOM.render** (再次调用)
*   **forceUpdate**

## 2. 调度更新 (Schedule)
当状态改变时，React 不会立即更新，而是创建一个 Update 对象，并将其加入到 Fiber 的更新队列（UpdateQueue）中，然后通知调度器（Scheduler）调度一次更新。

```javascript
const update = {
  eventTime,
  lane,           // 优先级
  payload: null,  // 更新内容 (setState 的参数)
  callback: null, // setState 的回调
  next: null      // 指向下一个 update
};
```

### 2.1 批量更新 (Batching)
在 React 18 之前，只有事件处理函数中的更新会自动批处理。在 React 18 中，**自动批处理（Automatic Batching）** 覆盖了所有场景（Promise, setTimeout, Native Events）。
*   原理：通过变量锁（isBatchingUpdates）控制，在微任务结束时统一执行更新。

## 3. 协调阶段 (Reconciliation)
调度器允许执行后，进入 Render 阶段。
1.  **Clone Fiber**：复用 Current 树的 Fiber 节点创建 WorkInProgress 节点。
2.  **Process UpdateQueue**：计算新 State。
3.  **Diff**：对比新旧 Props 和 Children。
    *   如果没变（bailout），复用子树。
    *   如果变了，打上 EffectTag（Update, Placement, Deletion）。

## 4. Commit 阶段
与首次渲染类似，但只处理有 EffectTag 的节点。

## 5. 模拟实现：更新队列

```javascript
// 环形链表结构
function enqueueUpdate(fiber, update) {
  const updateQueue = fiber.updateQueue;
  const pending = updateQueue.shared.pending;
  
  if (pending === null) {
    // 第一个更新，自己指向自己
    update.next = update;
  } else {
    // 插入到链表尾部
    update.next = pending.next;
    pending.next = update;
  }
  // pending 指向最后一个更新
  updateQueue.shared.pending = update;
}

// 处理更新队列
function processUpdateQueue(workInProgress, props, workInProgressRootRenderLanes) {
  const queue = workInProgress.updateQueue;
  let firstBaseUpdate = queue.firstBaseUpdate;
  let lastBaseUpdate = queue.lastBaseUpdate;
  
  let pendingQueue = queue.shared.pending;
  if (pendingQueue !== null) {
    // 剪断环形链表，拼接到 baseQueue 后面
    queue.shared.pending = null;
    const lastPendingUpdate = pendingQueue;
    const firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    
    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }
    lastBaseUpdate = lastPendingUpdate;
  }
  
  // ... 遍历链表计算 state ...
}
```

## 6. 常见问题
### Q: setState 是同步还是异步？
**A:**
*   **表现上**：通常是异步的（为了批处理性能优化）。
*   **实现上**：是同步代码，只是 React 控制了执行时机。
*   **React 18**：总是异步批处理（除非用 `flushSync`）。
*   **React 17 及之前**：在 `setTimeout` 或原生事件中是同步的。

### Q: 为什么 hooks 中的 state 不需要 this？
**A:** 因为 state 保存在 Fiber 节点的 `memoizedState` 链表中，每次组件函数执行时，通过 hook 调用的顺序来获取对应的 state，利用了闭包和链表结构。
