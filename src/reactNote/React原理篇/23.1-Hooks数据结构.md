# Hooks 数据结构

Hooks 的核心魔力在于它如何将状态和副作用“挂载”到函数组件上。这依赖于 Fiber 节点上的一个链表结构。

## 1. Fiber 上的存储
每个 Fiber 节点（函数组件对应的）有一个 `memoizedState` 属性，它指向 Hooks 链表的头部。

```javascript
const fiber = {
  // ...
  memoizedState: null, // 指向第一个 Hook
  // ...
};
```

## 2. Hook 对象结构
链表中的每个 Hook 节点结构如下：

```javascript
const hook = {
  memoizedState: null, // 保存该 Hook 的状态 (state, effect, memo...)
  baseState: null,     // 基础状态
  baseQueue: null,     // 基础更新队列
  queue: null,         // 当前更新队列
  next: null,          // 指向下一个 Hook
};
```

*   `memoizedState`：
    *   `useState(value)`: 存 value。
    *   `useEffect(create, deps)`: 存 effect 对象。
    *   `useMemo(create, deps)`: 存 `[value, deps]`。
    *   `useRef(value)`: 存 `{current: value}`。

## 3. 链表结构示意图
假设组件代码如下：

```javascript
function App() {
  const [count, setCount] = useState(0);       // Hook 1
  const [text, setText] = useState('hello');   // Hook 2
  useEffect(() => {}, []);                     // Hook 3
}
```

对应的 Hooks 链表：

```
Fiber.memoizedState 
  ↓
[Hook 1 (count)] -> next 
  ↓
[Hook 2 (text)] -> next 
  ↓
[Hook 3 (Effect)] -> next -> null
```

## 4. 模拟实现：创建 Hook

```javascript
let workInProgressHook = null; // 当前正在处理的 Hook

function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };

  if (workInProgressHook === null) {
    // 这是链表中的第一个 Hook
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // 追加到链表末尾
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

## 5. 常见问题
### Q: 为什么 Hooks 不能在条件语句中使用？
**A:** 因为 React 完全依赖 Hooks 的**调用顺序**来将 Hook 对象与链表中的节点对应起来。
如果在条件语句中：
1.  Render 1: `useState(A) -> useState(B) -> useEffect(C)`
2.  Render 2 (条件变了): `useState(B) -> useEffect(C)`
React 会尝试把 `useState(B)` 的状态赋给第一个 Hook 节点（原本是 A 的位置），导致状态错乱。

### Q: 为什么 Hook 的状态不会在组件重渲染时丢失？
**A:** 状态保存在 Fiber 节点（堆内存）中，而不是函数作用域（栈内存）中。函数执行完出栈销毁，但 Fiber 树依然存在，下次渲染时会从 Fiber 中读取状态。
