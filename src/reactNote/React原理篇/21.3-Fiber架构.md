# Fiber 架构

Fiber 是 React 16 引入的新的协调引擎，核心目的是为了解决 React 15 在处理大量 DOM 节点时产生的卡顿问题，实现**可中断的异步渲染**。

## 1. 背景与问题
在 React 15 中，更新过程是同步且不可中断的（Stack Reconciler）。一旦开始渲染，React 会递归对比虚拟 DOM 树，直到完成。如果树很深，这个过程会占用主线程很长时间，导致页面掉帧、无法响应用户交互。

**解决方案**：将大任务拆分成多个小任务（Fiber），每执行完一个小任务，就让出主线程，如果有高优先级任务（如用户输入），优先处理。

## 2. Fiber 核心概念

### 2.1 什么是 Fiber
1.  **架构层面**：一种新的调度算法（Reconciler）。
2.  **数据结构层面**：一个链表节点，保存了组件类型、DOM 节点、以及**关系指针**。
3.  **执行层面**：一个执行单元（Unit of Work）。

### 2.2 Fiber 节点结构
Fiber 使用链表结构代替了原来的递归树结构，使得遍历可以中断和恢复。

```javascript
function FiberNode(tag, pendingProps, key, mode) {
  // 实例属性
  this.tag = tag;           // 组件类型（Function/Class/Host...）
  this.key = key;
  this.type = null;         // 具体元素类型（'div', Comp...）
  this.stateNode = null;    // 对应的真实 DOM

  // 链表结构（关系指针）
  this.return = null;       // 指向父节点
  this.child = null;        // 指向第一个子节点
  this.sibling = null;      // 指向下一个兄弟节点
  this.index = 0;

  // 工作单元
  this.pendingProps = pendingProps;
  this.memoizedProps = null; // 上一次的 props
  this.memoizedState = null; // 上一次的 state (Hooks 链表在这里)
  this.updateQueue = null;   // 更新队列

  // 副作用
  this.flags = NoFlags;      // 也就是 effectTag (增/删/改)
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  // 双缓冲
  this.alternate = null;     // 指向另一棵树对应的 Fiber
}
```

## 3. 工作原理

### 3.1 双缓冲技术 (Double Buffering)
React 维护两棵 Fiber 树：
1.  **Current Tree**：当前屏幕上显示的树。
2.  **WorkInProgress Tree**：正在内存中构建的树。

更新时，React 在 WorkInProgress 树上进行计算，完成后直接将 Current 指针指向 WorkInProgress 树，实现快速切换。

### 3.2 两个阶段
Fiber 架构将渲染过程分为两个阶段：

1.  **Render 阶段（可中断）**
    *   遍历 Fiber 树，找出需要更新的节点。
    *   构建 WorkInProgress 树。
    *   打上 EffectTag（标记增删改）。
    *   **可以被高优先级任务打断**。

2.  **Commit 阶段（不可中断）**
    *   一次性将所有变更提交到真实 DOM。
    *   执行生命周期和 Hooks（componentDidMount, useEffect）。

## 4. 模拟实现：简易 Fiber 调度

```javascript
let nextUnitOfWork = null;
let wipRoot = null;

function workLoop(deadline) {
  // 当有任务且有空闲时间时
  while (nextUnitOfWork && deadline.timeRemaining() > 1) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }

  // 任务还没做完，请求下一帧继续
  if (nextUnitOfWork) {
    requestIdleCallback(workLoop);
  } else if (wipRoot) {
    // Render 阶段结束，进入 Commit 阶段
    commitRoot();
  }
}

// 处理单个 Fiber 节点
function performUnitOfWork(fiber) {
  // 1. 处理当前组件（创建 DOM，协调子节点）
  // ... logic ...

  // 2. 返回下一个任务（深度优先遍历）
  if (fiber.child) return fiber.child;
  
  let nextFiber = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) return nextFiber.sibling;
    nextFiber = nextFiber.return;
  }
  return null;
}

// 启动
requestIdleCallback(workLoop);
```

## 5. 常见问题
### Q: Fiber 如何实现可中断？
**A:** 通过 `requestIdleCallback`（React 实现了自己的 Scheduler）获取浏览器空闲时间。在循环执行任务时，检查剩余时间，如果时间不够就保存当前状态（`nextUnitOfWork`），退出循环，把控制权还给浏览器。

### Q: 为什么 Commit 阶段不可中断？
**A:** Commit 阶段涉及真实 DOM 的操作，如果中断会导致 UI 显示不一致（如页面只更新了一半），为了保证视图的一致性，必须同步完成。
