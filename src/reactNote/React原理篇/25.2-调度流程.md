# 调度流程

Scheduler 的核心工作流程是一个**生产-消费**模型：React 生产任务，Scheduler 消费任务。

## 1. 任务队列
Scheduler 维护了两个优先队列（最小堆）：
1.  **timerQueue**：未到开始时间的延时任务。
2.  **taskQueue**：已就绪、待执行的任务。

## 2. 主循环 (WorkLoop)
当 Scheduler 被唤醒（requestHostCallback）时，会执行 `workLoop`。

### 流程步骤
1.  **转移任务**：检查 `timerQueue`，将所有已过期的任务（startTime <= currentTime）移动到 `taskQueue`。
2.  **取出任务**：从 `taskQueue` 取出优先级最高的任务（堆顶）。
3.  **执行任务**：
    *   如果任务被取消，跳过。
    *   执行任务回调 `callback`。
    *   **检查返回值**：
        *   如果 `callback` 返回了一个函数，说明任务没做完（被中断），将该函数作为新回调更新当前任务，保留在队列中。
        *   如果返回 null，说明任务完成，从队列移除。
4.  **检查时间**：每执行完一个任务，调用 `shouldYieldToHost` 检查 5ms 时间片是否用完。
    *   如果用完，停止循环，返回 `true`（表示还有任务没做完）。
    *   如果没用完，继续取下一个任务。
5.  **后续处理**：
    *   如果 `workLoop` 返回 true，Scheduler 会在下一个宏任务中再次调度自己。
    *   如果 `taskQueue` 空了，检查 `timerQueue` 最早的任务，设置定时器等待唤醒。

## 3. 模拟实现：工作循环

```javascript
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  advanceTimers(currentTime); // timerQueue -> taskQueue
  
  let currentTask = peek(taskQueue);
  
  while (currentTask !== null) {
    // 如果任务没过期，且时间片用完了，中断退出
    if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {
      break;
    }
    
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      currentTask.callback = null;
      const priorityLevel = currentTask.priorityLevel;
      
      // 执行 React 的 render 阶段
      // 如果时间片用完，render 会返回一个 continuation 函数
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      const continuationCallback = callback(didUserCallbackTimeout);
      
      currentTime = getCurrentTime();
      
      if (typeof continuationCallback === 'function') {
        // 任务未完成，恢复 callback，下次继续
        currentTask.callback = continuationCallback;
      } else {
        // 任务完成，移出队列
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }
      
      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }
    
    currentTask = peek(taskQueue);
  }
  
  // 返回是否还有剩余任务
  if (currentTask !== null) {
    return true;
  } else {
    // 如果 taskQueue 空了，看看 timerQueue
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
```

## 4. 常见问题
### Q: 任务如何被中断？
**A:** 在 `workLoop` 中，每次循环都会检查 `shouldYieldToHost()`。如果时间到了，`break` 跳出循环。此时 `currentTask` 还在队列堆顶。Scheduler 退出当前宏任务，等待下一个宏任务再次进入 `workLoop`，继续从堆顶取出任务执行。

### Q: 任务如何恢复？
**A:** React 的 `render` 阶段在设计时就是可中断的。它通过 `performUnitOfWork` 遍历 Fiber 树。中断时，`workInProgress` 节点被保存在全局变量中。下次恢复时，直接从这个节点继续处理即可。
