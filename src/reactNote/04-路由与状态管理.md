# 第四部分：路由与状态管理

## 第18章：React Router

### 18.1 路由基础 🌟

> 📄 **详细内容**：[18.1-路由基础.md](./路由与状态管理/18.1-路由基础.md)

- [x] **前端路由原理**
  - Hash 模式：监听 hashchange 事件
  - History 模式：pushState + popstate
  - 模拟实现：简易前端路由
- [x] **BrowserRouter vs HashRouter**
  - BrowserRouter：history API，需要服务器配置
  - HashRouter：# 锚点，无需服务器配置
- [x] **常见问题**：两种模式区别、SEO 影响

### 18.2 核心组件 🌟

> 📄 **详细内容**：[18.2-核心组件.md](./路由与状态管理/18.2-核心组件.md)

- [x] **Router 组件**
  - 实现思路：Context 传递 location + navigate
  - 模拟实现：手写 Router（监听路由变化）
- [x] **Route 组件**
  - 实现思路：path-to-regexp 路径匹配
  - 模拟实现：手写 Route（匹配后渲染）
- [x] **Link 组件**
  - 实现思路：preventDefault + pushState
  - 模拟实现：手写 Link
- [x] **Navigate 组件**
  - 实现思路：useEffect + navigate
  - 模拟实现：重定向组件

### 18.3 Hooks API 🌟

> 📄 **详细内容**：[18.3-HooksAPI.md](./路由与状态管理/18.3-HooksAPI.md)

- [x] **useNavigate**
  - 实现思路：useContext 获取 navigate 函数
  - 模拟实现：编程式导航
- [x] **useParams**
  - 实现思路：解析路径参数（:id）
  - 模拟实现：提取动态参数
- [x] **useLocation**
  - 实现思路：useContext 获取 location
  - 模拟实现：获取当前路由信息
- [x] **useSearchParams**
  - 实现思路：URLSearchParams 管理查询参数
  - 模拟实现：查询参数读写
- [x] **useMatch**
  - 实现思路：matchPath 检测路径匹配
  - 模拟实现：路径匹配检测

### 18.4 高级特性 ⭐

> 📄 **详细内容**：[18.4-高级特性.md](./路由与状态管理/18.4-高级特性.md)

- [x] **嵌套路由**
  - 实现思路：Outlet 组件 + 路由树
  - 模拟实现：嵌套路由系统
  - 使用场景：布局嵌套、多级导航
- [x] **路由守卫**
  - 实现思路：权限检查 + Navigate 重定向
  - 模拟实现：ProtectedRoute 组件
  - 使用场景：登录验证、权限控制
- [x] **懒加载路由**
  - 实现思路：React.lazy + Suspense
  - 模拟实现：代码分割路由
  - 使用场景：首屏优化、按需加载
- [x] **路由过渡动画**
  - 实现思路：结合 framer-motion
  - 模拟实现：路由切换动画
  - 使用场景：提升用户体验

### 18.5 路由最佳实践 💡

> 📄 **详细内容**：[18.5-路由最佳实践.md](./路由与状态管理/18.5-路由最佳实践.md)

- [x] **路由配置化**：useRoutes 集中管理
- [x] **路由权限管理**：角色权限控制
- [x] **路由状态持久化**：保存滚动位置
- [x] **SEO 优化**：React Helmet、预渲染

---

## 第19章：Zustand

### 19.1 Zustand 基础 🌟

> 📄 **详细内容**：[19.1-Zustand基础.md](./路由与状态管理/19.1-Zustand基础.md)

- [x] **Zustand 原理**
  - 实现思路：发布订阅 + useSyncExternalStore
  - 模拟实现：简易 Zustand（create + subscribe）
- [x] **create 函数**
  - 实现思路：创建 store + 返回 hook
  - 模拟实现：手写 create
- [x] **状态订阅机制**
  - 实现思路：listeners 数组 + notify
  - 模拟实现：subscribe 系统
- [x] **常见问题**：vs Redux、vs Context

### 19.2 核心 API 🌟

> 📄 **详细内容**：[19.2-核心API.md](./路由与状态管理/19.2-核心API.md)

- [x] **set 函数**
  - 实现思路：更新状态 + 通知订阅者
  - 模拟实现：setState + notify
  - 支持函数式更新：set(state => ({ count: state.count + 1 }))
- [x] **get 函数**
  - 实现思路：获取当前状态快照
  - 模拟实现：getState
  - 使用场景：在 actions 中获取最新状态
- [x] **subscribe**
  - 实现思路：添加订阅者 + 返回取消订阅函数
  - 模拟实现：订阅管理
  - 使用场景：监听状态变化

### 19.3 中间件 ⭐

> 📄 **详细内容**：[19.3-中间件.md](./路由与状态管理/19.3-中间件.md)

- [x] **persist 中间件**
  - 实现思路：localStorage 持久化
  - 模拟实现：persist(config, { name: 'storage-key' })
  - 配置项：name、storage、partialize
- [x] **immer 中间件**
  - 实现思路：集成 Immer 不可变更新
  - 模拟实现：immer(config)
  - 使用场景：简化复杂状态更新
- [x] **devtools 中间件**
  - 实现思路：Redux DevTools 集成
  - 模拟实现：devtools(config, { name: 'MyStore' })
  - 使用场景：调试状态变化
- [x] **自定义中间件**
  - 实现思路：中间件模式（洋葱模型）
  - 模拟实现：logger 中间件
  - 使用场景：日志、性能监控

### 19.4 高级用法 💡

> 📄 **详细内容**：[19.4-高级用法.md](./路由与状态管理/19.4-高级用法.md)

- [x] **切片模式（Slices）**
  - 实现思路：模块化状态管理
  - 模拟实现：多 slice 组合
  - 使用场景：复杂 Store 拆分
- [x] **选择器优化**
  - 实现思路：shallow 浅比较避免重渲染
  - 模拟实现：useStore(selector, shallow)
  - 使用场景：只订阅部分状态
- [x] **异步 Actions**
  - 实现思路：在 actions 中处理异步逻辑
  - 模拟实现：异步状态管理
- [x] **计算属性**
  - 实现思路：在 selector 中计算
  - 使用场景：派生状态

### 19.5 Zustand vs 其他方案 💡

> 📄 **详细内容**：[19.5-Zustand对比.md](./路由与状态管理/19.5-Zustand对比.md)

- [x] **vs Redux**
  - Zustand：更简单、无 boilerplate、更小体积
  - Redux：生态更丰富、中间件更强大
- [x] **vs Context**
  - Zustand：性能更好、无 Provider 嵌套
  - Context：React 内置、适合简单场景
- [x] **vs Jotai/Recoil**
  - Zustand：中心化状态管理
  - Jotai/Recoil：原子化状态管理

---

## 第20章：其他状态管理方案

### 20.1 Redux Toolkit 🌟

> 📄 **详细内容**：[20.1-ReduxToolkit.md](./路由与状态管理/20.1-ReduxToolkit.md)

- [x] **Redux 核心原理**
  - 实现思路：单一数据源 + reducer + action
  - 模拟实现：简易 Redux（createStore、dispatch、subscribe）
  - 三大原则：单一数据源、只读状态、纯函数修改
- [x] **Redux Toolkit 简化**
  - configureStore：自动配置（thunk、devtools）
  - createSlice：自动生成 actions 和 reducer
  - createAsyncThunk：异步处理
- [x] **使用示例**
- [x] **常见问题**：Redux 数据流、中间件原理

### 20.2 Jotai ⭐

> 📄 **详细内容**：[20.2-Jotai.md](./路由与状态管理/20.2-Jotai.md)

- [x] **原子化状态管理**
  - 实现思路：atom 模式，细粒度更新
  - 模拟实现：简易 Jotai（atom + useAtom）
- [x] **核心概念**
  - atom：最小状态单元
  - useAtom：读写 atom
  - 派生 atom：computed
- [x] **使用示例**
- [x] **常见问题**：vs Zustand、原子化优势

### 20.3 Recoil ⭐

> 📄 **详细内容**：[20.3-Recoil.md](./路由与状态管理/20.3-Recoil.md)

- [x] **Recoil 原理**
  - 实现思路：atom + selector 依赖图
  - 模拟实现：简易 Recoil
- [x] **核心概念**
  - atom：状态单元
  - selector：派生状态
  - 依赖追踪：自动更新
- [x] **使用示例**
- [x] **常见问题**：vs Jotai、Facebook 出品

### 20.4 状态管理方案选择 💡

> 📄 **详细内容**：[20.4-状态管理选择.md](./路由与状态管理/20.4-状态管理选择.md)

- [x] **简单应用**：Context + useReducer
- [x] **中型应用**：Zustand
- [x] **大型应用**：Redux Toolkit
- [x] **原子化需求**：Jotai / Recoil
- [x] **选择标准**
  - 团队熟悉度
  - 项目复杂度
  - 性能要求
  - 生态支持
