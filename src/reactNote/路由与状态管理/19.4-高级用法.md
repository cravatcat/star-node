# 19.4 高级用法


## 1. 切片模式 (Slices)

将大的 Store 拆分为多个小的 Slice，便于维护。

```javascript
// createBearSlice.js
export const createBearSlice = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
})

// createFishSlice.js
export const createFishSlice = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
})

// store.js
import { create } from 'zustand'
import { createBearSlice } from './createBearSlice'
import { createFishSlice } from './createFishSlice'

const useBoundStore = create((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
}))
```

## 2. 选择器优化 (Selector)

默认使用 `Object.is` 比较，可以通过 selector 减少重渲染。

```javascript
// 只有当 bears 变化时才重渲染
const bears = useStore((state) => state.bears);

// 如果返回对象，默认会每次都生成新引用导致重渲染
// 解决方案 1: 拆分多个 hooks
const bears = useStore(state => state.bears)
const fish = useStore(state => state.fish)

// 解决方案 2: 使用 shallow
import { shallow } from 'zustand/shallow';
const { bears, fish } = useStore(state => ({ bears: state.bears, fish: state.fish }), shallow);
```

## 3. 异步 Actions

Zustand 对异步操作没有特殊处理，直接在函数中 `await` 即可。

```javascript
const useStore = create((set) => ({
  data: null,
  loading: false,
  fetchData: async () => {
    set({ loading: true });
    try {
      const response = await fetch('/api/data');
      const data = await response.json();
      set({ data, loading: false });
    } catch (e) {
      set({ loading: false });
    }
  }
}))
```
