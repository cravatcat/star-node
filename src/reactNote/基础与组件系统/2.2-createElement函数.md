# 2.2 createElement 函数

## 1. 概念讲解

`React.createElement` 是 React 核心 API 之一，用于创建 **React 元素 (React Element)**。
React 元素是一个轻量级的 JavaScript 对象，描述了我们希望在屏幕上看到的内容（即 **虚拟 DOM**）。

当我们编写 JSX 时：

```jsx
<div id="app">Hello</div>
```

Babel 会将其编译为：

```javascript
React.createElement('div', { id: 'app' }, 'Hello');
```

## 2. 实现思路

`createElement` 函数的主要任务是规范化数据结构。它接收三个主要参数：

1. **type**: 标签名（字符串，如 `'div'`）或组件（函数/类）。
2. **config**: 属性对象（props），包含 className, id, style 等。
3. **children**: 子节点，可以是字符串、数字、其他 React 元素等。

函数的返回值是一个标准的 React Element 对象，通常结构如下：

```javascript
{
  type: 'div',
  props: {
    id: 'app',
    children: 'Hello'
  },
  key: null,
  ref: null,
  // ...其他内部属性
}
```

## 3. 模拟实现：手写 createElement

我们将实现一个简化版的 `createElement`，忽略 ref 和 key 的复杂处理，专注于 props 和 children 的组合。

```javascript
/**
 * 创建虚拟 DOM 对象
 * @param {string | Function} type - 标签名或组件函数
 * @param {object | null} config - 属性对象
 * @param {...any} children - 子节点列表
 */
function createElement(type, config, ...children) {
  // 1. 初始化 props，移除 null/undefined
  const props = {};
  
  if (config != null) {
    // 过滤掉保留属性（如 key, ref, __self, __source）
    // 这里简化处理，直接复制所有属性
    for (let propName in config) {
       // 在真实 React 中，会过滤 key 和 ref
       if (Object.prototype.hasOwnProperty.call(config, propName)) {
         props[propName] = config[propName];
       }
    }
  }

  // 2. 处理 children
  // 如果有多个参数，children 是一个数组
  // 如果只有一个参数，children 是该元素本身
  const childrenLength = children.length;
  
  if (childrenLength === 1) {
    props.children = children[0];
  } else if (childrenLength > 1) {
    props.children = children;
  }

  // 3. 处理 defaultProps (针对类组件或函数组件)
  if (type && type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (let propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  // 4. 返回 React Element 对象
  return {
    type,
    props,
    // 在 React 源码中，$$typeof 用于安全检测，防止 XSS
    $$typeof: Symbol.for('react.element'), 
  };
}

// --- 测试 ---

// 1. 创建简单 DOM 元素
const vdom = createElement(
  'div', 
  { id: 'container', className: 'box' }, 
  createElement('h1', null, 'Hello World'),
  createElement('p', null, 'This is a paragraph')
);

console.log(JSON.stringify(vdom, null, 2));

/* 输出预期:
{
  "type": "div",
  "props": {
    "id": "container",
    "className": "box",
    "children": [
      {
        "type": "h1",
        "props": { "children": "Hello World" },
        "$$typeof": "Symbol(react.element)"
      },
      {
        "type": "p",
        "props": { "children": "This is a paragraph" },
        "$$typeof": "Symbol(react.element)"
      }
    ]
  },
  "$$typeof": "Symbol(react.element)"
}
*/
```

## 4. 常见问题

### Q1: `createElement` 和 `cloneElement` 有什么区别？

**答**：

* `createElement`: 用于**从头创建**一个新的 React 元素。通常用于 JSX 编译后的结果。
* `cloneElement`: 用于**复制**一个已有的 React 元素，并可以修改其 props 或替换 children。常用于高阶组件或复合组件中，父组件需要向子组件注入额外 props 时。

### Q2: React 17 之前的 JSX 转换和 React 17+ 有什么不同？

**答**：

* **React 16 及以前**: JSX 编译为 `React.createElement(...)`。这意味着你的代码中必须包含 `import React from 'react'`，否则会报错 `React is not defined`。
* **React 17+**: 引入了新的 JSX Transform。JSX 编译为 `import { jsx as _jsx } from 'react/jsx-runtime'; _jsx(...)`。编译器会自动引入运行时函数，因此不再需要手动 `import React`。

### Q3: 为什么 React Element 需要 `$$typeof` 属性？

**答**：
这是一个安全机制，用于防止 **XSS (跨站脚本攻击)**。
`$$typeof` 的值是一个 Symbol (`Symbol.for('react.element')`)。由于 JSON 不支持 Symbol，如果服务器端返回了一个恶意的 JSON 对象伪装成 React Element，React 在渲染时会检查 `$$typeof`。如果该属性缺失或不是预期的 Symbol，React 会拒绝渲染它，从而防止恶意代码注入。
