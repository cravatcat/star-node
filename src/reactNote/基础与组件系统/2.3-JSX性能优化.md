# 2.3 JSX 性能优化

## 1. 概念讲解

在 React 中，`render` 函数（或函数组件本身）每次重新渲染时都会运行。这意味着默认情况下，JSX 中定义的每一个 React Element 对象都会被重新创建。

**编译时优化 (Compile-time Optimization)** 的目标是在构建阶段分析代码，找出那些在多次渲染之间不会改变的部分（**静态节点**），并将它们**提升 (Hoist)** 到渲染函数之外。这样，在后续渲染中就可以直接复用同一个对象引用，从而减轻垃圾回收压力，并帮助 Diff 算法快速跳过无需比对的子树。

*注意：传统的 React（使用 Babel 转换）主要依赖运行时优化。但随着 **React Compiler (React Forget)** 的推出，React 也开始深度利用编译时优化。相比之下，Vue 等框架早就内置了静态提升等优化。*

## 2. 实现思路：静态节点提升与常量折叠

### 场景分析

```jsx
function App() {
  return (
    <div>
      <header>
        <h1>Logo</h1> {/* 永远不变的静态内容 */}
      </header>
      <Content />
    </div>
  );
}
```

### 未优化 (Standard)

每次运行 `App()`，都会执行 `React.createElement('header', ...)`，生成新的对象。

### 优化后 (Hoisted)

将静态部分提取到函数外部：

```javascript
const _hoisted_header = React.createElement('header', null, 
  React.createElement('h1', null, 'Logo')
);

function App() {
  return React.createElement('div', null, 
    _hoisted_header, // 直接复用引用
    React.createElement(Content)
  );
}
```

## 3. 模拟实现：静态节点标记与复用

虽然我们不能在运行时轻易实现编译器行为，但我们可以模拟“提升”的效果，并验证其性能收益（主要是引用相等性）。

```javascript
// 1. 模拟 React.createElement
function createElement(type, props, ...children) {
  return { type, props, children };
}

// 2. 模拟未优化的组件渲染
function AppStandard() {
  return createElement('div', { id: 'app' },
    createElement('h1', null, 'Static Title'), // 每次都是新对象
    createElement('p', null, Math.random())    // 动态内容
  );
}

// 3. 模拟经过“静态提升”优化的组件
// 编译器发现这个 h1 不依赖任何变量，将其提取出来
const _hoisted_h1 = createElement('h1', null, 'Static Title');

function AppOptimized() {
  return createElement('div', { id: 'app' },
    _hoisted_h1, // 复用同一个对象引用
    createElement('p', null, Math.random())
  );
}

// --- 验证 ---

console.log('--- Standard ---');
const vdom1 = AppStandard();
const vdom2 = AppStandard();
// 检查静态部分的引用是否相同
console.log('Static part is same reference?', vdom1.children[0] === vdom2.children[0]); // false

console.log('\n--- Optimized ---');
const vdomOpt1 = AppOptimized();
const vdomOpt2 = AppOptimized();
// 检查静态部分的引用是否相同
console.log('Static part is same reference?', vdomOpt1.children[0] === vdomOpt2.children[0]); // true

/* 
在真实的 React Diff 算法中，如果检测到 element === oldElement (引用相等)，
React 会直接跳过该子树的 Diff 过程，性能提升巨大。
*/
```

## 4. 常见问题

### Q1: 编译时优化 (Compile-time) vs 运行时优化 (Runtime) 有什么区别？

**答**：

* **运行时优化**：如 React 的 Virtual DOM Diff。代码在浏览器运行这一刻才进行计算和比对，灵活性高但有运行时开销。
* **编译时优化**：如 Svelte 或 React Compiler。在代码打包阶段就预先计算出依赖关系或将静态内容提取。**以空间换时间**，减少了运行时的计算量。

### Q2: React Compiler (React Forget) 解决了什么问题？

**答**：
它是一个自动化的 memoization 编译器。
在传统的 React 中，开发者需要手动使用 `useMemo` 和 `useCallback` 来缓存对象和函数，以避免不必要的子组件重渲染。这很容易出错且代码繁琐。
React Compiler 能够自动分析数据流，自动对组件和 Hooks 的依赖进行细粒度的缓存，让开发者不再需要手动写 `useMemo`。

### Q3: 在没有编译器优化的情况下，开发者如何手动优化静态内容？

**答**：
可以使用 `useMemo` 或将静态变量定义在组件函数外部。

```javascript
// 方法 1: 定义在外部
const staticStyle = { color: 'red' };

// 方法 2: useMemo
const staticContent = useMemo(() => <div>Static</div>, []);
```
