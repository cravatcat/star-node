# 3.6 异步组件 (Suspense & Lazy)

## 1. 概念讲解

在大型 React 应用中，打包文件往往会很大。为了优化性能，我们需要进行**代码分割 (Code Splitting)**。React 提供了 `React.lazy` 和 `Suspense` 来原生支持动态加载组件。

* **React.lazy**: 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。
* **Suspense**: 允许在子组件完成加载前展示后备方案 (Fallback) 界面（如 Loading）。
* **Error Boundary**: 既然是异步加载，就可能会失败（如网络断开）。错误边界用于捕获这些加载错误并展示友好的错误页面。

## 2. React.lazy

### 实现思路

`React.lazy` 接受一个函数，这个函数需要动态调用 `import()`。它返回一个组件，这个组件在首次渲染时会尝试读取模块。如果模块未加载，它会“挂起” (Suspend)，即抛出一个 Promise。

### 模拟实现

```javascript
function lazy(loadFn) {
  // 记录加载状态
  let status = 'pending';
  let result = null;

  const promise = loadFn().then(
    (module) => {
      status = 'success';
      result = module.default;
    },
    (error) => {
      status = 'error';
      result = error;
    }
  );

  // 返回一个组件
  return function LazyComponent(props) {
    if (status === 'success') {
      const Component = result;
      return <Component {...props} />;
    }
    if (status === 'error') {
      throw result; // 抛出错误让 ErrorBoundary 捕获
    }
    // 抛出 Promise 让 Suspense 捕获
    throw promise;
  };
}
```

## 3. Suspense

### 实现思路

`Suspense` 的核心原理利用了 React 的**错误捕获机制**。在 React 中，组件不仅可以抛出错误，还可以抛出 Promise。当 React 捕获到子组件抛出的 Promise 时，它会暂停渲染该子树，并显示 `fallback`，等待 Promise resolve 后重新尝试渲染。

### 模拟实现 (概念版)

虽然真实的 `Suspense` 涉及 Fiber 架构的底层调度，但我们可以用 `componentDidCatch` 来模拟其核心思想：**捕获 Promise -> 等待 -> 重新渲染**。

```javascript
class Suspense extends React.Component {
  state = {
    isLoading: false
  };

  componentDidCatch(error) {
    // 检查抛出的东西是不是一个 Promise (鸭子类型检测)
    if (error && typeof error.then === 'function') {
      this.setState({ isLoading: true });
      
      // 等待 Promise 完成
      error.then(() => {
        // Promise 完成后，恢复渲染子组件
        this.setState({ isLoading: false });
      });
    } else {
      // 如果是真错误，继续向上抛出或由 ErrorBoundary 处理
      throw error;
    }
  }

  render() {
    const { fallback, children } = this.props;
    const { isLoading } = this.state;

    if (isLoading) {
      return fallback;
    }

    return children;
  }
}
```

*注意：真实 React 中，Suspense 的机制比这复杂得多，且 `componentDidCatch` 实际上只捕获 Error，React 内部有专门处理 Throwing Promise 的逻辑。但这个模拟有助于理解“通过抛出异常来中断渲染”的设计模式。*

## 4. Error Boundary (错误边界)

### 实现思路

当 `React.lazy` 加载失败（网络错误或文件不存在）时，需要一个机制来兜底。Error Boundary 是唯一能捕获组件树中错误的组件。

### 模拟实现

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  // 1. 更新 state 以便下一次渲染显示降级 UI
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  // 2. 记录错误日志
  componentDidCatch(error, errorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

## 5. 常见问题

### Q1: React.lazy 为什么需要配合 Suspense 使用？

**答**：
`React.lazy` 加载的组件在首次渲染时，代码文件可能还没下载下来。此时组件无法立即返回 UI。为了不阻塞主线程或显示空白，React 设计为让该组件**抛出一个 Promise**。`Suspense` 组件位于父级，充当“Promise 捕获器”，当捕获到 Promise 时展示 Fallback，直到 Promise 解决。如果没有 `Suspense`，这个“异常”会导致应用崩溃。

### Q2: Suspense 只能用于懒加载组件吗？

**答**：
在 React 16/17 中，主要用于 `React.lazy`。但在 React 18+ 中，Suspense 的能力被大大扩展，支持**数据获取 (Data Fetching)**。配合支持 Suspense 的数据框架（如 Relay, Next.js, SWR 等），可以在数据请求过程中挂起组件，实现“Render-as-you-fetch”模式。

### Q3: 路由懒加载是怎么实现的？

**答**：
结合 `React-Router` 和 `React.lazy`。

```jsx
const Home = React.lazy(() => import('./routes/Home'));

<Suspense fallback={<Loading />}>
  <Routes>
    <Route path="/" element={<Home />} />
  </Routes>
</Suspense>
```

当路由匹配到 `/` 时，React 尝试渲染 `Home`，`Home` 抛出 Promise，`Suspense` 捕获并显示 `Loading`，网络请求完成，`Home` 重新渲染显示真实内容。
