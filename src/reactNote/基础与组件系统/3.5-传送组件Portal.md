# 3.5 传送组件 (Portal)

## 1. 概念讲解

Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

通常，当从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点：

```jsx
render() {
  // React 挂载了一个新的 div，并且把子元素渲染其中
  return (
    <div>
      {this.props.children}
    </div>
  );
}
```

然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的：

```jsx
render() {
  // React 并没有创建一个新的 div。它只是把子元素渲染到 `domNode` 中。
  // `domNode` 是一个有效的 DOM 节点，任何位置都可以。
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
```

一个典型的用例是当父组件有 `overflow: hidden` 或 `z-index` 样式时，但你需要子组件在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。

## 2. 实现思路

React 的 Portal 机制依赖于 `ReactDOM.createPortal(child, container)` API。

- **child**: 任何可渲染的 React 子元素（例如一个元素，字符串或 fragment）。
- **container**: 一个 DOM 元素。

### 核心特性

1. **DOM 结构脱离**: Portal 渲染的元素在 DOM 树中可以位于任何位置，不局限于父组件的 DOM 结构内。
2. **React 树保留**: 尽管在 DOM 树中位置不同，但在 React 组件树中，Portal 仍是其父组件的子节点。
3. **事件冒泡**: 由于 React 树的连续性，Portal 内部触发的事件会冒泡到 React 树中的祖先节点，即使这些祖先节点在 DOM 树中并不是 Portal 的父节点。

## 3. 模拟实现

虽然我们不能完全模拟 React Fiber 架构下的 Portal 实现，但我们可以模拟其核心行为：将组件渲染到指定 DOM 节点。

### 简易版 createPortal 模拟

```javascript
// 模拟 ReactDOM.createPortal
function createPortal(children, container) {
  // 在真实 React 中，这里会创建一个特殊的 Fiber 节点
  // 这里我们简单模拟挂载过程
  
  // 注意：这不是一个真实的 React 组件，而是一个挂载操作
  // 在实际应用中，我们需要一个组件来管理这个挂载
  return {
    type: 'PORTAL',
    children,
    container
  };
}

// 配合自定义渲染器使用 (伪代码)
function render(element, parentDOM) {
  if (element.type === 'PORTAL') {
    // 如果是 Portal，渲染到指定的 container，而不是 parentDOM
    render(element.children, element.container);
    return;
  }
  
  // 普通渲染逻辑...
}
```

### 自定义 Portal 组件封装 (Hook 风格)

使用 Hooks 封装一个通用的 Portal 组件，可以更灵活地管理 DOM 节点的创建与销毁。

```jsx
import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';

const ClientOnlyPortal = ({ children, selector }) => {
  // 1. 状态：标记组件是否已挂载 (解决 SSR 不匹配问题)
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  // 2. 获取目标 DOM 节点
  const container = selector 
    ? document.querySelector(selector) 
    : document.body;

  // 3. 如果未挂载或找不到容器，不渲染
  if (!mounted || !container) {
    return null;
  }

  // 4. 使用 createPortal 渲染子组件到容器中
  return createPortal(children, container);
};

export default ClientOnlyPortal;
```

**使用示例：**

```jsx
function App() {
  return (
    <div className="App">
      <h1>Hello Portal</h1>
      
      <ClientOnlyPortal selector="#modal-root">
         <div className="modal">
            我是被传送的模态框！
         </div>
      </ClientOnlyPortal>
    </div>
  );
}
```

## 4. 应用场景

### Modal (模态框)

模态框通常需要覆盖整个页面，并且不受父级 `overflow: hidden` 的影响。

```jsx
import { createPortal } from 'react-dom';

function Modal({ children, onClose }) {
  return createPortal(
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        {children}
      </div>
    </div>,
    document.body // 渲染到 body
  );
}
```

### Tooltip (提示框)

提示框需要精确定位，且不被父级容器截断。

### Dropdown (下拉菜单)

防止下拉菜单被父容器的滚动条遮挡。

## 5. 深入理解：Portal 事件冒泡

这个概念初看起来反直觉，因为它与我们熟知的 DOM 事件冒泡不一致。让我们通过对比来理解。

### 核心冲突：DOM 树 vs React 树

1. **物理结构 (DOM Tree)**:
    - Portal 将子元素渲染到了其他地方（比如 `document.body`）。
    - 在 DOM 结构上，子元素和父组件可能相隔十万八千里，完全没有父子关系。
    - **浏览器原生事件**确实只会沿着 DOM 树冒泡。

2. **逻辑结构 (React Component Tree)**:
    - 在 React 的代码里，`<Portal>` 依然写在 `<Parent>` 组件里。
    - React 维护了一棵自己的"组件树"。
    - **React 合成事件**是沿着这棵"组件树"冒泡的。

### 代码实证

```jsx
// 1. 定义一个 Portal 组件，把内容渲染到 body
const Modal = ({ children }) => {
  return ReactDOM.createPortal(
    <button>{children}</button>,
    document.body // 挂载目标是 body
  );
};

// 2. 定义父组件
class Parent extends React.Component {
  handleClick = () => {
    // 关键点：这里会被触发！
    console.log('父组件捕获到了点击事件');
  };

  render() {
    return (
      <div onClick={this.handleClick} className="parent-box">
        <h3>我是父组件</h3>
        {/* 虽然 Modal 里的 button 被渲染到了 body，但这里它是 Parent 的子组件 */}
        <Modal>点击我</Modal>
      </div>
    );
  }
}
```

### 发生了什么？

1. 用户点击 `button`。
2. **浏览器层面**：事件沿着 DOM 树冒泡：`button` -> `body` -> `html`。注意，它**不经过** `div.parent-box`。
3. **React 层面**：React 的根事件代理捕获到了这个事件。
4. React 查找组件树，发现 `button` 是 `Modal` 的子节点，`Modal` 是 `Parent` 的子节点。
5. React 模拟冒泡，依次触发：`button` 的 onClick -> `Parent` 的 onClick。

这就是为什么说“即使在 DOM 树中并不是父子关系，事件依然可以冒泡”的原因。

## 6. 常见问题

### Q1: Portal 的事件冒泡机制是怎样的？

**答**：
虽然 Portal 渲染的元素在 DOM 树中可能位于很远的地方（例如直接挂在 `body` 下），但在 **React 虚拟 DOM 树**中，它仍然是父组件的子节点。
因此，React 的合成事件系统（Synthetic Event）会按照 React 组件树的层级进行冒泡。这意味着在 Portal 内部触发的事件，可以被其 React 父组件捕获，即使在 DOM 结构上它们并无父子关系。

### Q2: 为什么需要 Portal？

**答**：
主要解决 CSS 布局问题。
当父组件具有 `overflow: hidden` 或 `z-index` 属性时，子组件如果需要“跳出”父容器的视觉限制（如全屏遮罩、悬浮层），直接在父组件内部渲染会受到 CSS 堆叠上下文（Stacking Context）和裁剪（Clipping）的限制。Portal 允许我们将子组件渲染到 DOM 树的顶层（如 `document.body`），从而规避这些样式限制，同时保留 React 组件树的逻辑关系（如 Context 共享、事件冒泡）。

### Q3: Portal 与 Context 的关系？

**答**：
Portal 仅仅改变了 DOM 节点的挂载位置，不影响 React 组件树的结构。因此，Context 可以正常穿透 Portal，子组件依然可以消费父组件提供的 Context。

### Q4: createPortal 的生命周期？

**答**：
Portal 组件的生命周期与普通 React 组件完全一致。当 Portal 被挂载、更新或卸载时，其子组件也会触发相应的生命周期方法。
