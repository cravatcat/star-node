# 2.1 JSX 语法解析

## 1. 概念讲解

* **JSX (JavaScript XML)**: 是一种 JavaScript 的语法扩展，允许我们在 JavaScript 中编写类似 HTML 的代码。
* **本质**: JSX 并不是浏览器能直接理解的语法，它只是 **Syntactic Sugar (语法糖)**。在构建阶段（Build Time），Babel 等工具会将 JSX 编译成标准的 JavaScript 函数调用，即 `React.createElement()`。

例如：

```jsx
const element = <h1 className="greeting">Hello, world!</h1>;
```

会被编译为：

```javascript
const element = React.createElement(
  'h1',
  { className: 'greeting' },
  'Hello, world!'
);
```

## 2. 实现思路：JSX → Babel → React.createElement()

整个流程分为三个步骤：

1. **编写**: 开发者编写 JSX 代码。
2. **编译**: Babel 解析 JSX 语法，将其转换为 `React.createElement` 调用嵌套。
3. **运行**: 浏览器执行 `React.createElement`，生成虚拟 DOM 对象（JavaScript 对象）。

### 为什么组件首字母必须大写？

React 的 JSX 编译器（Babel）需要通过首字母大小写来区分 **原生 DOM 标签** 和 **自定义组件**。

* **小写首字母**（如 `<div>`）：被解析为字符串 `'div'`，传给 `React.createElement`，最终创建 HTML 标签。
* **大写首字母**（如 `<App />`）：被解析为变量 `App`，传给 `React.createElement`，React 知道这是一个组件。

## 3. 模拟实现：简易 JSX 编译器

为了理解 JSX 是如何被解析的，我们可以写一个极其简单的编译器（Parser），将类似 HTML 的字符串转换为类似 `React.createElement` 的调用结构（或者直接转换为 VDOM 对象）。

*注意：真实的 JSX 编译是在构建时由 Babel 完成的 AST 转换，这里仅为运行时模拟思路。*

```javascript
// 目标：将 template string 解析为 VDOM 对象
// const jsx = '<div id="app" class="container">Hello <span style="color: red">World</span></div>';

function parseJSX(template) {
  // 1. 简单的正则匹配标签
  // 这只是一个非常简陋的演示，无法处理嵌套复杂情况
  const tagRegex = /<(\w+)([^>]*)>(.*?)<\/\1>/;
  
  const match = template.match(tagRegex);
  
  if (!match) {
    // 如果是纯文本
    return template;
  }
  
  const [fullStr, tagName, attrsStr, childrenStr] = match;
  
  // 2. 解析属性
  const props = {};
  const attrRegex = /(\w+)="([^"]*)"/g;
  let attrMatch;
  while ((attrMatch = attrRegex.exec(attrsStr)) !== null) {
    props[attrMatch[1]] = attrMatch[2];
  }
  
  // 3. 递归解析子节点 (简化版，假设只有一个子节点或者全是文本)
  // 真实场景需要完整的 Tokenizer 和 Parser
  let children = [];
  const childMatch = childrenStr.match(tagRegex);
  if (childMatch) {
      children.push(parseJSX(childrenStr));
  } else if (childrenStr) {
      children.push(childrenStr);
  }

  // 4. 返回 VDOM 结构 (模拟 React.createElement 的返回值)
  return {
    type: tagName,
    props: {
      ...props,
      children: children.length === 1 ? children[0] : children
    }
  };
}

// 测试
const jsxStr = '<div id="app">Hello</div>';
console.log(JSON.stringify(parseJSX(jsxStr), null, 2));

/* 输出:
{
  "type": "div",
  "props": {
    "id": "app",
    "children": "Hello"
  }
}
*/
```

## 4. 常见问题

### Q1: 浏览器能直接运行 JSX 吗？

**答**：
不能。浏览器只能执行 JavaScript。JSX 必须经过编译器（如 Babel）转换为标准的 JavaScript (`React.createElement` 或 `_jsx` runtime) 才能在浏览器中运行。

### Q2: 为什么 React 组件首字母必须大写？

**答**：
为了让 Babel 编译器区分原生 HTML 标签和自定义 React 组件。

* `<div />` 编译为 `React.createElement('div')` （字符串类型）
* `<MyComponent />` 编译为 `React.createElement(MyComponent)` （引用变量）

### Q3: React 必须使用 JSX 吗？

**答**：
不是必须的。你可以直接手写 `React.createElement`，但 JSX 提供了更好的可读性和开发体验，且更接近 HTML 结构，易于维护。

### Q4: 现在的 React (v17+) 还需要 `import React from 'react'` 吗？

**答**：
在 React 17 之前，JSX 会被编译为 `React.createElement`，所以必须引入 `React`。
在 React 17 及之后，引入了新的 JSX Transform，JSX 会被编译为 `_jsx` 函数（来自 `react/jsx-runtime`），因此不再需要在每个文件中显式引入 `React`（除非你要用 Hooks 或其他 React 导出）。
