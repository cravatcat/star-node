# 3.1 函数组件 vs 类组件

## 1. 概念讲解

React 组件主要分为两种形式：**函数组件 (Functional Component)** 和 **类组件 (Class Component)**。

* **函数组件**：本质上是 JavaScript 函数，接收 props 作为参数，返回 React 元素。在 React 16.8 之前也被称为“无状态组件”。
* **类组件**：ES6 类，继承自 `React.Component`，拥有 state 和生命周期方法。

随着 React Hooks 的引入，函数组件获得了处理状态和副作用的能力，逐渐成为主流。

## 2. 函数组件

### 2.1 核心特点

* **语法简洁**：没有 `this`，代码量更少。
* **思维模型**：更符合“UI 是数据的映射” (`UI = f(data)`) 的理念。
* **闭包捕获**：函数组件会捕获渲染时的值（Capture Value），这在异步操作中尤为重要。

### 2.2 模拟实现：函数组件渲染器

函数组件的本质就是一个执行函数。

```javascript
// 1. 定义函数组件
function Welcome(props) {
  return `<h1>Hello, ${props.name}</h1>`;
}

// 2. 模拟渲染器
function renderFunctionalComponent(Component, props) {
  // 直接调用函数，传入 props
  const element = Component(props);
  console.log('Rendered:', element);
  return element;
}

// 使用
renderFunctionalComponent(Welcome, { name: 'React' });
// Output: Rendered: <h1>Hello, React</h1>
```

## 3. 类组件

### 3.1 核心特点

* **面向对象**：使用继承、封装。
* **生命周期**：提供 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 等钩子。
* **State 管理**：通过 `this.state` 和 `this.setState` 管理内部状态。
* **`this` 指向**：需要手动绑定 `this` 或使用箭头函数。

### 3.2 模拟实现：生命周期管理系统

我们可以模拟一个简易的类组件基类和挂载过程，展示生命周期的触发时机。

```javascript
// 1. 模拟 React.Component 基类
class Component {
  constructor(props) {
    this.props = props;
    this.state = {};
  }

  setState(partialState) {
    // 简单合并 state
    this.state = { ...this.state, ...partialState };
    // 触发更新 (模拟)
    console.log('--- State Updated, Trigger Re-render ---');
    const instance = this;
    // 重新调用 render
    const newVNode = instance.render();
    // 触发 componentDidUpdate (简化逻辑)
    if (instance.componentDidUpdate) {
      instance.componentDidUpdate();
    }
  }
}

// 2. 模拟挂载函数
function mountComponent(ComponentClass, props) {
  // 实例化
  const instance = new ComponentClass(props);
  
  // 渲染
  const element = instance.render();
  console.log('Initial Render:', element);
  
  // 挂载完成，触发 componentDidMount
  if (instance.componentDidMount) {
    instance.componentDidMount();
  }
  
  return instance;
}

// --- 使用示例 ---

class MyCounter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  componentDidMount() {
    console.log('✅ componentDidMount: 组件已挂载');
  }

  componentDidUpdate() {
    console.log('🔄 componentDidUpdate: 组件已更新');
  }

  increment() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return `Counter: ${this.state.count}`;
  }
}

// 运行模拟
console.log('--- Start Mount ---');
const counterInstance = mountComponent(MyCounter, {});
// Output: 
// Initial Render: Counter: 0
// ✅ componentDidMount: 组件已挂载

console.log('--- User Click ---');
counterInstance.increment();
// Output:
// --- State Updated, Trigger Re-render ---
// 🔄 componentDidUpdate: 组件已更新
```

## 4. 常见问题

### Q1: 函数组件与类组件的区别？

**答**：

1. **心智模型**：函数组件捕获渲染时的值（Capture Value），类组件依赖 `this`（Mutable）。
2. **代码量**：函数组件更简洁，便于复用逻辑（Hooks）。
3. **性能**：现代浏览器中差异微乎其微，但 React 团队侧重优化函数组件。
4. **功能**：在 Hooks 出现前，函数组件无法使用 State 和 Lifecycle；Hooks 出现后，函数组件几乎能做所有类组件能做的事（除了 Error Boundary 等少数生命周期）。

### Q2: 为什么说函数组件捕获了渲染值？

**答**：
在函数组件中，`props` 和 `state` 是不可变的。每次渲染都是一次独立的函数调用，拥有独立的闭包。
而在类组件中，`this` 是可变的，`this.props` 永远读取最新的属性。如果在异步操作（如 setTimeout）回调中读取 `this.props`，可能会读到 UI 更新后的新值，而不是触发操作时的旧值。

### Q3: 生命周期方法如何对应 Hooks？

| 类组件生命周期 | Hooks 等效写法 |
| :--- | :--- |
| `componentDidMount` | `useEffect(() => { ... }, [])` |
| `componentDidUpdate` | `useEffect(() => { ... }, [deps])` |
| `componentWillUnmount` | `useEffect(() => { return () => { ... } }, [])` |
| `shouldComponentUpdate` | `React.memo` (包裹组件) |
| `getDerivedStateFromProps` | 渲染时直接计算 state |

### Q4: 为什么 Hooks 不能在循环、条件或嵌套函数中调用？

**答**：
React 依赖 Hooks 调用的顺序来将 state/effect 与组件状态对应起来。如果在条件语句中调用，可能会导致每次渲染调用的 Hooks 数量或顺序不一致，从而导致状态错乱。
